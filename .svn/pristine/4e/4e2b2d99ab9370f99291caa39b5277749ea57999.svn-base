\documentclass{llncs}


%%%%%%%%%%%%%%%%%%%%%%%% General Packages %%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{pdflscape}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath,mathtools}
\usepackage{inputenc}
\usepackage{hyperref}
\usepackage{paralist}   % Required for compactum
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{threeparttable}
\usepackage[table]{xcolor}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\usepackage{enumerate}
\usepackage{xspace}
\usepackage{multirow}
\usepackage{colortbl}
\usepackage{enumitem}
\usepackage{appendix}

% For theorems
% \newtheorem{theorem}{Theorem}

\usepackage{tikz}
\usetikzlibrary{decorations.pathreplacing}
\usetikzlibrary{arrows}
\usetikzlibrary{positioning}
%%%%%%%%%%%%%%%%%%%%%%%% Custom Macros %%%%%%%%%%%%%%%%%%%%%%%%

% References
% -------------------------------------------------------
\newcommand{\figref}[1]{{Figure}~\ref{#1}}      % Figure
\newcommand{\tabref}[1]{{Table}~\ref{#1}}       % Table
\newcommand{\secref}[1]{{Section}~\ref{#1}}     % Section
\newcommand{\appref}[1]{{Appendix}~\ref{#1}}    % Appendix
\newcommand{\defref}[1]{{Definition}~\ref{#1}}  % Definition
\newcommand{\thref}[1]{{Theorem}~\ref{#1}}      % Theorem
\newcommand{\remref}[1]{{Remark}~\ref{#1}}      % Remark
% -------------------------------------------------------

% Description
% -------------------------------------------------------
\newcommand{\desc}[1]{\bigskip\noindent\textbf{#1}}

% NEWFUCTION-related
% -------------------------------------------------------
\renewcommand{\AE}{\ensuremath{\mathrm{AE}}\xspace}
\newcommand{\key}{\ensuremath{\mathit{key}}}
\newcommand{\hasht}{\ensuremath{\mathit{ht}}}
\newcommand{\tstamp}{\ensuremath{\mathit{ts}}}
\newcommand{\meta}{\ensuremath{\mathit{meta}}} %was hasht
\newcommand{\nonce}{\ensuremath{\mathit{nonce}}} %was tstamp
\newcommand{\msg}{\ensuremath{\mathit{msg}}}
\newcommand{\ctxt}{\ensuremath{\mathit{ctxt}}}
\newcommand{\auth}{\ensuremath{\mathit{auth}}}
\newcommand{\fish}{\ensuremath{\mathrm{3fish}}\xspace}
\newcommand{\LRW}{\ensuremath{\mathrm{LRW}}\xspace}
\newcommand{\LRWa}{\ensuremath{\mathrm{LRW1}}\xspace}
\newcommand{\LRWb}{\ensuremath{\mathrm{LRW2}}\xspace}
\newcommand{\TwSp}{\ensuremath{\mathrm{TwSp}}\xspace}
\newcommand{\Sp}{\ensuremath{\mathrm{Sp}}\xspace}
\newcommand{\keccak}{\ensuremath{\pi_{\mathrm{keccak}}}\xspace}
\newcommand{\IKS}{\ensuremath{\mathrm{IKS}}\xspace}

% Others
% -------------------------------------------------------
\newcommand{\etal}{et al.}
\newcommand{\xor}{\oplus}
\newcommand{\getR}{\xleftarrow{{\scriptscriptstyle\$}}}
\newcommand{\tE}{\widetilde{E}}
\newcommand{\tpi}{\widetilde{\pi}}
\newcommand{\func}{\mathsf{Func}}
\newcommand{\perm}{\mathsf{Perm}}
\newcommand{\tperm}{\widetilde{\mathsf{Perm}}}
\newcommand{\RO}{\mathcal{RO}}
\newcommand{\bin}[1]{\{0,1\}^{#1}}
\newcommand{\bink}{\bin{\kappa}}
\newcommand{\bint}{\bin{\leq\tau}}
\newcommand{\bins}{\bin{\sigma}}
\newcommand{\binm}{\bin{\leq\mu}}
\newcommand{\binn}{\bin{\leq\nu}}
\newcommand{\bina}{\bin{\alpha}}
\newcommand{\adv}[2]{\ensuremath{\mathbf{Adv}_{#2}^{\mathrm{#1}}}}
\newcommand{\advsprp}[1]{\adv{\widetilde{sprp}}{#1}}
\newcommand{\advcpa}[1]{\adv{cpa}{#1}}
\newcommand{\advauth}[1]{\adv{auth}{#1}}
\newcommand{\A}{\mathcal{A}}
\newcommand{\calK}{\mathcal{K}} %key
\newcommand{\calT}{\mathcal{T}} %cipher-tweak
\newcommand{\calM}{\mathcal{M}} %cipher-in
\newcommand{\calC}{\mathcal{C}} %cipher-out
\newcommand{\pad}{\mathsf{pad}}
\newcommand{\unpad}{\mathsf{unpad}}
\definecolor{lightgray}{gray}{0.9}
\newcommand{\lambdamax}{\lambda_{\mathrm{max}}}
% -------------------------------------------------------


% Personal Comments
% -------------------------------------------------------
\newcommand{\filipe}[1]{{\color{red}\textsf{Filipe:} \emph{#1}}}
\newcommand{\kimmo}[1]{{\color{blue}\textsf{Kimmo:} \emph{#1}}}
\newcommand{\bart}[1]{{\color{orange}\textsf{Bart:} \emph{#1}}}
\newcommand{\alert}[1]{{\color{red}\emph{#1}}}
% -------------------------------------------------------




\begin{document}

\title{Improving the Sphinx Mix Network}
% \author{Filipe Beato\inst{1} \and Kimmo Halunen\inst{2} \and Bart Mennink\inst{1}}
% \institute{
%   Dept. Electrical Engineering, ESAT/COSIC, KU Leuven, and iMinds, Belgium\\
%   \email{\{filipe.beato,bart.mennink\}@esat.kuleuven.be} \and
%   VTT Technical Research Center of Finland, Oulu, Finland\\
%   \email{kimmo.halunen@vtt.fi}
% }
%\author{}\institute{}


\maketitle

\begin{abstract}
    Secure mix networks consider the presence of multiple nodes that relay encrypted messages from one node to another in such a way that anonymous communication can be achieved. We consider the Sphinx mix formatting protocol by Danezis and Goldberg (IEEE Security and Privacy 2009), and analyze its use of symmetric-key cryptographic primitives. We scrutinize the reliance on multiple distinct primitives, as well as the use of the ancient LIONESS cipher, and suggest various paths towards improving the security and efficiency of the protocol.

    \keywords{Sphinx; mix network; LIONESS; authenticated encryption; sponge}
\end{abstract}

\section{Introduction}\label{sec:intro}
    With the large growth of Internet services, modern users rely more on digital and ubiquitous communications. In this digital domain, privacy needs to be protected against the very nature of the communications, which tend to be easily traceable and produce massive amounts of metadata. Such a task requires some cryptographic methods. Hiding the metadata of communications is hard, but there are some systems, called mix networks, that provide such capabilities. One recent example is the Sphinx~\cite{sp/DanezisG09} mix network, that is in wide use in privacy protecting applications. The Sphinx mix network format provides security against powerful adversaries and also good communications possibilities such as replies, which are not easily available in other mix network formats.
    
    The Sphinx protocol (see \secref{sec:sphinx}) uses internally a plurality of symmetric-key primitives. At first, there is the SHA-2 hash function used for hashing. The function additionally includes a HMAC mode~\cite{DBLP:conf/crypto/BellareCK96} to support message authentication. Then, Sphinx relies on the LIONESS blockcipher~\cite{DBLP:conf/fse/AndersonB96a}, an encryption functionality that is made out of the SEAL stream cipher and a keyed version of the SHA-1 hash function, and evaluates these functions on the message via a Feistel structure. In addition, Sphinx uses a pseudorandom generator to generate entropy for the key. All of these symmetric-key primitives are used in a strongly intertwined manner.

    The LIONESS blockcipher is proven to be secure, under the assumption that the underlying primitives SEAL and SHA-1 are sufficiently secure~\cite{DBLP:conf/fse/AndersonB96a}, therewith making it particularly useful for Sphinx because of its goal to achieve provable security. However, LIONESS dates back to 1996, and has been outpaced by reality. Attacks on SEAL~\cite{DBLP:conf/fse/Fluhrer01a} and SHA-1~\cite{DBLP:conf/asiacrypt/CanniereR06,DBLP:conf/crypto/KarpmanPS15,DBLP:conf/eurocrypt/Stevens13,DBLP:conf/eurocrypt/StevensKP16,DBLP:conf/crypto/WangYY05a}, the most recent result being a free-start collision attack on the full SHA-1, shine a negative light on the security of the LIONESS mode.

   % This state of affairs---security issues in LIONESS and the effective use of multiple distinct symmetric-key cryptographic primitives---underscores the importance of re-investigating Sphinx from a symmetric-key perspective.

    \subsection{Our Contribution}\label{sec:intro-our}
        Most importantly, we suggest to replace the encryption and authentication functionalities by one \emph{authenticated encryption} functionality. This optimization allows for improved security as, unlike in the original Sphinx, the payload now gets authenticated without any efficiency cost. Various existing solutions to authenticated encryption exist (see \secref{sec:intro-related} for a discussion on relevant works in this direction), but not all schemes are suitable. In this work, we suggest two approaches for authenticated encryption that are particularly suited for Sphinx. As a bonus, both approaches allow for an elimination of various symmetric-key primitive calls, or more formally, for merging various calls into one. This, consequently, contributes to the simplicity and efficiency of the design.

        The first proposal in \secref{sec:ae-duplex} is based on the keyed version of the sponge, which has found recent interest in the design of SHA-3~\cite{BDPA07,BDPA11}. In more detail, the authenticated encryption scheme can be seen as an adaption of the full-state SpongeWrap~\cite{BDPA11-SAC,asiacrypt/MenninkRV15}. It internally uses a large unkeyed permutation, the state of which is separated into a capacity and a rate. The capacity determines the security bound, and the rate determines the speed at which data is processed. By using a large permutation, one can make a proper balance between the capacity and the rate, and therewith achieve a high level of security. However, the scheme inherently requires nonce respecting behavior: every new evaluation of the authenticated encryption scheme should be initialized with a unique nonce.

        The second proposal in \secref{sec:ae-bc} is blockcipher based, and is resistant to nonce reuse. The design of our second proposal is somewhat orthogonal to that of conventional nonce reuse resistant authenticated encryption schemes such as~\cite{DBLP:conf/asiacrypt/AndreevaBLMTY13,DBLP:conf/eurocrypt/Minematsu14,DBLP:conf/acisp/DattaN14,DBLP:conf/eurocrypt/HoangKR15}: while other designs consist of a mode built on top of AES, we follow a ``tweakable tweakable blockcipher'' approach. In other words, we give a powerful construction of a tweakable blockcipher mode on top of a tweakable blockcipher, in such a way that the scheme allows for sufficiently large message and associated data, while still being quite simple and nonce reuse resistant. For a specific instantiation of the construction, we suggest Threefish, a tweakable blockcipher with $1024$-bit state by Ferguson et al.~used for the Skein hash function family~\cite{FLS+11}.\footnote{The most prominent alternative solutions were the use of (i) a large permutation (such as the Keyak~\cite{BDP+15} or Pr{\o}st~\cite{KLL+14} permutation) in a tweakable Even-Mansour mode~\cite{DBLP:conf/crypto/CogliatiLS15} and (ii) the TWEAKEY tweakable blockcipher by Jean et al.~\cite{DBLP:conf/asiacrypt/JeanNP14,JNP15Deoxys,JNP15Joltik}. However, the Keyak permutation is known to have an expensive inverse, and the other solutions have a state size which is too small for our purposes.} Threefish has withstood a wide variety of cryptanalysis~\cite{DBLP:conf/asiacrypt/AumassonCMOPV09,DBLP:conf/ispec/ChenJ10,FLS+11,DBLP:conf/fse/KhovratovichN10,DBLP:conf/fse/KhovratovichNPS15,DBLP:conf/asiacrypt/KhovratovichNR10,DBLP:conf/ctrsa/LeurentR12,DBLP:conf/sacrypt/YuCW12}.

        In \secref{sec:improvedsphinx}, we apply our schemes of \secref{sec:ae-duplex} and \secref{sec:ae-bc} to the Sphinx format. The new Sphinx format of \figref{fig:improvedsphinx} improves over the earlier one (i) in terms of simplicity, (ii) in terms of efficiency, and (iii) in terms of security.

    \subsection{Related Work on Authenticated Encryption}\label{sec:intro-related}
        Authenticated encryption (AE) enjoys a long and steady line of research, and the ongoing CAESAR competition~\cite{CAESAR} for the design of new AE schemes has induced renewed attention to the field. The classical approach to design AE schemes is to build the generic mode of operation on top of a blockcipher (usually AES) in order to process data blocks iteratively \cite{DBLP:conf/asiacrypt/AndreevaBLMTY13,DBLP:conf/fse/BellareRW04,DBLP:conf/acisp/DattaN14,DBLP:conf/eurocrypt/HoangKR15,DBLP:conf/fse/KrovetzR11,DBLP:conf/eurocrypt/Minematsu14,DBLP:conf/asiacrypt/Rogaway04,DBLP:conf/ccs/RogawayBBK01}. A more novel approach is to design AE based on permutations. The most well-known approach is SpongeWrap by Bertoni \etal~\cite{BDPA11-SAC} which got recently generalized by Jovanovic \etal~\cite{DBLP:conf/asiacrypt/JovanovicLM14} and Mennink \etal~\cite{asiacrypt/MenninkRV15}, and various CAESAR submissions follow this idea \cite{ABB+15,AJN15,BDP+15,GMS15,DEMS15,MGH+15,SB15}. Different permutation based approaches include APE~\cite{DBLP:conf/fse/AndreevaBBLMMY14} and PAEQ~\cite{DBLP:conf/isw/BiryukovK14}.

        The sponge based proposal in this work follows the literature. Regarding our blockcipher based approach, we have deviated from the state of the art. The reason is that conventional modes often entail overhead, e.g., in the form of padding, and the security level is in the end dominated by what the underlying primitive offers. For blockcipher based modes, using AES internally delivers at most $128$-bit security, and often there exist already distinguishability attacks in complexity of about $2^{64}$ (cf.~Bellare \etal~\cite{BDJR97}). Note that for messages of, say, $1024$ bits, a classical AES based mode still requires at least $8$ AES evaluations. We remark that also AEZ~\cite{DBLP:conf/eurocrypt/HoangKR15}, or more detailed the latest version v4 in the CAESAR competition~\cite{HKR15AEZ}, is also inherently a mode based on 4 and 10 rounds of AES, and has $64$-bit security as well. Recent cryptanalysis on AEZ~\cite{DBLP:conf/asiacrypt/FuhrLS15,Mennink16} has moreover shined a negative light on its security.

\section{Sphinx Mix Format}\label{sec:sphinx}
    Mix networks rely on mix message formats that provide efficiency and security properties. Sphinx~\cite{sp/DanezisG09} is the most compact cryptographic mix message format, which is provably secure and efficient. To deliver such properties, Sphinx relies on the \emph{Sphinx blinding logic} technique for generating a session key consisting of nested MAC computations over the public pseudonyms of each predecessor mix. The private key associated to the public key (i.e., pseudonym) is only known by the user, while the session key is used for the encryption of the payload message. A high-level depiction of Sphinx is given in \figref{fig:sphinx}.
    \begin{figure}[t]
        \centering
        \resizebox{0.8\linewidth}{!}{%
        \begin{tikzpicture}%
        [%
            auto,font=\small\sffamily,
            myarrow/.style={-angle 60,>=stealth',shorten >=1pt}
        ]
            % Top rectangle
            \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=2pt] (7,4) -- (0,4);
            \node at (3.5,5) {Sphinx Header};

            \draw [fill=white] (0,3) rectangle (1,4);
            \node at (0.5,3.5) {$\alpha$};
            \draw [fill=white] (1.1,3) rectangle (5,4);
            \node at (3,3.5) {$\beta$};
            \draw [fill=white] (5.1,3) rectangle (7,4);
            \node at (6,3.5) {$\gamma$};
            %
            \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=2pt] (10,4) -- (7.1,4);
            \node at (8.5,5) {Payload};
            \draw [fill=white] (7.1,3) rectangle (10,4);
            \node at (8.5,3.5) {$\delta$};% $\tau = t - \mu$};
            

            % sphinx header block
            \draw [fill=white] (1,1) rectangle (5.5,2);
            \node[font=\normalsize] at (3.25,1.5) {Sphinx Mix Header};

 
            % Mac 2 block
            \draw [fill=gray!10] (5.6,0.4) rectangle (6.4,1);
            \node[font=\scriptsize,align=center] at (6,0.7) {MAC};


            % encrypt block
            \draw [fill=gray!30,very thick] (7.5,1) rectangle (9.5,2);
            \node[font=\small,text width=2cm,align=center] at (8.5,1.5) {Encryption module};

            % Bottom rectangles ....
            % left
            \draw [fill=white] (0,-1) rectangle (1,0);
            \node at (0.5,-0.5) {$\alpha'$};
            \draw [fill=white] (1.1,-1) rectangle (5,0);
            \node at (3,-0.5) {$\beta'$};        
            \draw [fill=white] (5.1,-1) rectangle (7,0);
            \node at (6,-0.5) {$\gamma'$};
            \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=2pt] (0,-1) -- (10,-1);
            \node at (5,-1.75) {Route to Mix $n'$};

            \draw [fill=white] (7.1,-1) rectangle (10,0);
            \node at (8.5,-0.5) {$\delta'$};

            \node[font=\normalsize\sffamily] at (-0.1,2.3) {Mix $n$};
            \node[font=\normalsize\sffamily] (secret) at (-0.1,1.9) {secret $x_n$};

            \begin{scope}[myarrow,thick]
              \draw (secret) |- (1,1.5);
              \draw (5.5,1.55) -- (7.5,1.55);
              \draw (0.5,3) -- (0.5,2.5) -- (1.5,2.5) -- (1.5,2); % alpha
              \draw (3,3) -- (3,2); % beta
              \draw (8.5,3) -- (8.5,2);
              \draw (6,2.5) -- (6.4,2.5);
              % 
              \draw (1.5,1) -- (1.5,0.5) -- (0.5,0.5) -- (0.5,0); % alpha
              \draw (3,1) -- (3,0); % beta
              \draw (6,3) -- (6,2.5) -- (5,2.5) -- (5,2); % gamma
              \draw (8.5,1) -- (8.5,0);
              \draw (3,0.7) -- (5.6,0.7);
              \draw (6,1.55) -- (6,1);
              \draw (6,0.4) -- (6,0);
            \end{scope}
            

            % concat
            \node at (6.5,1.8) {session key $s_n$};
            \node[font=\scriptsize,text width=1cm, align=center] at (6.8,2.5) {Check MAC};
            \node at (4.5,0.4) {$\beta'$};
            % 
        \end{tikzpicture}
        }
        \caption{High-level description of Sphinx~\cite{sp/DanezisG09} to process a Sphinx message $( (\alpha,\beta,\gamma),\delta)$ into $( (\alpha',\beta',\gamma'),\delta')$ at Mix $n$ with the secret $x_n$. Key derivation $s_n = \mathsf{keyderive}(\alpha, x_n)$ and the blinding $(\alpha',\beta') = \mathsf{blinding}(\alpha,\beta,\gamma,s_n)$ are omitted from the picture.}
        \label{fig:sphinx}
    \end{figure}

    Internally, Sphinx uses a plurality of cryptographic primitives. First, there are five hash functions, which are used to cryptographically hash group elements to key bit strings. Then, it uses a pseudorandom generator PRG and a MAC function for the computation of the nested MAC. Finally, it uses an encryption scheme ENC that encrypts the payload at every mix.

    The hash functions are instantiated using appropriately truncated SHA256 hash functions, and SHA256-HMAC-128 is used as the MAC function. For the encryption, Sphinx relies on the LIONESS blockcipher by Anderson and Biham~\cite{DBLP:conf/fse/AndersonB96a}. This blockcipher is made out of the SEAL stream cipher and a keyed version of the SHA-1 hash function, and evaluates these functions on the message via a Feistel structure. In more detail, denote the stream cipher by $S_k$ and the keyed hash function by $H_k$. Consider a LIONESS key $k=(k_1,k_2,k_3,k_4)$, where $k_1,k_3$ will be used to key the stream cipher and $k_2,k_4$ to key the hash function. To encrypt a message $m$, LIONESS first splits it into two blocks $m_l\|m_r\gets m$. These two blocks are then transformed using a four-round Feistel structure:
    \begin{align*}
    m_r &\gets m_r\xor S_{k_1}(m_l)\,,\\
    m_l &\gets m_l\xor H_{k_2}(m_r)\,,\\
    m_r &\gets m_r\xor S_{k_3}(m_l)\,,\\
    m_l &\gets m_l\xor H_{k_4}(m_r)\,.
    \end{align*}
    The updated $m_l\|m_r$ constitutes the ciphertext $c$.

    Due to the security parameter choices, the Sphinx construction needs an encryption scheme with a state of at least 1408 bits plus the message length. Based on this, LIONESS appears to be a good option as it has the potential to have a large state and thus act as the permutation required by the Sphinx system. In addition, LIONESS enjoys a security proof if the underlying hash function SHA-1 and stream cipher SEAL are secure~\cite{DBLP:conf/fse/AndersonB96a}. However, the security of LIONESS is undermined by the results mentioned in the introduction.
    
    
    % much has happened since the introduction from LIONESS in 1996. In more detail, attacks on SEAL~\cite{DBLP:conf/fse/Fluhrer01a} and SHA-1~\cite{DBLP:conf/asiacrypt/CanniereR06,DBLP:conf/crypto/KarpmanPS15,DBLP:conf/eurocrypt/Stevens13,DBLP:conf/eurocrypt/StevensKP16,DBLP:conf/crypto/WangYY05a}, the most recent result being a free-start collision attack on the full SHA-1, shine a negative light on the security of the LIONESS mode.

    Besides the doubtful use of LIONESS in the first place, it is noteworthy that Sphinx uses different symmetric-key primitives for various purposes: i.e., SHA-1 is used in LIONESS and SHA-2 for hashing and MACing. These functions are often intertwined, and particularly, three of the cryptographic hash functions are used to transform a secret non-identity group element $s$ to secret keys to the PRG, MAC, and ENC. In other words, denoting these three hash functions as $H_{\mathrm{PRG}}$, $H_{\mathrm{MAC}}$, and $H_{\mathrm{ENC}}$, Sphinx calls the PRG, MAC, and ENC functionalities as follows:
    \begin{align*}
    &\mathrm{PRG}(H_{\mathrm{PRG}}(s))\,,\\
    &\mathrm{MAC}(H_{\mathrm{MAC}}(s),m)\,,\\
    &\mathrm{ENC}(H_{\mathrm{ENC}}(s),m)\,,
    \end{align*}
    where $s$ is the secret group element, the secret session key, and $m$ denotes the data to be MACed or ENCed. The synergy between MAC and $H_{\mathrm{MAC}}$ is striking, given the designers' choice to instantiate those with SHA256-HMAC-128, and SHA256, respectively. For the case of encryption, the situation is not much clearer, given that LIONESS uses SHA-1 while $H_{\mathrm{ENC}}$ is instantiated with SHA256.

    Finally, from \figref{fig:sphinx}, it becomes apparent that $\gamma$ is a MAC of $\beta$ (using session key $s$), and $\delta$ is the encryption of the payload (under session key $s$). It turns out that, by merging these two functionalities into one \emph{authenticated encryption} scheme that authenticates $\beta$ and $\delta$ and that encrypts $\delta$, one obtains the following improvements:
    \begin{itemize}
    \item Authentication of $\beta$ and encryption of $\delta$ still persists, but authentication of $\delta$ is \emph{for free};
    \item The session key needs to be processed \emph{only once};
    \item There is no need to implement two distinct algorithms.
    \end{itemize}
    As such, our main goal in this work will be to introduce an authenticated encryption scheme that suits Sphinx, which will be done in Sections~\ref{sec:ae}-\ref{sec:ae-bc}. The potential employment of the new schemes in Sphinx will be considered in Section~\ref{sec:improvedsphinx} in such a way that the remaining above-mentioned issues (such as the redundant usage of cryptographic primitives) are resolved on the fly.

\section{Authenticated Encryption}\label{sec:ae}
    For $n\in\mathbb{N}$, $\bin{n}$ is the set of $n$-bit strings, and $\bin{\leq n}=\bigcup_{i=0}^n\bin{i}$. For two bit strings $M,N$, their concatenation is denoted by $M\|N$ and $M\xor N$ denotes their bitwise XOR. Furthermore, if $M\in\bin{\leq n-1}$, then $\pad_n(M)=M\|10^{n-1-|M|}$. For a string $N\in\bin{n}$, we define by $\unpad_n(N)$ the unique string $M\in\bin{\leq n-1}$ such that $\pad_n(M)=N$. For $m\leq n$ and $N\in\bin{n}$, we denote by $\lceil N\rceil_m$ the leftmost $m$ bits and by $\lfloor N\rfloor_{n-m}$ the rightmost $n-m$ bits of $N$, in such a way that $N=\lceil N\rceil_m\|\lfloor N\rfloor_{n-m}$.

    \subsection{Definition of Authenticated Encryption}
    Let $\mu,\nu,\alpha,\tau,\sigma\in\mathbb{N}$ be size values that satisfy $\mu\leq\nu$. Here, $\mu$ denotes the size of the message, $\nu$ the size of the ciphertext, $\tau$ the size of the associated data, and $\sigma$ the size of the nonce. The value $\alpha$ determines the size of the authentication tag. If no authentication is needed, we have $\alpha=0$.

    An authenticated encryption scheme AE is composed of three algorithms: \texttt{KeyGen}, \texttt{Enc}, and \texttt{Dec}. \texttt{KeyGen} is a randomized algorithm that gets as input $\kappa\in\mathbb{N}$ and outputs a random key $\key \leftarrow \bink$. The \texttt{Enc} and \texttt{Dec} algorithms are defined as follows:
    \begin{align*}
    \texttt{Enc}:\;\;&\bink\times\binm\times\bint\times\bins \to  \binn\times\bina\,,\\
                     &(\key, \msg, \meta, \nonce) \mapsto (\ctxt, \auth)\,,\\
    \texttt{Dec}:\;\;&\bink\times\binn\times\bina\times\bint\times\bins \to \binm\cup\{\bot\}\,,\\
                     &(\key, \ctxt, \auth, \meta, \nonce) \mapsto \msg/\bot\,.
    \end{align*}
    \texttt{Dec} outputs the unique $\msg$ satisfying $\texttt{Enc}(\key,\msg,\meta,\nonce)=(\ctxt,\auth)$, or it returns $\bot$ if no such message exists. \texttt{Enc} also outputs $\meta$ and $\nonce$. We allow for a small amount of ciphertext expansion (from $\mu$ to $\nu$ bits), as long as the encrypted ciphertext $(\ctxt,\auth,\meta,\nonce)$ is of size at most $\lambdamax$.

    \subsection{Threat Model}
    We consider an adversary $\A$ to be any entity attempting to passively access the shared information by monitoring the communication channel, with no incentive to tamper with the content. However, $\A$ is allowed to generate encryptions under a secret and unknown key. In this case, $\A$ should not learn the encrypted content, beyond that revealed in the associated data.

    More technically, adversary $\A$ has query access to $\mathtt{Enc}$ under a secret key $\key$, and it tries to find irregularities among the queries, i.e., some relation that is not likely to hold for a random function. For a function $F$, let $\func(F)$ be the set of all functions $f$ with the same interface as $F$. The advantage of an adversary $\A$ in breaking the secrecy of an authenticated encryption scheme \AE is defined as:
    \begin{align*}
    &\advcpa{\AE}(\A) = \left|
        \begin{array}{l}
        \Pr\left(\key\getR\mathtt{KeyGen}(\kappa)\;:\;\A^{\mathtt{Enc}_{\key}} = 1 \right)\:-\\[6pt]\quad\qquad\qquad\!\Pr\left(\$\getR\func(\mathtt{Enc}_{\key})\;:\;\A^{\$} = 1\right)
        \end{array} \right|\,.
    \end{align*}
    We denote by $\advcpa{\AE}(Q,T)$ the maximum advantage over all adversaries that make at most $Q$ encryption queries and operate in time $T$. Depending on the scheme, the adversary $\A$ may be limited to being nonce respecting, so that every query must be made under a different nonce. We will always explicitly note if this is the case.

    For the authenticity of $\AE$, we consider $\A$ to have access to the encryption functionality $\mathtt{Enc}$ under a secret key $\key$, and say that $\A$ \emph{forges} an authentication tag if it manages to output a tuple $(\ctxt, \auth, \meta, \nonce)\in\binn\times\bina\times\bint\times\bins$ such that $\texttt{Dec}(\key,\ctxt, \auth, \meta, \nonce)=\msg\neq\bot$ and $(\msg,\meta,\nonce)$ was never queried to $\mathtt{Enc}$ before. The forgery attempt may be made under a nonce $\nonce$ that has appeared before. The advantage of $\A$ in breaking the authenticity of authenticated encryption scheme \AE is defined as:
    \begin{align*}
    \advauth{\AE}(\A) = \Pr\left(\key\getR\mathtt{KeyGen}(\kappa)\;:\;\A^{\mathtt{Enc}_{\key}} \text{ forges} \right)\,.
    \end{align*}
    We denote by $\advauth{\AE}(Q,R,T)$ the maximum advantage over all adversaries that make at most $Q$ encryption queries, $R$ forgery attempts, and operate in time $T$.

\section{Solution 1: Sponge}\label{sec:ae-duplex}
    The Sponge functions were originally introduced by Bertoni \etal~\cite{BDPA07} for cryptographic hashing, but can also be used in a broad spectrum of keyed applications, including message authentication~\cite{ADMV15-FSE,BDPA11-SKEW,NY16,crypto/GaziPT15} and stream encryption~\cite{BDPA11-SAC,asiacrypt/MenninkRV15}. We will use the keyed sponge in the full-state duplex mode \cite{asiacrypt/MenninkRV15}, to describe an authenticated encryption scheme that is suited for the use in Sphinx. As keyed Sponges are merely stream based encryption, a unique nonce is required for every encryption.
    \begin{figure}[t]
        \centering
        \resizebox{.75\linewidth}{!}{%
        \begin{tikzpicture}
            [%
                auto,thick,%
                block/.style={draw,thick,rectangle,minimum height=5em,minimum width=5em,font=\Large},
                xor/.style={draw,circle,append after command={[shorten >=\pgflinewidth, shorten <=\pgflinewidth,] (\tikzlastnode.north) edge (\tikzlastnode.south)(\tikzlastnode.east) edge (\tikzlastnode.west)}},
                line/.style={draw, shorten <=1bp,shorten >=1bp,-angle 60}
            ]
            % box 1
            \node[block,anchor=center] (b1) at (0,0) {$\pi$};
            \begin{scope}[node distance=0.7cm]
                \node (b_nw1) at (-0.7,0.5) {};
                \node (b_sw1) at (-0.7,-0.5) {};
                \node (b_ne1) at (0.7,0.5) {};
                \node (b_se1) at (0.7,-0.5) {};
            \end{scope}
            % box 2
            \node[block,anchor=center] (b2) at (5,0) {$\pi$};
            \begin{scope}[node distance=0.7cm]
                \node (b_nw2) at (4.3,0.5) {};
                \node (b_sw2) at (4.3,-0.5){};
                \node (b_ne2) at (5.7,0.5) {};
                \node (b_se2) at (5.7,-0.5) {};
            \end{scope}
            % box 3
            \node[block,anchor=center] (b3) at (10,0) {$\pi$};
            \begin{scope}[node distance=0.7cm]
                \node (b_nw3) at (9.3,0.5) {};
                \node (b_sw3) at (9.3,-0.5){};
                \node (b_ne3) at (10.7,0.5) {};
                \node (b_se3) at (10.7,-0.5) {};
            \end{scope}

            % oplus sign
            \node[xor,scale=1.2] (op1) at (1.7,0.5) {};
            \node[xor,scale=1.2] (op2) at (6.8,0.5) {};
            \node[right of=op1,node distance=1.4cm] (dot1) {\LARGE$\cdot$};
            \node[right of=op2,node distance=1.4cm] (dot2) {\LARGE$\cdot$};
            \node[right of=b_ne3,node distance=1.2cm] (dot3) {\LARGE$\cdot$};
            %\node at (12.5,0) {$\ldots$};

            % % labels
            \begin{scope}[font=\Large,node distance=2cm]
                \node[above left of=b_nw1] (tsht) {$\nonce \parallel \meta$};
                \node[left of=b_sw1] (key1) {$key$};
            \end{scope}
            \begin{scope}[font=\Large,node distance=1.4cm]
                \node[above of=op1]  (ms1) {$\msg_1$};
                \node[above of=op2] (ms2) {$\msg_2$};
                \node[above of=dot1] (ct0) {$\ctxt_1$};
                \node[above of=dot2] (ct1) {$\ctxt_2$};
                \node[above of=dot3] (ct2) {$\auth$};
            \end{scope}
            \node[font=\large,below of=dot1,node distance=2cm] {$\ctxt = \ctxt_1 \parallel \ctxt_2$};

            \draw[line] (tsht) |- (b_nw1.west);
            \path[line] (key1) edge (b_sw1)
                        (b_ne1) edge (op1)
                        (b_se1) edge (b_sw2)
                        (op1) edge (b_nw2)
                        (b_ne2) edge (op2)
                        (b_se2) edge (b_sw3)
                        (op2) edge (b_nw3)
                        (ms1) edge (op1)
                        (ms2) edge (op2);

            \draw[-angle 60] (dot1.center) -- (ct0);
            \draw[-angle 60] (dot2.center) -- (ct1);
            \draw[-angle 60] (dot3.center) -- (ct2);
            \draw (b_ne3) -- (12.5,0.5);
            \draw (b_se2) -- (8.5,-0.5);
            \draw (b_se3) -- (12.5,-0.5);

        \end{tikzpicture}
        }
        \caption{\AE based on a Sponge. Padding of data is excluded from the figure.}
        \label{fig:Sponge}
    \end{figure}

    The realization of our authenticated encryption scheme using the sponge is dubbed $\AE^{\pi,\ell,n}$. It is indexed by a permutation $\pi$ of width $b$ and parameters $\ell$ and $n\leq b$ which specify the parsing of the message blocks: it considers at most $\ell$ message blocks of $n$ bits. The parameter $\ell$ can be arbitrarily large, but it is used to show how the length affects the security bound. $\AE^{\pi,\ell,n}$ operates on keys of size $\kappa\leq b-n$ bits, messages and ciphertexts can be of length at most $\mu=\ell\cdot n-1$ (note that the scheme does not use ciphertext expansion, hence $\mu=\nu$), and the sizes of the associated data and nonce should satisfy $\sigma+\tau\leq n-1$. The size of the authentication tag is $\alpha\leq n$ (this bound is for simplicity, the scheme generalizes to $\alpha>n$). $\AE^{\pi,\ell,n}$ is depicted in \figref{fig:Sponge}. The formal encryption and decryption functionalities are given in Algorithms~\ref{algo:piEnc} and \ref{algo:piDec}.
    % \noindent\begin{minipage}[tb]{\linewidth}
    %     \vspace{-15pt}
    \begin{algorithm}[t]
    \caption{\;\;$\mathtt{Enc}^{\pi,\ell,n}$}\label{algo:piEnc}
        \begin{algorithmic}[1]
            \Require{$(\key,\msg,\meta,\nonce)\in\bink\times\binm\times\bint\times\bins$}
            \Ensure{$(\ctxt,\auth)\in\binm\times\bina$}
            \State{$\ell'\gets\lceil (|\msg|+1)/n\rceil$}
            \State{$\msg_1\parallel\cdots\parallel \msg_{\ell'}\xleftarrow{n\text{-}\mathrm{blocks}} \pad_{\ell'\cdot n}(\msg)$}
            \State{$s_0\gets \pad_n(\nonce\|\meta)\parallel 0^{b-n-|\key|}\parallel  \key$}
            \For{$i=1,\ldots,\ell'$}
                \State{$s_i\gets \pi(s_{i-1})$}
                \State{$s_i\gets s_i \xor \big(\msg_i\parallel 0^*\big)$}
                \State{$\ctxt_i\gets \lceil s_i\rceil_n$}
            \EndFor
            \State{$s_{\ell'+1}\gets \pi(s_{\ell'})$}
            \State{\Return $(\lceil \ctxt_1\parallel\cdots\parallel \ctxt_{\ell'} \rceil_{|\msg|},\lceil s_{\ell'+1}\rceil_{\alpha})$}
        \end{algorithmic}
    \end{algorithm}
    % \vspace{-40pt}
    \begin{algorithm}[t]
    \caption{\;\;$\mathtt{Dec}^{\pi,\ell,n}$}\label{algo:piDec}
        \begin{algorithmic}[1]
            \Require{$(\key,\ctxt,\auth,\meta,\nonce)\in\bink\times\binm\times\bina\times\bint\times\bins$}
            \Ensure{$\msg\in\binm$ or $\bot$}
            \State{$\ell'\gets\lceil (|\ctxt|+1)/n\rceil$}
            \State{$\ctxt_1\parallel\cdots\parallel \ctxt_{\ell'}\xleftarrow{n\text{-}\mathrm{blocks}} \pad_{\ell'\cdot n}(\ctxt)$}
            \State{$s_0\gets \pad_n(\nonce\|\meta)\parallel 0^{b-n-|\key|}\parallel  \key$}
            \For{$i=1,\ldots,\ell'-1$}
                \State{$s_i\gets \pi(s_{i-1})$}
                \State{$\msg_i\gets \lceil s_i\rceil_n \xor \ctxt_i$}
                \If{$i<\ell'$}
                    \State{$s_i\gets \ctxt_i \parallel \lfloor s_i\rfloor_{b-n}$}
                \Else
                    \State{$s_i\gets \lceil \ctxt_i \rceil_{|\ctxt|\bmod n} \parallel \lfloor s_i\rfloor_{b-(|\ctxt|\bmod n)}$}
                \EndIf
            \EndFor
            \State{$\msg\gets \lceil \msg_1\parallel\cdots\parallel \msg_{\ell'} \rceil_{|\ctxt|}$}
            \State{$s_{\ell'+1}\gets \pi(s_{\ell'})$}
            \State{\Return $\lceil s_{\ell'+1}\rceil_{\alpha}=\auth\;?\;\msg : \bot $}
        \end{algorithmic}
    \end{algorithm}
    %     \vspace{-15pt}
    % \end{minipage}

    \subsection{Security}
    $\AE^{\pi,\ell,n}$ is in fact a full-state duplex construction~\cite{asiacrypt/MenninkRV15}, but it is easier to explain the security of the construction in terms of the Inner-Keyed Sponge (\IKS) of Andreeva \etal~\cite{ADMV15-FSE}. This construction gets as input a key $k$, an arbitrarily sized message $m$, and a natural number $\rho$, and it outputs a digest $z$ of size $\rho$. That is $\IKS^\pi(k,m,\rho) = z\in\bin{\rho}$. It is defined as the classical Sponge with an outer part of size $n$ and an inner part of size $b-n$, and with the capacity part being initialized using the key. We consider a specific case of \IKS where $\rho\leq n$, which means that the squeezing part of the Sponge takes exactly one round.

    The security of variable-input-length $\IKS:\calK\times\bin{\ast}\to\bin{n}$ based on a permutation $\pi$ is slightly different from the CPA security of \secref{sec:ae}; first, $\IKS$ is variable length, so it is compared with a random oracle $\RO:\bin{\ast}\to\bin{n}$, and second, it is based on an underlying idealized permutation $\pi$ and the adversary has two-sided oracle access to $\pi$. Denote by $\perm(\bin{b})$ the set of $b$-bit permutations. Abusing notation, we refer to the security of \IKS against an adversary that has access to either $(\IKS,\pi^{\pm})$ or $(\RO,\pi^{\pm})$, where $k\getR\calK$, $\pi\getR\perm(\bin{b})$, and $\RO$ is a random oracle, by
    $\advcpa{\IKS}(\A)$. We define by $\advcpa{\IKS}(Q,S)$ the maximum advantage over all adversaries with total complexity $Q$, that make at most $S$ primitive queries to $\pi^\pm$. The total complexity $Q$ counts the number of \emph{fresh calls} to $\pi$ if $\A$ were conversing with $\IKS$.

    Note that if no authentication is needed, then $\mathtt{Enc}^{\pi,\ell,n}$ and $\mathtt{Dec}^{\pi,\ell,n}$ do not require the computation of $s_{\ell'+1}\gets \pi(s_{\ell'})$ at the end, which saves a permutation call. Related to this, we define $\ell_\alpha$ as $\ell$, if $\alpha=0$, and $\ell+1$ otherwise.
   % \begin{align*}
   % \ell_\alpha =
   %     \begin{cases}
   %     \ell\,, \text{ if }\alpha=0\,,\\
   %     \ell+1\,, \text{ if }\alpha>0\,.
   %     \end{cases}
   % \end{align*}

    \begin{theorem}\label{thm:Sponge}
        Assume $\pi\getR\perm(\bin{b})$ is an ideal permutation. We have
        \begin{align*}
        \advcpa{\AE^{\pi,\ell,n}}(Q,T) &\leq \frac{(\ell_aQ)^2}{2^{b-n}} + \frac{\ell_aQS}{2^\kappa}\,,\\
        \advauth{\AE^{\pi,\ell,n}}(Q,R,T) &\leq \frac{(\ell_aQ)^2}{2^{b-n}} + \frac{\ell_aQS}{2^\kappa} + \frac{R}{2^\alpha}\,.
        \end{align*}
        where $S$ is the maximal number of evaluations of $\pi$ that can be made in time $T$. The adversaries are required to be \emph{nonce respecting}.
    \end{theorem}
    \begin{proof}
        Let $\A$ be an adversary that makes $Q$ queries and runs in time $T$. It has access to either $\mathtt{Enc}_\key$ or $\$$. Consider any evaluation $\mathtt{Enc}_\key$ on input of $(\msg,\meta,\nonce)$. If we define $k=0^{b-n-|\key|}\|\key$, then its output is as follows,
        %
        \begin{align*}
        \ctxt=&\;\IKS^\pi(k,\pad_n(\nonce\|\meta),n) \xor \msg_1 \parallel\\
             &\;\IKS^\pi(k,\pad_n(\nonce\|\meta)\| \msg_1,n) \xor \msg_2 \parallel\\
             &\;\cdots\,\\
             &\;\IKS^\pi(k,\pad_n(\nonce\|\meta)\| \msg_1\cdots \msg_{\ell-2},n) \xor \msg_{\ell-1} \parallel\\
             &\;\lceil\IKS^\pi(k,\pad_n(\nonce\|\meta)\| \msg_1\cdots \msg_{\ell-1},n) \xor \msg_\ell\rceil_{|\msg|\bmod n}\,,\\
        \auth=&\;\IKS^\pi(k,\pad_n(\nonce\|\meta)\| \msg_1\cdots \msg_{\ell},\alpha)
        \end{align*}
        Where abusing notation, $|\msg|\bmod n\in\{1,\ldots,n\}$. In other words, any evaluation of $\mathtt{Enc}_\key$ entails $\ell_\alpha$ evaluations of $\IKS$ (the computation of $\auth$ is omitted if $\alpha=0$). Each of these evaluations adds $1$ to the complexity (as it is simply an extension of the previous one). Thus, after $Q$ evaluations of $\mathtt{Enc}_\key$, \IKS is evaluated with a total complexity $\ell_a Q$. We replace $\IKS$ by a random oracle $\RO$. This step costs us $\advcpa{\IKS}(\ell_a Q,S)$, where $S$ is as described in the theorem statement.

        Now, for the case of secrecy, recall that $\A$ is nonce respecting. Consequently, all evaluations of $\RO$ are made for a different input. This is clear for the $\ell+1$ queries for a single evaluation; different evaluations of $\mathtt{Enc}_\key$ are made under a different $\nonce$ as the adversary is nonce respecting. Consequently, every query to $\mathtt{Enc}_\key$ is responded with a uniformly randomly generated $|\msg|$-bit value, and thus,
        \begin{align*}
        \advcpa{\AE^{\pi,\ell,n}}(Q,T) \leq \advcpa{\IKS}(\ell_a Q,S)\,.
        \end{align*}
        Next, for authenticity, it suffices to only focus on the value $\auth$. Consider any forgery attempt $(\ctxt,\auth,\meta,\nonce)$. Let $\msg$ be the message that is derived by $\mathtt{Dec}^{\pi,\ell,n}$. As the forgery needs to be non-trivial, $\RO$ has not been queried on
        \begin{align*}
        \pad_n(\nonce\|\meta)\| \msg_1\cdots \msg_{\ell}
        \end{align*}
        before. Its response $\auth$ is thus a randomly generated value and the forgery is successful with probability $1/2^\alpha$. Again using \cite{DBLP:journals/iacr/BellareGM04},
        \begin{align*}
        \advauth{\AE^{\pi,\ell,n}}(Q,R,T) \leq \advcpa{\IKS}(\ell_a Q,S) + \frac{R}{2^\alpha}\,.
        \end{align*}
        Now, in \cite{ADMV15-FSE} it is proven that\footnote{We have slightly re-interpreted the result in order to accommodate the different key length.}
        \begin{align*}
        \advcpa{\IKS}(Q',S) \leq \frac{(Q')^2}{2^{b-n}} + \frac{Q'S}{2^\kappa} \,,
        \end{align*}
        which completes the proof of both secrecy and authenticity.
    \qed\end{proof}

\section{Solution 2: Tweakable Blockcipher Based}\label{sec:ae-bc}
    The second approach is to apply a large tweakable blockcipher. A tweakable blockcipher $\tE:\calK\times\calT\times\calM\to\calM$ takes as input a key $k\in\calK$, a tweak $t\in\calT$, and a message $m\in\calM$, and outputs a ciphertext $c\in\calM$. It is a permutation for every choice of $(k,t)$.

    For our authenticated encryption functionality \AE, we will need a tweakable blockcipher with a large state $\calM$. To this end, we suggest \emph{Threefish}, a tweakable blockcipher by Ferguson et al.~used for the Skein hash function family~\cite{FLS+11}. Threefish supports block sizes of 256, 512, and 1024 bits. The key size equals the block size, and the tweak size is $128$ bits. We focus on the largest variant, Threefish-1024, which for readability we simply denote \fish:
    \begin{align*}
    \fish:\;\;&\bin{1024}\times\bin{128}\times\bin{1024} \to \bin{1024}\,,\\
                     &(k,t,m) \mapsto c\,.
    \end{align*}
    \fish can be used for authenticated encryption directly, i.e., by placing the associated data and nonce into the tweak, and encrypting  based on the secret key and this tweak. While the state size of \fish is reasonably large enough (for certain applications), the tag size is not. One way to resolve this is to employ a random oracle that maps the associated data and nonce to a string of size $128$ bits, but this would degrade the security of the construction as forgeries can be found in a complexity $2^{64}$. Another way to enlarge the tweak space without adjusting the cipher itself is by using it in a tweakable mode of operation.
    % \noindent\begin{minipage}[t]{\linewidth}
    %     \vspace{-15pt}
        \begin{algorithm}[t]
        \caption{\;\;$\mathtt{Enc}^{\LRW[\fish]}$}\label{algo:LRWEnc}
            \begin{algorithmic}[1]
                \Require{$(\key,\msg,\meta,\nonce)\in\bink\times\binm\times\    bint\times\bins$}
                \Ensure{$(\ctxt,\auth)\in\bin{\nu}\times\bina$}
                \State{$c \gets \LRW[\fish](\key,
                    \phantom{.}\pad_{1024}(\meta),\pad_{128}(\nonce),\pad_{  1024}(\msg))$}
                \State{\Return $(\lceil c\rceil_\nu,\lfloor c\rfloor_{\alpha})$}
            \end{algorithmic}
        \end{algorithm}
        % \vspace{-40pt}
        \begin{algorithm}[t]
        \caption{\;\;$\mathtt{Dec}^{\LRW[\fish]}$}\label{algo:LRWDec}
            \begin{algorithmic}[1]
                \Require{$(\key,\ctxt,\auth,\meta,\nonce)\in\bink\times\bin{\nu }\times\bina\times\bint\times\bins$}
                \Ensure{$\msg\in\binm$ or $\bot$}
                \State{$m\gets \LRW[\fish]^{-1}(\key,
                    \phantom{.}\pad_{1024}(\meta),\pad_{128}(\nonce),\ctxt\| \auth)$}
                \State{$\msg\gets \unpad_{\mu+1}(\lceil m \rceil_{\mu+1})$}
                \State{\Return $\lfloor m\rfloor_\alpha=0\;?\;\msg : \bot$}
            \end{algorithmic}
        \end{algorithm}
    % \end{minipage}

    % ----------------------------------------------------------------
    \begin{figure}[t]
        \centering
        \resizebox{.5\linewidth}{!}{%
        \begin{tikzpicture}
            [%
                auto,thick,%
                block/.style={draw,thick,rectangle,minimum height=5em,minimum width=5em},
                xor/.style={draw,circle,append after command={[shorten >=\pgflinewidth, shorten <=\pgflinewidth,] (\tikzlastnode.north) edge (\tikzlastnode.south)(\tikzlastnode.east) edge (\tikzlastnode.west)}},
                line/.style={draw, -latex',shorten <=1bp,shorten >=1bp,-angle 60}
            ]
            % box 1
            \node[block,anchor=center] (b1) at (0,0) {3fish};
            % box 2
            \node[block,anchor=center] (b2) at (4,0) {3fish};
            % oplus sign
            \node[xor,scale=1.2] (op) at (2,0) {};

            % labels
            \begin{scope}[node distance=2cm]
                \node[above of=b1] (key1) {$key$};
                \node[above of=b2] (key2) {$key$};
                \node[left of=b1]  (message) {\msg};
                \node[right of=b2] (cipher) {$\ctxt\|\auth$};
                \node[below of=b1] (tp1) {$\nonce$};
                \node[below of=b2] (tp2) {$\nonce$};
            \end{scope}
            \node[above of=op,node distance=2cm] (t) {$\meta$};
            \path[line] (b1) edge (op)
                        (op) edge (b2)
                        (message) edge (b1)
                        (b2) edge (cipher)
                        (key1) edge (b1)
                        (key2) edge (b2)
                        (tp1) edge (b1)
                        (tp2) edge (b2)
                        (t) edge (op);

        \end{tikzpicture}
        }
        \caption{\AE based on $\LRW[\fish]$. Padding of data is excluded from the figure}\label{fig:LRW}
    \end{figure}
    % ----------------------------------------------------------------

    Liskov \etal~\cite{LRW02} introduced two tweakable modes of operation: while these constructions are originally designed to add a tweak input to a blockcipher, they can equally well be applied to tweakable blockciphers themselves to enlarge the tweak space. We will consider one of these constructions, which makes two evaluations of the underlying cipher:\footnote{The other construction is less relevant as it requires an additional key and needs a universal hash function with a $1024$-bit range (or smaller, in which case the security of the construction degrades).}
    \begin{align*}
    \LRW[\fish]:\;\;&\bin{1024}\times\bin{1024}\times\bin{128}\times\bin{1024} \to \bin{1024}\,,\\
                     &(k,t,t',m) \mapsto \fish(k,t',\fish(k,t',m)\xor t)\,.
    \end{align*}
    This construction can be used to realize $\AE^{\LRW[\fish]}$ as illustrated in \figref{fig:LRW} and described in Algorithms~\ref{algo:LRWEnc} and \ref{algo:LRWDec}. It operates on keys of size $\kappa=1024$ bits, messages can be of arbitrary length but of size at most $\mu=1023-\alpha$, the nonce should be of size $\sigma\leq127$, and the associated data should be of size at most $\tau\leq1023$. The ciphertexts are of size \emph{exactly} $\nu=1024-\alpha$ bits, where $\alpha$ is the size of the authentication tag. The latter is required to make decryption possible.

    \subsection{Security}
    We formally derive the security of $\AE^{\LRW[\fish]}$ under the assumption that \fish is a secure tweakable blockcipher. The security of a tweakable blockcipher $\tE:\calK\times\calT\times\calM\to\calM$ is captured by an adversary $\A$ that has adaptive two-sided oracle access to either $\tE_k$ for some secret key $k\getR\calK$, or ideal tweakable permutation $\tpi$ with tweak space $\calT$ and message space $\calM$, and tries to distinguish both worlds. Denote by $\tperm(\calT,\calM)$ the set of tweakable permutations. We define the strong PRP security of $\tE$ as
    %
    \begin{align*}
        &\advsprp{\tE}(\A) = \left|
            \begin{array}{l}
            \Pr\left(k\getR\calK\;:\;\A^{\tE_k^{\pm}} = 1 \right) - \Pr\left(\tpi\getR\tperm(\calT,\calM)\;:\;\A^{\tpi^{\pm}} = 1\right)
            \end{array} \right|\,.
    \end{align*}
    %
    By $\advsprp{\tE}(Q,T)$ we denote the maximum security advantage of any adversary $\A$ that makes $Q$ queries and runs in time $T$.

    The security of $\AE^{\LRW[\fish]}$ follows from a result from \cite{LRW02} on the security of $\LRW$.
    \begin{theorem}\label{thm:lrw}
        Let $n=1024$ be the state size of \fish. We have
        \begin{align*}
        \advcpa{\AE^{\LRW[\fish]}}(Q,T)    &\leq \Theta\left(\frac{Q^2}{2^n}\right) + \advsprp{\fish}(2Q,T')\,,\\
        \advauth{\AE^{\LRW[\fish]}}(Q,R,T) &\leq \Theta\!\left(\!\frac{(Q\!+\!R)^2}{2^n}\!\right) + \advsprp{\fish}(2(Q+R),T') + \frac{R2^{n-\alpha}}{2^n-Q}\,,
        \end{align*}
        where $T'\approx T$. The adversaries may be \emph{nonce reusing}.
    \end{theorem}
    \begin{proof}
        We start with the secrecy of $\AE^{\LRW[\fish]}$. Let $\A$ be an adversary that makes $Q$ queries and runs in time $T$. It has access to either $\mathtt{Enc}_\key$ or $\$$. Note that $Q$ evaluations of $\AE^{\fish}$ induce $Q$ evaluations of $\LRW[\fish]$. We replace $\LRW[\fish]$ by an ideal tweakable permutation $\tpi\getR\tperm(\bin{1024+128},\bin{1024})$. Now, any query $\mathtt{Enc}^{\tpi}(\key, \msg, \meta, \nonce)$ is responded with
        \begin{align*}
        \ctxt\|\auth = \tpi(\key,\pad_{1024}(\meta),\pad_{128}(\nonce),\pad_{1024}(\msg))\,.
        \end{align*}
        Note that every fresh $\meta\|\nonce$ initiates a new instance of $\tpi$ and results in a uniformly random $1024$-bit value $\ctxt\|\auth$. On the other hand, if the adversary repeats a $\meta\|\nonce$, the value $\ctxt\|\auth$ will be generated uniformly at random from $\bin{n}$ \emph{without replacement}. In the ideal world, $\$$ always generates uniformly random responses from $\bin{1024}$. This means that $\mathtt{Enc}^{\tpi}_\key$ is indistinguishable from $\$$ up to bound ${Q\choose2}/2^n$. Thus, writing $n=1024$:
        \begin{align*}
        \advcpa{\AE^{\LRW[\fish]}}(Q,T) \leq \advsprp{\LRW[\fish]}(Q,T'') + \frac{{Q\choose2}}{2^n}\,,
        \end{align*}
        where $T''\approx T$. 

        For authenticity, the first part of the proof is identical: we replace $\LRW[\fish]$ by ideal tweakable permutation $\tpi\getR\tperm(\bin{1024+128},\bin{1024})$, where now the $Q+R$ evaluations of $\AE^{\LRW[\fish]}$ induce $Q+R$ evaluations of $\LRW[\fish]$. It remains to consider the probability to forge an authentication tag for $\AE^{\tpi}$. By \cite{DBLP:journals/iacr/BellareGM04}, it suffices to consider any attempt and sum over all $R$ attempts. Consider any forgery attempt $(\ctxt,\auth,\meta,\nonce)$. The value
        \begin{align*}
        m = \tpi^{-1}(\key,\pad_{1024}(\meta),\pad_{128}(\nonce),\ctxt\|\auth)
        \end{align*}
        is randomly drawn from a set of size at least $2^n-Q$, as there have been at most $Q$ encryption queries under associated data $\meta$ and nonce $\nonce$, and satisfies $\lfloor m\rfloor_\alpha=0$ with probability at most $2^{n-\alpha}/(2^n-Q)$. Thus:
        \begin{align*}
        \advauth{\AE^{\LRW[\fish]}}(Q,R,T) \leq \advsprp{\LRW[\fish]}(Q+R,T'') + \frac{R2^{n-\alpha}}{2^n-Q}\,,
        \end{align*}
        where $T''\approx T$.

        In \cite{LRW02} it is proven that
        \begin{align*}
            \advsprp{\LRW[\fish]}(Q,T'') \leq \Theta\left(\frac{Q^2}{2^n}\right) + \advsprp{\fish}(2Q,T')\,,
        \end{align*}
        where $T'\approx T''$.
    \qed\end{proof}
    We briefly remark that the construction is even secure under \emph{release of unverified plaintext}, where $\msg$ is disclosed before tag verification is done \cite{asiacrypt/AndreevaBLMMY14}. We also note that, if one considers \emph{nonce respecting} adversaries, the term ${Q\choose2}/2^n$ in the analysis of secrecy disappears, and $\frac{R2^{n-\alpha}}{2^n-Q}$ can be replaced with $\frac{R2^{n-\alpha}}{2^n-1}$.

\section{Improving the Sphinx}\label{sec:improvedsphinx}
    A naive solution to the state of affairs for Sphinx (Section~\ref{sec:sphinx}) would be to replace SEAL by a more modern stream cipher and to replace SHA-1 by SHA-3, but there is little point in doing so: versatility of Sponges in general and SHA-3 in particular enables encryption using SHA-3 on the fly; putting a four-round Feistel construction on top of it is overkill. Instead, it makes more sense to simply \emph{replace} LIONESS by a keyed version of the SHA-3. The construction of Section~\ref{sec:ae-duplex} is particularly suited for this purpose, as it is an AE scheme based on the SHA-3 permutation. As the construction offers authenticated encryption, it can also be used to replace the MAC. In other words, where the original Sphinx MACs $\beta$ into authentication tag $\gamma$ and encrypts the payload into $\delta$ (both using secret session key $s$), the construction of Section~\ref{sec:ae-duplex} neatly merges those into
    \begin{align}
    (\delta,\gamma) = \mathrm{AE}(s, \mathrm{payload}, \beta)\,,\label{eqn:improvedsphinx}
    \end{align}
    where, for the sake of simplicity, $\beta$ now represents the associated data and the nonce. We have henceforth obtained the security and efficiency improvement promised in Section~\ref{sec:sphinx}. 

    It seems logical to also replace the remaining cryptographic functionalities in Sphinx by SHA-3. However, a second though reveals that, again, there is little point in doing so: first hashing a key through SHA-3 and then considering the keyed version of the SHA-3 based on this key is plainly less efficient \emph{and} less secure than considering the keyed version of the SHA-3 based on the original key. Therefore, it suffices to have a simple mapping that transforms the secret session key, which is a group element by default, into a bit string.

    The downside of the SHA-3 based approach is that the authenticated encryption scheme of \secref{sec:ae-duplex} does not offer security against nonce reusing adversaries, and in the solution of (\ref{eqn:improvedsphinx}), $\beta$ represents the associated data as well as the nonce. In Sphinx, the $\beta$ values are generated using the PRG, and henceforth random, but collisions may appear. Alternatively, one can use the Threefish based mode of Section~\ref{sec:ae-bc}, and use the Skein hash function family~\cite{FLS+11} to serve for hashing, as it already uses Threefish natively.

    Either approach makes the encryption functionality of Sphinx more secure and more efficient. \figref{fig:improvedsphinx} depicts our proposal of using authenticated encryption in Sphinx. Our authenticated encryption solutions support associated data as input which could be used for the processing of the header, it natively allows for authentication, and could potentially be used as MAC function. These advantages could be exploited to integrate part of the nested MAC functionality of Sphinx within the AE. As a bonus, Sphinx using our AE schemes \emph{additionally} authenticates the payload for free, a feature that was missing in the original Sphinx.
    \begin{figure}[t]
        \centering
        \resizebox{0.8\linewidth}{!}{%
        \begin{tikzpicture}%
        [%
            auto,font=\small\sffamily,
            myarrow/.style={-angle 60,>=stealth',shorten >=1pt}
        ]
            % Top rectangle
            \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=2pt] (7,4) -- (0,4);
            \node at (3.5,5) {Sphinx Header};

            \draw [fill=white] (0,3) rectangle (1,4);
            \node at (0.5,3.5) {$\alpha$};
            \draw [fill=white] (1.1,3) rectangle (5,4);
            \node at (3,3.5) {$\beta$};
            \draw [fill=white] (5.1,3) rectangle (7,4);
            \node at (6,3.5) {$\gamma$};
            %
            \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=2pt] (10,4) -- (7.1,4);
            \node at (8.5,5) {Payload};
            \draw [fill=white] (7.1,3) rectangle (10,4);
            \node at (8.5,3.5) {$\delta$};% $\tau = t - \mu$};
            

            % encrypt block
            \draw [fill=white] (1,1) rectangle (5.5,2);
            \node[font=\normalsize] at (3.25,1.5) {Sphinx Mix Header};


            % encrypt block
            \draw [fill=gray!30,very thick] (7.5,1) rectangle (9.5,2);
            \node[font=\normalsize] at (8.5,1.5) {AE module};

            % Bottom rectangles ....
            % left
            \draw [fill=white] (0,-1) rectangle (1,0);
            \node at (0.5,-0.5) {$\alpha'$};
            \draw [fill=white] (1.1,-1) rectangle (5,0);
            \node at (3,-0.5) {$\beta'$};        
            \draw [fill=white] (5.1,-1) rectangle (7,0);
            \node at (6,-0.5) {$\gamma'$};
            \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=2pt] (0,-1) -- (10,-1);
            \node at (5,-1.75) {Route to Mix $n'$};
            % \node at (3.5,-1) {Tweakable blockcipher Output};

            \draw [fill=white] (7.1,-1) rectangle (10,0);
            \node at (8.5,-0.5) {$\delta'$};

            \node[font=\normalsize\sffamily] at (-0.1,2.3) {Mix $n$};
            \node[font=\normalsize\sffamily] (secret) at (-0.1,1.9) {secret $x_n$};

            \begin{scope}[myarrow,thick]
              \draw (secret) |- (1,1.5);
              \draw (5.5,1.55) -- (7.5,1.55);
              \draw (0.5,3) -- (0.5,2.5) -- (1.5,2.5) -- (1.5,2); % alpha
              \draw (3,3) -- (3,2); % beta
              \draw (6,3) -- (6,2.5) -- (5,2.5) -- (5,2); % gamma
              \draw (6,2.5) -- (6.4,2.5);
              \draw (8.5,3) -- (8.5,2);
              % 
              \draw (1.5,1) -- (1.5,0.5) -- (0.5,0.5) -- (0.5,0); % alpha
              \draw (3,1) -- (3,0); % beta
              \draw (6,3) -- (6,2.5) -- (5,2.5) -- (5,2); % gamma
              \draw (8.5,1) -- (8.5,0);
              \draw (8.5,0.5) -- (6.3,0.5) -- (6.3,0);
              \draw (3,0.7) -- (5.8,0.7) -- (5.8,1.25) -- (7.5,1.25);  
            \end{scope}
            

            % concat
            \node at (6.5,1.8) {session key $s_n$};
            \node[font=\scriptsize,text width=1cm, align=center] at (6.8,2.5) {Check MAC};
            \node at (7.25,0.7) {$auth$ tag};
            \node at (4.5,0.4) {$\beta'$};
            % 
        \end{tikzpicture}
        }
        \caption{Using the AE scheme of Section~\ref{sec:ae-duplex} or Section~\ref{sec:ae-bc} in Sphinx. The mix header remains mostly unchanged. Message authentication and encryption are now merged into AE, where $\beta$ functions as the associated data.}
        \label{fig:improvedsphinx}
    \end{figure}

% \section{Conclusion}\label{sec:concl}
%     \alert{if needed.}

%\bigskip\noindent\textsc{Acknowledgments. }This work was supported in part by the Research Council KU Leuven: GOA TENSE (GOA/11/007). Bart Mennink is a Postdoctoral Fellow of the Research Foundation -- Flanders (FWO).

\bibliographystyle{splncs}
\bibliography{tweetybib}

\end{document}

