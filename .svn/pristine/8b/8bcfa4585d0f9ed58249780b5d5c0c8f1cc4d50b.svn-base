\documentclass{llncs}


%%%%%%%%%%%%%%%%%%%%%%%% General Packages %%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{pdflscape}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath,mathtools}
\usepackage{inputenc}
\usepackage{hyperref}
\usepackage{paralist}   % Required for compactum
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{threeparttable}
\usepackage[table]{xcolor}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\usepackage{enumerate}
\usepackage{xspace}
\usepackage{multirow}
\usepackage{colortbl}
\usepackage{enumitem}
\usepackage{appendix}

% For theorems
% \newtheorem{theorem}{Theorem}

\usepackage{tikz}
\usetikzlibrary{decorations.pathreplacing}
\usetikzlibrary{arrows}
\usetikzlibrary{positioning}
%%%%%%%%%%%%%%%%%%%%%%%% Custom Macros %%%%%%%%%%%%%%%%%%%%%%%%

% References
% -------------------------------------------------------
\newcommand{\figref}[1]{{Figure}~\ref{#1}}      % Figure
\newcommand{\tabref}[1]{{Table}~\ref{#1}}       % Table
\newcommand{\secref}[1]{{Section}~\ref{#1}}     % Section
\newcommand{\appref}[1]{{Appendix}~\ref{#1}}    % Appendix
\newcommand{\defref}[1]{{Definition}~\ref{#1}}  % Definition
\newcommand{\thref}[1]{{Theorem}~\ref{#1}}      % Theorem
\newcommand{\remref}[1]{{Remark}~\ref{#1}}      % Remark
% -------------------------------------------------------

% Description
% -------------------------------------------------------
\newcommand{\desc}[1]{\bigskip\noindent\textbf{#1}}

% NEWFUCTION-related
% -------------------------------------------------------
\newcommand{\NAME}{\ensuremath{\mathrm{AITO}}\xspace}
\newcommand{\key}{\ensuremath{\mathit{key}}}
\newcommand{\hasht}{\ensuremath{\mathit{ht}}}
\newcommand{\tstamp}{\ensuremath{\mathit{ts}}}
\newcommand{\meta}{\ensuremath{\mathit{meta}}} %was hasht
\newcommand{\nonce}{\ensuremath{\mathit{nonce}}} %was tstamp
\newcommand{\msg}{\ensuremath{\mathit{msg}}}
\newcommand{\ctxt}{\ensuremath{\mathit{ctxt}}}
\newcommand{\auth}{\ensuremath{\mathit{auth}}}
\newcommand{\fish}{\ensuremath{\mathrm{3fish}}\xspace}
\newcommand{\LRW}{\ensuremath{\mathrm{LRW}}\xspace}
\newcommand{\LRWa}{\ensuremath{\mathrm{LRW1}}\xspace}
\newcommand{\LRWb}{\ensuremath{\mathrm{LRW2}}\xspace}
\newcommand{\TwSp}{\ensuremath{\mathrm{TwSp}}\xspace}
\newcommand{\Sp}{\ensuremath{\mathrm{Sp}}\xspace}
\newcommand{\keccak}{\ensuremath{\pi_{\mathrm{keccak}}}\xspace}
\newcommand{\IKS}{\ensuremath{\mathrm{IKS}}\xspace}

% Others
% -------------------------------------------------------
\newcommand{\etal}{et al.}
\newcommand{\xor}{\oplus}
\newcommand{\getR}{\xleftarrow{{\scriptscriptstyle\$}}}
\newcommand{\tE}{\widetilde{E}}
\newcommand{\tpi}{\widetilde{\pi}}
\newcommand{\func}{\mathsf{Func}}
\newcommand{\perm}{\mathsf{Perm}}
\newcommand{\tperm}{\widetilde{\mathsf{Perm}}}
\newcommand{\RO}{\mathcal{RO}}
\newcommand{\bin}[1]{\{0,1\}^{#1}}
\newcommand{\bink}{\bin{\kappa}}
\newcommand{\bint}{\bin{\leq\tau}}
\newcommand{\bins}{\bin{\sigma}}
\newcommand{\binm}{\bin{\leq\mu}}
\newcommand{\binn}{\bin{\leq\nu}}
\newcommand{\bina}{\bin{\alpha}}
\newcommand{\adv}[2]{\ensuremath{\mathbf{Adv}_{#2}^{\mathrm{#1}}}}
\newcommand{\advsprp}[1]{\adv{\widetilde{sprp}}{#1}}
\newcommand{\advcpa}[1]{\adv{cpa}{#1}}
\newcommand{\advauth}[1]{\adv{auth}{#1}}
\newcommand{\A}{\mathcal{A}}
\newcommand{\calK}{\mathcal{K}} %key
\newcommand{\calT}{\mathcal{T}} %cipher-tweak
\newcommand{\calM}{\mathcal{M}} %cipher-in
\newcommand{\calC}{\mathcal{C}} %cipher-out
\newcommand{\pad}{\mathsf{pad}}
\newcommand{\unpad}{\mathsf{unpad}}
\definecolor{lightgray}{gray}{0.9}
\newcommand{\lambdamax}{\lambda_{\mathrm{max}}}
% -------------------------------------------------------


% Personal Comments
% -------------------------------------------------------
\newcommand{\filipe}[1]{{\color{red}\textsf{Filipe:} \emph{#1}}}
\newcommand{\kimmo}[1]{{\color{blue}\textsf{Kimmo:} \emph{#1}}}
\newcommand{\bart}[1]{{\color{orange}\textsf{Bart:} \emph{#1}}}
% \newcommand{\bart}[1]{{\color{orange}\emph{#1}}}
% -------------------------------------------------------




\begin{document}

\title{\boldmath{\NAME}: Compact Authenticated Encryption\\ for Private and Secret Messaging}
  % \runningtitle{\NAME: Compact Authenticated Encryption for Private and Secret Messaging}
  %\bart \NAME
\author{}
\institute{}
\maketitle

\begin{abstract}
    % Compact messaging services, such as microblogging and direct messaging, provide users with easy and reliable channels for dissemination of information. %These networks play a fundamental role in quick and ubiquitous dissemination of information.
    % %
    % At the same time, networks offering those services store treasure troves of information to support their business model through targeted advertisements, and have become prime targets of censorship and surveillance based on the shared content.
    % Current approaches that deliver privacy in such systems use traditional encryption techniques, requiring large entropy and lack flexibility to selectively provide data utility, and thus, becoming unappealing for the service providers and unsuitable to compact messaging.
    % Traditional approaches for encrypting and authenticating this content offer security, but lack flexibility to selectively reveal some information for the providers to use. This makes them unappealing for the service providers. Furthermore, a dedicated design for compact messaging could give more security and greater efficiency.
    %
    % Add more privacy issues + motivation
    %
    \NAME is a secure encryption scheme tailored for usage in any compact messaging service, guaranteeing semantic security and authenticity while complying with the commonly imposed space restrictions in several services. \NAME consists of three distinct instantiations based on different primitives, namely tweakable blockciphers and Sponge functions, and offers higher levels of security than existing alternatives.
    We prove the cryptographic security of \NAME and describe how it yields efficiency and security gains for private messaging services and for the cryptographic message format Sphinx for relay of anonymous messages.
    % In addition, we describe how \NAME can be efficiently applied to different deployed systems, such as OTR, Sphinx, and Twitter. Finally, we discuss an implementation of a prototype, demonstrating the improved efficiency and low overhead of our constructions.}
\end{abstract}

\section{Introduction}\label{sec:intro}
    With the large growth of internet services, modern users rely more on digital and ubiquitous communications. Compact messaging services, such as private direct messaging and anonymous services, provide users with private, easy, and reliable channels for dissemination of information.  Many services offer the possibility to encrypt data by means of symmetric encryption schemes. However, sometimes these lack authentication and generally require a mode of operation to comply with the compact size restrictions, affecting efficiency and security. For instance, Sphinx~\cite{sp/DanezisG09}, a widely used compact cryptographic message format for mix networks, uses plain encryption and plain message authentication. While authenticated encryption (AE) schemes present a valid solution for the integrity problem, they still require a mode of operation and several interactions to comply with both the size constraints and the security expectations.
    %which means that the content of a message is not only encrypted to some recipient, but also the integrity of that content is protected (and possibly the sender is also authenticated to the recipient). AE forms the de facto logical solution to above problems, but the implementation of it in above-mentioned applications is lacking. For instance, the Sphinx mix format uses plain encryption and plain message authentication (see Section~\ref{sec:applmix} for more details), and it makes sense to investigate what security \emph{and} efficiency gains can be made by using a single AE.

    \subsection{\NAME}
        In this work we present \NAME, a novel authenticated encryption scheme that is specifically tailored for compact messages. It provides access control to the content by means of encryption, allows for authenticity ensuring the integrity of data, and most importantly, it offers extra flexibility and re-randomization. It consists of three solutions, two based on tweakable blockciphers~\cite{LRW02} and one based on the SpongeWrap~\cite{BDPA11-SAC,asiacrypt/MenninkRV15}, each with different properties and advantages.

        For the two solutions based on tweakable blockciphers~\cite{LRW02}, we approach compact authenticated encryption from an orthogonal direction. In more detail, instead of developing the AE as a mode, we aim to use a dedicated tweakable blockcipher to encrypt all data \emph{at once}. For \NAME, we have selected Threefish, a tweakable blockcipher with $1024$-bit state by Ferguson et al.~used for the Skein hash function family~\cite{FLS+11}.\footnote{The most prominent alternative solutions were the use of (i) a large permutation (such as the Keyak~\cite{BDP+15} or Pr{\o}st~\cite{KLL+14} permutation) in a tweakable Even-Mansour mode~\cite{DBLP:conf/crypto/CogliatiLS15} and (ii) the TWEAKEY tweakable blockcipher by Jean et al.~\cite{DBLP:conf/asiacrypt/JeanNP14,JNP15Deoxys,JNP15Joltik}. However, the Keyak permutation is known to have an expensive inverse, and the other solutions have a state size which is too small for our purposes.} Threefish has withstood a wide variety of cryptanalysis~\cite{DBLP:conf/asiacrypt/AumassonCMOPV09,DBLP:conf/ispec/ChenJ10,FLS+11,DBLP:conf/fse/KhovratovichN10,DBLP:conf/fse/KhovratovichNPS15,DBLP:conf/asiacrypt/KhovratovichNR10,DBLP:conf/ctrsa/LeurentR12,DBLP:conf/sacrypt/YuCW12}.

        The first instance of \NAME (Section~\ref{sec:tweetytbc}) consists of a single evaluation of Threefish. It is the most efficient compact AE solution of the three, but requires a restriction on the size of the associated data to be rather stringent (around 128 bits at most). The second instance of \NAME (Section~\ref{sec:tweetylrw}) resolves the latter via the use of a tweakable mode by Liskov \etal~\cite{LRW02} on top of the tweakable blockcipher: it consists of two evaluations of Threefish but allows for significantly larger associated data. Both solutions achieve approximately 512-bit security, and are even resistant (to a certain degree) against nonce-repeating adversaries. A comparison of the solutions can be found in Table~\ref{tab:comparison}.

        The Sponge based solution of \NAME can be seen as an adaption of the full-state SpongeWrap~\cite{BDPA11-SAC,asiacrypt/MenninkRV15} to compact data (Section~\ref{sec:tweetySponge}). This solution allows for more flexible data sizes than the previous two solutions, while allowing for equally high security levels, but it is inherently nonce-respecting.

    \subsection{Application and Implementation}
        \NAME is tailored to the use of compact data, and henceforth finds plenty of privacy applications.
        For instance, if used together with secret messaging protocols such as OTR~\cite{wpes/BorisovGB04} and the more recent Vuvuzela \cite{van2015vuvuzela}, \NAME allows for higher security, and more efficient refreshing the session keys (\secref{sec:secmsg}).
        Furthermore, we demonstrate in Section~\ref{sec:applmix} how \NAME can be used to increase the security and efficiency of the Sphinx mix network~\cite{sp/DanezisG09}. In more detail, the original Sphinx uses the outdated LIONESS cipher from 1996; our proposal of Sphinx using \NAME is more secure and increased performance, while allowing for a decrease in the header size.
        As a third application, we consider the use of \NAME in online social networks and microblogging services, such as Twitter or Instagram (Section~\ref{sec:applmicro}). Our solution enables secret messaging and access control by means of authenticated encryption, while still facilitating the providers in keeping the data utility of some information to support their business model. Our application allows users to selectively decide on the \emph{``gist''} of information shared \cite{esorics/BilogrevicFCU14}. As such, \NAME contributes to saving computational resources at the recipient side of the communication, as it is possible to filter messages based on the gist.

        We present a comparison and implementation of the various solutions for \NAME in Section~\ref{sec:practical}. In this comparison, which is specifically thwarted to the secret messaging and microblogging services, we demonstrate that \NAME offers high security for compact data, without sacrificing efficiency.

    \subsection{Related Work on Authenticated Encryption}
        Authenticated encryption (AE) enjoys a long and steady line of research, and the ongoing CAESAR competition~\cite{CAESAR} for the design of new AE schemes has induced renewed attention to the field. The classical approach to design AE schemes is to build the generic mode of operation on top of a blockcipher (usually AES) in order to process data blocks iteratively \cite{DBLP:conf/asiacrypt/AndreevaBLMTY13,DBLP:conf/fse/BellareRW04,DBLP:conf/acisp/DattaN14,DBLP:conf/eurocrypt/HoangKR15,DBLP:conf/fse/KrovetzR11,DBLP:conf/eurocrypt/Minematsu14,DBLP:conf/asiacrypt/Rogaway04,DBLP:conf/ccs/RogawayBBK01}. A more novel approach is to design AEs based on permutations. The most well-known approach is SpongeWrap by Bertoni \etal~\cite{BDPA11-SAC} which got recently generalized by Jovanovic \etal~\cite{DBLP:conf/asiacrypt/JovanovicLM14} and Mennink \etal~\cite{asiacrypt/MenninkRV15}, and various CAESAR submissions follow this idea \cite{ABB+15,AJN15,BDP+15,GMS15,DEMS15,MGH+15,SB15}. Different permutation based approaches include APE~\cite{DBLP:conf/fse/AndreevaBBLMMY14} and PAEQ~\cite{DBLP:conf/isw/BiryukovK14}.

        Yet, the focus of this work is mostly on \emph{compact} and \emph{highly-secure} authenticated encryption, and particularly its connection to above privacy applications, leaving most of the blockcipher based modes inadequate for our purposes. The reason is that these often entail overhead, e.g.~in the form of padding, and the security level is in the end dominated by what the underlying primitive offers. For blockcipher based modes, using AES internally delivers at most $128$-bit security, and often there exist already distinguishability attacks in complexity of about $2^{64}$ (cf.~Bellare \etal~\cite{BDJR97}). In addition, for messages of say $1024$ bits, solutions of this type still require at least $8$ AES evaluations. Aligned with the fact that generally tweets (or text messages) are of a relatively short (but larger than $128$ bits) length, alternative approaches will be more suitable.

        Although AEZ~\cite{DBLP:conf/eurocrypt/HoangKR15}, or more detailed the latest version v4 in the CAESAR competition~\cite{HKR15AEZ}, is an exception to this, AEZ is also inherently a mode based on 4 and 10 rounds of AES, and has $64$-bit security as well. Recent cryptanalysis on AEZ~\cite{DBLP:conf/asiacrypt/FuhrLS15,Mennink16} has moreover shined a negative light on its security.
        % 
        For permutation based approaches the situation is different, which is in part because cryptographic permutations are often \emph{much} larger than blockciphers. For instance, the Keccak~\cite{BDPA12} and Keyak~\cite{BDP+15} permutation are of size $1600$ bits, and a smart balance among the internal parameters of the SpongeWrap can allow the security level to reach the $800$-bit barrier~\cite{DBLP:conf/asiacrypt/JovanovicLM14}, an observation which we have used in our Sponge based instantiation of \NAME.

%     Encrypting the content delivered over such services is one way of protection. While many messaging services offer the possibility to encrypt messages, in OSNs this is usually not the case, and in many cases the business model of the OSN requires that it can collect and analyze the posted content and other information. Thus, allowing and facilitating the sharing of encrypted content, possibly even anonymously, is against their interests. Finding a good balance between privacy of the content and (some) ability to use some user-specified information about that content would be a win-win situation for privacy and the economic viability of the majority of today's OSNs.


    % With the large growth of Internet services, modern users rely more on digital and ubiquitous communications. Services such as Online Social Networks (OSNs), microblogging, and mobile direct messaging have become prominent communication channels by providing efficient as well as reliable sharing tools for dissemination and exchange of information. At the same time, given their prominent design and current business models, providers end up centralizing and storing large amounts of information about the users and their communications, thus leading to several privacy threats. For example, it is important for the users to be able to protect the content posted on OSN as well as have some mechanism for anonymous sending and receiving of messages over otherwise public or non-anonymous OSNs.

    % Encrypting the content delivered over such services is one way of protection. While many messaging services offer the possibility to encrypt messages, in OSNs this is usually not the case, and in many cases the business model of the OSN requires that it can collect and analyze the posted content and other information. Thus, allowing and facilitating the sharing of encrypted content, possibly even anonymously, is against their interests. Finding a good balance between privacy of the content and (some) ability to use some user-specified information about that content would be a win-win situation for privacy and the economic viability of the majority of today's OSNs.

% \subsection{Authenticated Encryption}
    % One important tool in modern cryptography for achieving these goals is \emph{authenticated encryption} (AE), which means that the content of a message is not only encrypted to some recipient, but also the integrity of that content is protected (and possibly the sender is also authenticated to the recipient). AE forms the de facto logical solution to above problems, but the implementation of it in above-mentioned applications is lacking. For instance, the Sphinx mix format uses plain encryption and plain message authentication (see Section~\ref{sec:applmix} for more details), and it makes sense to investigate what security \emph{and} efficiency gains can be made by using a single AE.

    % AE enjoys a long and steady line of research, and the ongoing CAESAR competition~\cite{CAESAR} for the design of new AE schemes has induced renewed attention to the field. The classical approach to AE design is blockcipher based, where a generic mode of operation is built on top of a blockcipher (usually AES) in order to process data blocks iteratively \cite{DBLP:conf/ccs/RogawayBBK01,DBLP:conf/asiacrypt/Rogaway04,DBLP:conf/fse/BellareRW04,DBLP:conf/fse/KrovetzR11,DBLP:conf/asiacrypt/AndreevaBLMTY13,DBLP:conf/eurocrypt/Minematsu14,DBLP:conf/acisp/DattaN14,DBLP:conf/eurocrypt/HoangKR15}. A more novel approach is to design AEs based on permutations. The most well-known approach is SpongeWrap by Bertoni \etal~\cite{BDPA11-SAC} which got recently generalized by Jovanovic \etal~\cite{DBLP:conf/asiacrypt/JovanovicLM14} and Mennink \etal~\cite{asiacrypt/MenninkRV15}, and various CAESAR submissions follow this idea \cite{DEMS15,MGH+15,BDP+15,AJN15,GMS15,ABB+15,SB15}. Different permutation based approaches include APE~\cite{DBLP:conf/fse/AndreevaBBLMMY14} and PAEQ~\cite{DBLP:conf/isw/BiryukovK14}.

    % Yet, the focus in this work is mostly on \emph{compact} and \emph{highly-secure} authenticated encryption, and particularly its connection to above privacy applications. This leaves most of the blockcipher based modes inadequate for our purposes. The reason is that these often entail overhead, e.g.~in the form of padding, and the security level is in the end dominated by what the underlying primitive offers. For above blockcipher based modes, using AES internally means that $128$-bit security is the best possible, and often there exist already distinguishability attacks in complexity of about $2^{64}$ (cf.~Bellare \etal~\cite{BDJR97}). Additionally, for messages of say $1024$ bits, solutions of this type still require at least $8$ AES evaluations. Aligned with the fact that general tweets (or text messages) are of a relatively short (but larger than $128$ bits) length, alternative approaches will be more suitable.

    % A first glance suggests that AEZ~\cite{DBLP:conf/eurocrypt/HoangKR15}, or more detailed the latest version v4 in the CAESAR competition~\cite{HKR15AEZ}, is an exception to this. However, also AEZ is inherently a mode based on 4 and 10 rounds of AES, and has $64$-bit security as well. Additionally, recent cryptanalysis on AEZ~\cite{DBLP:conf/asiacrypt/FuhrLS15,Mennink16} have shined a negative light on its security.

    % For permutation based approaches the situation is different, which is in part because cryptographic permutations are often \emph{much} larger than blockciphers. For instance, the Keccak~\cite{BDPA12} and Keyak~\cite{BDP+15} permutation are of size $1600$ bits, and a smart balance among the internal parameters of the SpongeWrap can allow the security level to reach the $800$-bit barrier~\cite{DBLP:conf/asiacrypt/JovanovicLM14}.

% \subsection{\NAME Compact Authenticated Encryption}
    % In this paper we propose \emph{\NAME}, a novel AE scheme that is tailored for compact messages (\secref{sec:model}). Besides providing access control to the content by means of encryption, it additionally allows for authenticity, ensuring integrity of data. \NAME consists of three solutions, a Sponge based one and two tweakable blockcipher based ones. The Sponge based one can be seen as an adaption of the SpongeWrap to our specific use-cases. For the other two solutions based on tweakable blockciphers, we approach compact authenticated encryption from an orthogonal direction. In more detail, instead of developing the AE as a mode, we aim to use a dedicated tweakable blockcipher to encrypt all data \emph{at once}. For \NAME, we have selected Threefish, a tweakable blockcipher with $1024$-bit state by Ferguson et al.~used for the Skein hash function family~\cite{FLS+11}. Threefish has withstood a wide variety of cryptanalysis~\cite{FLS+11,DBLP:conf/asiacrypt/AumassonCMOPV09,DBLP:conf/ispec/ChenJ10,DBLP:conf/fse/KhovratovichN10,DBLP:conf/asiacrypt/KhovratovichNR10,DBLP:conf/ctrsa/LeurentR12,DBLP:conf/sacrypt/YuCW12,DBLP:conf/fse/KhovratovichNPS15}.\footnote{The most prominent alternative solutions were the use of (i) a large permutation (such as the Keyak~\cite{BDP+15} or Pr{\o}st~\cite{KLL+14} permutation) in a tweakable Even-Mansour mode~\cite{DBLP:conf/crypto/CogliatiLS15} and (ii) the TWEAKEY tweakable blockcipher by Jean et al.~\cite{DBLP:conf/asiacrypt/JeanNP14,JNP15Deoxys,JNP15Joltik}. However, the Keyak permutation is known to have an expensive inverse, and the other solutions have a state size which is too small for our purposes.}

    % The formal description of \NAME is given in \secref{sec:model}. The two versions of \NAME based on tweakable blockciphers are introduced in Sections \ref{sec:tweetytbc} and \ref{sec:tweetylrw}, and the one based on the keyed Sponge in \secref{sec:tweetySponge}. In these sections, we also show that these constructions achieve provable security that is better than existing possibilities for this type of authenticated encryption with a tolerable cost in key size.

% \subsection{Applications}
% These issues motivate the need to implement more reliable user-centric privacy protection mechanisms, such as end-to-end encryption. One possible solution is to encrypt all the data shared and transferred, for instance using a standard encryption modes of operation, such as AES-CTR or AES-CBC, or a secure messaging protocol, such as OTR~\cite{wpes/BorisovGB04}.
%
%However, those constructions have several shortcomings. For instance, sharing encrypted information breaks the business model relying on the mining of the shared content to provide targeted advertisements, which could cause providers to restrict and censor the distribution of the encrypted content. It has been shown that is possible to keep data utility and privacy by allowing providers to access limited information~\cite{esorics/BilogrevicFCU14}. Also, those general constructions do not take into account the limitations and specific properties of OSN, such as the space constraints (140 characters, about 1120~$bits$) and the use of hashtags for filtering and marking specific events, in the case of Twitter and Instagram. For instance, an adaption of the CTR or CBC mode of operation with AES-128\footnote{http://codecereal.blogspot.ch/2011/06/encrypted-tweets.html} to those properties, achieves $128$-bit security \emph{at most}, and even allows for distinguishability attacks in complexity about $2^{64}$ (cf.~Bellare \etal~\cite{BDJR97}), while requiring at least $8$ AES evaluations.
% Also, sharing encrypted information breaks business model of several systems relying on the mining of the shared content to provide targeted advertisements, which could cause providers to restrict and censor the distribution of the encrypted content. In fact, it has been shown that is actually possible to keep data utility and privacy by allowing providers to access the \emph{"gist"} of information, i.e., a set limited information released that does not affect user's privacy~\cite{esorics/BilogrevicFCU14}.

% \NAME can be applied and used in many different applications, allowing security, integrity, and efficiency while enabling providers to prevail some data utility.
% For instance, it can be plugged into several messaging protocols, such as OTR~\cite{wpes/BorisovGB04} by replacing the symmetric key operation allowing higher security, as well as increasing efficiency for refreshing the session keys (\secref{sec:secmsg}). Furthermore, \NAME can be used to increase the 128-bit security and efficiency of anonymized messages in a mix-network, such as Sphinx~\cite{sp/DanezisG09}. We propose that using \NAME in the Sphinx mix-network scenario instead of the original LIONESS cipher from 1996 will provide greater security and also better performance with smaller headers (\secref{sec:applmix}).
% In addition, \NAME could be applied to Twitter, the widely popular microblogging service (\secref{sec:applmicro}), to enable secret messaging and access control by means of encryption, while enabling providers to keep the data utility of some information to support their business model, allowing users to selectively select the \emph{"gist"} of information shared. Consequently also helping in saving some computational resources at the recipient side of the communication as it is possible to filter messages based on the hashtags, and thus limit the number of decryption operations. For instance, one could choose not to decrypt messages with the hashtag ``\#football'' from a certain (or every) user.
% In addition, it offers the flexibility to enable providers to keep the a gist of data utility of some information to support their business model.

% In the final sections, we discuss our three constructions and present our conclusions (\secref{sec:concl}).

% This can be seen from \tabref{tab:comparison}. In addition, \NAME can be used together with the broadcast and attribute-based encryptions solutions as a tailored symmetric encryption, and with Hummingbird system for protecting tweets.

% \subsection{Use Cases}
% Most popular OSNs, such as Facebook, Google+, and Twitter, provide users with certain privacy controls over their content and with secured direct messaging. While secure messaging usually employs end-to-end encryption mechanisms~\cite{sp/UngerDBFPG015}. However, this process relies not only on the diligence of the users but also on the trustworthiness of the providers in protecting stored content from possible adversaries.  Nevertheless, providers require access to the content in order to comply with their economical model, such as targeted advertisement~\cite{NEWS/SLT:facebooksued4,HOTNEts:RiedererECKR11}, consequently exposing users to several privacy issues.
%
% Online Social Networks (OSNs), such as Facebook, Google+, and Twitter, alongside direct messaging solutions such as WhatsApp and iMessage,
% In particular, Twitter has facilitated a very rapid-fire style of information sharing helping for example grassroots democracy movements in many places over the world.
% Given their prominent role and design, OSNs end up centralizing and storing large amounts of information, exposing users to several privacy threats.
% Although most popular OSNs provide users with certain privacy controls over their content and with secured direct messaging, this process relies not only on the diligence of the users but also on the trustworthiness of the providers in protecting stored content from possible adversaries.
% corrent this sentence!
% This has lead to several reports of mass breaches on the information shared on OSNs~\cite{NEWS/FBBug15}, as is evident from the recent accounts of surveillance programs like Prism~\cite{NEWS/WP:prism13}, and the recent iCloud mega leak~\cite{NEWS/FBS:icloud14}, amplifying the privacy issues.
%


% addd examples of the problems we are solving!

% cite Whatâ€™s the Gist? Privacy-Preserving Aggregation of User Profiles

% Moreover,
% business model shit
% breaches
% efficiency
% key management
%
% These issues motivate the need to implement more reliable user-centric privacy protection mechanisms, such as end-to-end encryption. One possible solution is to encrypt all the data shared and transferred, for instance using a standard encryption modes of operation, such as AES-CTR or AES-CBC, or a secure messaging protocol, such as OTR~\cite{wpes/BorisovGB04}.
%
% However, those constructions have several shortcomings. For instance, sharing encrypted information breaks the business model relying on the mining of the shared content to provide targeted advertisements, which could cause providers to restrict and censor the distribution of the encrypted content. It has been shown that is possible to keep data utility and privacy by allowing providers to access limited information~\cite{esorics/BilogrevicFCU14}. Also, those general constructions do not take into account the limitations and specific properties of OSN, such as the space constraints (140 characters, about 1120~$bits$) and the use of hashtags for filtering and marking specific events, in the case of Twitter and Instagram. For instance, an adaption of the CTR or CBC mode of operation with AES-128\footnote{http://codecereal.blogspot.ch/2011/06/encrypted-tweets.html} to those properties, achieves $128$-bit security \emph{at most}, and even allows for distinguishability attacks in complexity about $2^{64}$ (cf.~Bellare \etal~\cite{BDJR97}), while requiring at least $8$ AES evaluations.
%
% Although direct messaging services apply similar mechanisms to protect the communication among users, these are generally inefficient and often require keys to be managed by providers.

\section{Model}\label{sec:model}
This section introduces \NAME and the respective threat model.
%\subsection{Notation}
For $n\in\mathbb{N}$, $\bin{n}$ is the set of $n$-bit strings, and $\bin{\leq n}=\bigcup_{i=0}^n\bin{i}$. For two bit strings $M,N$, their concatenation is denoted by $M\|N$ and $M\xor N$ denotes their bitwise XOR. Furthermore, if $M\in\bin{\leq n-1}$, then $\pad_n(M)=M\|10^{n-1-|M|}$. For a string $N\in\bin{n}$, we define by $\unpad_n(N)$ the unique string $M\in\bin{\leq n-1}$ such that $\pad_n(M)=N$. For $m\leq n$ and $N\in\bin{n}$, we denote by $\lceil N\rceil_m$ the leftmost $m$ bits and by $\lfloor N\rfloor_{n-m}$ the rightmost $n-m$ bits of $N$, in such a way that $N=\lceil N\rceil_m\|\lfloor N\rfloor_{n-m}$.

\subsection{\NAME}\label{sec:tweety}
\NAME is an AE scheme for short data. Let $\lambdamax\in\mathbb{N}$ be an integer that specifies the maximal size of an authenticated ciphertext (for instance $\lambdamax=1024$ or $1120$). Let $\mu,\nu,\alpha,\tau,\sigma\in\mathbb{N}$ be size values that satisfy $\mu\leq\nu$ and $\nu+\alpha+\tau+\sigma\leq\lambdamax$. Such that, $\mu$ denotes the size of the message, $\nu$ the size of the ciphertext, $\tau$ the size of the meta data, and $\sigma$ the size of the nonce. The value $\alpha$ determines the size of the authentication tag. If no authentication is needed, we have $\alpha=0$.

\NAME is composed of three algorithms: \texttt{KeyGen}, \texttt{Enc}, and \texttt{Dec}. \texttt{KeyGen} is a randomized algorithm that gets as input $\kappa\in\mathbb{N}$ and outputs a random key $\key \leftarrow \bink$. The \texttt{Enc} and \texttt{Dec} algorithms are defined as follows:
\begin{align*}
\texttt{Enc}:\;\;&\bink\times\binm\times\bint\times\bins \to  \binn\times\bina\,,\\
                 &(\key, \msg, \meta, \nonce) \mapsto (\ctxt, \auth)\,,\\
\texttt{Dec}:\;\;&\bink\times\binn\times\bina\times\bint\times\bins \to \binm\cup\{\bot\}\,,\\
                 &(\key, \ctxt, \auth, \meta, \nonce) \mapsto \msg/\bot\,.
\end{align*}
\texttt{Dec} outputs the unique $\msg$ satisfying $\texttt{Enc}(\key,\msg,\meta,\nonce)=(\ctxt,\auth)$, or it returns $\bot$ if no such message exists. \texttt{Enc} also outputs $\meta$ and $\nonce$. We allow for a small amount of ciphertext expansion (from $\mu$ to $\nu$ bits), as long as the encrypted ciphertext $(\ctxt,\auth,\meta,\nonce)$ is of size at most $\lambdamax$.

As aforementioned various approaches of AE schemes exist; see for instance the CAESAR competition~\cite{CAESAR} for the design of a new AE scheme. These schemes are often generic modes of operation that process data blocks iteratively. However, \NAME is designed for small data, and orthogonal design approaches turn out to be more suitable. In particular, the key principle of the design of \NAME is inspired by tweakable blockciphers, where the meta data and nonce function as the tweak.

\subsection{Threat Model}
We consider an adversary $\A$ to be any entity attempting to passively access the shared information by monitoring the communication channel, with no incentive to tamper with the content. However, $\A$ is allowed to generate encryptions under a secret and unknown key. In this case, $\A$ should not learn the encrypted content, beyond that revealed in the meta data.

More technically, adversary $\A$ has query access to $\mathtt{Enc}$ under a secret key $\key$, and it tries to find irregularities among the queries, i.e., some relation that is not likely to hold for a random function. Here, we require $\A$  to be nonce respecting, so that every query must be made under a different nonce (see also \secref{sec:concl}). For a function $F$, let $\func(F)$ be the set of all functions $f$ with the same interface as $F$. The advantage of an adversary $\A$ in breaking the secrecy of \NAME is defined as follows:
%
\begin{align*}
    &\advcpa{\NAME}(\A) = \left|
        \begin{array}{l}
        \Pr\left(\key\getR\mathtt{KeyGen}(\kappa)\;:\;\A^{\mathtt{Enc}_{\key}} = 1 \right)\:-\\[6pt]\quad\qquad\qquad\!\Pr\left(\$\getR\func(\mathtt{Enc}_{\key})\;:\;\A^{\$} = 1\right)
        \end{array} \right|\,.
\end{align*}
%
We denote by $\advcpa{\NAME}(Q,T)$ the maximum advantage over all adversaries that make at most $Q$ encryption queries and operate in time $T$.

For the authenticity of $\NAME$, we consider $\A$ to have access to the encryption functionality $\mathtt{Enc}$ under a secret key $\key$, and say that $\A$ \emph{forges} an authentication tag if it manages to output a tuple $(\ctxt, \auth, \meta, \nonce)\in\binn\times\bina\times\bint\times\bins$ such that $\texttt{Dec}(\key,\ctxt, \auth, \meta, \nonce)=\msg\neq\bot$ and $(\msg,\meta,\nonce)$ was never queried to $\mathtt{Enc}$ before. The forgery attempt may be made under a nonce $\nonce$ that has appeared before. The advantage of $\A$ in breaking the authenticity of \NAME is defined as follows:
%
\begin{align*}
    &\advauth{\NAME}(\A) = \Pr\left(\key\getR\mathtt{KeyGen}(\kappa)\;:\;\A^{\mathtt{Enc}_{\key}} \text{ forges} \right)\,.
\end{align*}
%
We denote by $\advauth{\NAME}(Q,R,T)$ the maximum advantage over all adversaries that make at most $Q$ encryption queries, $R$ forgery attempts, and operate in time $T$.
%

\section{\NAME: Basic Construction}\label{sec:tweetytbc}
The first approach is to apply a large tweakable blockcipher. A tweakable blockcipher $\tE:\calK\times\calT\times\calM\to\calM$ takes as input a key $k\in\calK$, a tweak $t\in\calT$, and a message $m\in\calM$, and outputs a ciphertext $c\in\calM$. It is a permutation for every choice of $(k,t)$.

For \NAME, we suggest using \emph{Threefish}, a tweakable blockcipher by Ferguson et al.~used for the Skein hash function family~\cite{FLS+11}. Threefish supports block sizes of 256, 512, and 1024 bits. The key size equals the block size, and the tweak size is $128$ bits. We focus on the largest variant, Threefish-1024, which for readability we simply denote \fish:
\begin{align*}
\fish:\;\;&\bin{1024}\times\bin{128}\times\bin{1024} \to \bin{1024}\,,\\
                 &(k,t,m) \mapsto c\,.
\end{align*}
\fish can be used for AE directly, a construction we call $\NAME^\fish$. It operates on keys of size $\kappa=1024$ bits, messages can be of arbitrary length but of size at most $\mu=1023-\alpha$, and the sizes of the meta data and nonce should satisfy $\sigma+\tau\leq 127$. The ciphertexts are of size \emph{exactly} $\nu=1024-\alpha$ bits, where $\alpha$ is the size of the authentication tag. The latter is required to make decryption possible. At a high level, the encryption consists of putting $m=\pad_{1024}(\msg)$ and $t=\pad_{128}(\nonce\|\meta)$, and the ciphertext and authentication tag are derived as $\ctxt\|\auth=c$. Formally, the encryption and decryption of $\NAME^\fish$ are defined as in Algorithms~\ref{algo:fishEnc} and \ref{algo:fishDec}.

% \noindent\begin{minipage}[t]{\linewidth}
%     \vspace{-15pt}
    \begin{algorithm}[t]
        \caption{\;\;$\mathtt{Enc}^{\fish}$}\label{algo:fishEnc}
        \begin{algorithmic}[1]
            \Require{$(\key,\msg,\meta,\nonce)\in\bink\times\binm\times\bint\times\bins$}
            \Ensure{$(\ctxt,\auth)\in\bin{\nu}\times\bina$}
            \State{$c \gets \fish(\key,\pad_{128}(\nonce\|\meta),\pad_{1024}(\msg))$}
            \State{\Return $(\lceil c\rceil_\nu,\lfloor c\rfloor_{\alpha})$}
        \end{algorithmic}
    \end{algorithm}
%    \vspace{-40pt}
    \begin{algorithm}[t]
        \caption{\;\;$\mathtt{Dec}^{\fish}$}\label{algo:fishDec}
        \begin{algorithmic}[1]
            \Require{$(\key,\ctxt,\auth,\meta,\nonce)\in\bink\times\bin{\nu}\times\bina\times\bint\times\bins$}
            \Ensure{$\msg\in\binm$ or $\bot$}
            \State{$m\gets \fish^{-1}(\key,\pad_{128}(\nonce\|\meta),\ctxt\|\auth)$}
            \State{$\msg\gets \unpad_{\mu+1}(\lceil m \rceil_{\mu+1})$}
            \State{\Return $ \lfloor m\rfloor_\alpha=0\;?\;\msg : \bot$}
        \end{algorithmic}
    \end{algorithm}
% \end{minipage}

\desc{Security.}
In this section we formally derive the security of $\NAME^{\fish}$ under the assumption that \fish is a secure tweakable blockcipher. The security of a tweakable blockcipher $\tE:\calK\times\calT\times\calM\to\calM$ is captured by an adversary $\A$ that has adaptive two-sided oracle access to either $\tE_k$ for some secret key $k\getR\calK$, or ideal tweakable permutation $\tpi$ with tweak space $\calT$ and message space $\calM$, and tries to distinguish both worlds. Denote by $\tperm(\calT,\calM)$ the set of tweakable permutations. We define the strong PRP security of $\tE$ as
%
\begin{align*}
    &\advsprp{\tE}(\A) = \left|
        \begin{array}{l}
        \Pr\left(k\getR\calK\;:\;\A^{\tE_k^{\pm}} = 1 \right) - \Pr\left(\tpi\getR\tperm(\calT,\calM)\;:\;\A^{\tpi^{\pm}} = 1\right)
        \end{array} \right|\,.
\end{align*}
%
By $\advsprp{\tE}(Q,T)$ we denote the maximum security advantage of any adversary $\A$ that makes $Q$ queries and runs in time $T$.
\begin{theorem}\label{thm:tbc}
    Let $n=1024$ be the state size of \fish. We have
    \begin{align*}
    \advcpa{\NAME^{\fish}}(Q,T) &\leq \advsprp{\fish}(Q,T')\,,\\
    \advauth{\NAME^{\fish}}(Q,R,T) &\leq \advsprp{\fish}(Q+R,T')+\frac{R2^{n-\alpha}}{2^n-1}\,,
    \end{align*}
    where $T'\approx T$.
\end{theorem}
The proof is given in Appendix~\ref{app:tbc}. We briefly remark that the construction is even secure under \emph{release of unverified plaintext}, where $\msg$ is disclosed before tag verification is done \cite{asiacrypt/AndreevaBLMMY14}.

\section{\NAME: Expanded Tweak Space}\label{sec:tweetylrw}
The \NAME basic construction presents a rather small tweak space, limiting the sizes of the meta data and nonce. One way to resolve this is to employ a random oracle that maps the (larger) meta data and nonce to a string of size $128$ bits, but this would significantly degrade the security of the construction as forgeries can be found in a complexity $2^{64}$. Another way to enlarge the tweak space without adjusting the cipher itself is by using it in a tweakable mode of operation.
% \noindent\begin{minipage}[t]{\linewidth}
%     \vspace{-15pt}
    \begin{algorithm}[t]
    \caption{\;\;$\mathtt{Enc}^{\LRW[\fish]}$}\label{algo:LRWEnc}
        \begin{algorithmic}[1]
            \Require{$(\key,\msg,\meta,\nonce)\in\bink\times\binm\times\    bint\times\bins$}
            \Ensure{$(\ctxt,\auth)\in\bin{\nu}\times\bina$}
            \State{$c \gets \LRW[\fish](\key,
                \phantom{.}\pad_{1024}(\meta),\pad_{128}(\nonce),\pad_{  1024}(\msg))$}
            \State{\Return $(\lceil c\rceil_\nu,\lfloor c\rfloor_{\alpha})$}
        \end{algorithmic}
    \end{algorithm}
    % \vspace{-40pt}
    \begin{algorithm}[t]
    \caption{\;\;$\mathtt{Dec}^{\LRW[\fish]}$}\label{algo:LRWDec}
        \begin{algorithmic}[1]
            \Require{$(\key,\ctxt,\auth,\meta,\nonce)\in\bink\times\bin{\nu }\times\bina\times\bint\times\bins$}
            \Ensure{$\msg\in\binm$ or $\bot$}
            \State{$m\gets \LRW[\fish]^{-1}(\key,
                \phantom{.}\pad_{1024}(\meta),\pad_{128}(\nonce),\ctxt\| \auth)$}
            \State{$\msg\gets \unpad_{\mu+1}(\lceil m \rceil_{\mu+1})$}
            \State{\Return $\lfloor m\rfloor_\alpha=0\;?\;\msg : \bot$}
        \end{algorithmic}
    \end{algorithm}
% \end{minipage}

% ----------------------------------------------------------------
\begin{figure}[t]
    \centering
    \resizebox{.5\linewidth}{!}{%
    \begin{tikzpicture}
        [%
            auto,thick,%
            block/.style={draw,thick,rectangle,minimum height=5em,minimum width=5em},
            xor/.style={draw,circle,append after command={[shorten >=\pgflinewidth, shorten <=\pgflinewidth,] (\tikzlastnode.north) edge (\tikzlastnode.south)(\tikzlastnode.east) edge (\tikzlastnode.west)}},
            line/.style={draw, -latex',shorten <=1bp,shorten >=1bp,-angle 60}
        ]
        % box 1
        \node[block,anchor=center] (b1) at (0,0) {3fish};
        % box 2
        \node[block,anchor=center] (b2) at (4,0) {3fish};
        % oplus sign
        \node[xor,scale=1.2] (op) at (2,0) {};

        % labels
        \begin{scope}[node distance=2cm]
            \node[above of=b1] (key1) {$key$};
            \node[above of=b2] (key2) {$key$};
            \node[left of=b1]  (message) {\msg};
            \node[right of=b2] (cipher) {$\ctxt\|\auth$};
            \node[below of=b1] (tp1) {$\nonce$};
            \node[below of=b2] (tp2) {$\nonce$};
        \end{scope}
        \node[above of=op,node distance=2cm] (t) {$\meta$};
        \path[line] (b1) edge (op)
                    (op) edge (b2)
                    (message) edge (b1)
                    (b2) edge (cipher)
                    (key1) edge (b1)
                    (key2) edge (b2)
                    (tp1) edge (b1)
                    (tp2) edge (b2)
                    (t) edge (op);

    \end{tikzpicture}
    }
    \caption{\NAME based on $\LRW[\fish]$. Padding of data is excluded from the figure}\label{fig:LRW}
\end{figure}
% ----------------------------------------------------------------

Liskov \etal~\cite{LRW02} introduced two tweakable modes of operation: while these constructions are originally designed to add a tweak input to a blockcipher, they can equally well be applied to tweakable blockciphers themselves to enlarge the tweak space. We will consider one of these constructions, which makes two evaluations of the underlying cipher:\footnote{The other construction is less relevant as it requires an additional key and needs a universal hash function with a $1024$-bit range (or smaller, in which case the security of the construction degrades).}
\begin{align*}
\LRW[\fish]:\;\;&\bin{1024}\times\bin{1024}\times\bin{128}\times\bin{1024} \to \bin{1024}\,,\\
                 &(k,t,t',m) \mapsto \fish(k,t',\fish(k,t',m)\xor t)\,.
\end{align*}
This construction can be used to realize $\NAME^{\LRW[\fish]}$ as illustrated in \figref{fig:LRW} and described in Algorithms~\ref{algo:LRWEnc} and \ref{algo:LRWDec}. The conditions on the sizes of the inputs and outputs carry over from Section~\ref{sec:tweetytbc}, with the difference that meta data should now be of size at most $\tau\leq 1023$.

\desc{Security.}
The security of $\NAME^{\LRW[\fish]}$ follows from \thref{thm:tbc} and a result from \cite{LRW02}. We refer to Appendix~\ref{app:lrw} for the proof.
\begin{theorem}\label{thm:lrw}
    Let $n=1024$ be the state size of \fish. We have
    \begin{align*}
    \advcpa{\NAME^{\LRW[\fish]}}(Q,T)    &\leq \Theta\left(\frac{Q^2}{2^n}\right) + \advsprp{\fish}(2Q,T')\,,\\
    \advauth{\NAME^{\LRW[\fish]}}(Q,R,T) &\leq \Theta\!\left(\!\frac{(Q\!+\!R)^2}{2^n}\!\right) + \advsprp{\fish}(2(Q+R),T') + \frac{R2^{n-\alpha}}{2^n-1}\,,
    \end{align*}
    where $T'\approx T$.
\end{theorem}

% ----------------------------------------------------------------
\section{\NAME: Sponge Construction}\label{sec:tweetySponge}
The Sponge functions were originally introduced by Bertoni \etal~\cite{BDPA07} for cryptographic hashing, but can also be used in a broad spectrum of keyed applications, including message authentication~\cite{ADMV15-FSE,BDPA11-SKEW,NY16,crypto/GaziPT15} and stream encryption~\cite{BDPA11-SAC,asiacrypt/MenninkRV15}. They are also particularly useful for compact AE, and hence allow for an alternative instantiation of \NAME. The function realization resembles ideas of the full-state duplex mode \cite{asiacrypt/MenninkRV15}, transformed to the tweakable setting. Although this instantiation of \NAME focuses on compact AE, it can also be used to process longer messages. We remark that, as the keyed Sponges are merely stream based encryption, a unique nonce is required for every encryption.

% ----------------------------------------------------------------
\begin{figure}[t]
    \centering
    \resizebox{.8\linewidth}{!}{%
    \begin{tikzpicture}
        [%
            auto,thick,%
            block/.style={draw,thick,rectangle,minimum height=5em,minimum width=5em,font=\Large},
            xor/.style={draw,circle,append after command={[shorten >=\pgflinewidth, shorten <=\pgflinewidth,] (\tikzlastnode.north) edge (\tikzlastnode.south)(\tikzlastnode.east) edge (\tikzlastnode.west)}},
            line/.style={draw, shorten <=1bp,shorten >=1bp,-angle 60}
        ]
        % box 1
        \node[block,anchor=center] (b1) at (0,0) {$\pi$};
        \begin{scope}[node distance=0.7cm]
            \node (b_nw1) at (-0.7,0.5) {};
            \node (b_sw1) at (-0.7,-0.5) {};
            \node (b_ne1) at (0.7,0.5) {};
            \node (b_se1) at (0.7,-0.5) {};
        \end{scope}
        % box 2
        \node[block,anchor=center] (b2) at (5,0) {$\pi$};
        \begin{scope}[node distance=0.7cm]
            \node (b_nw2) at (4.3,0.5) {};
            \node (b_sw2) at (4.3,-0.5){};
            \node (b_ne2) at (5.7,0.5) {};
            \node (b_se2) at (5.7,-0.5) {};
        \end{scope}
        % box 3
        \node[block,anchor=center] (b3) at (10,0) {$\pi$};
        \begin{scope}[node distance=0.7cm]
            \node (b_nw3) at (9.3,0.5) {};
            \node (b_sw3) at (9.3,-0.5){};
            \node (b_ne3) at (10.7,0.5) {};
            \node (b_se3) at (10.7,-0.5) {};
        \end{scope}

        % oplus sign
        \node[xor,scale=1.2] (op1) at (1.7,0.5) {};
        \node[xor,scale=1.2] (op2) at (6.8,0.5) {};
        \node[right of=op1,node distance=1.4cm] (dot1) {\LARGE$\cdot$};
        \node[right of=op2,node distance=1.4cm] (dot2) {\LARGE$\cdot$};
        \node[right of=b_ne3,node distance=1.2cm] (dot3) {\LARGE$\cdot$};
        %\node at (12.5,0) {$\ldots$};

        % % labels
        \begin{scope}[font=\Large,node distance=2cm]
            \node[above left of=b_nw1] (tsht) {$\nonce \parallel \meta$};
            \node[left of=b_sw1] (key1) {$key$};
        \end{scope}
        \begin{scope}[font=\Large,node distance=1.4cm]
            \node[above of=op1]  (ms1) {$\msg_1$};
            \node[above of=op2] (ms2) {$\msg_2$};
            \node[above of=dot1] (ct0) {$\ctxt_1$};
            \node[above of=dot2] (ct1) {$\ctxt_2$};
            \node[above of=dot3] (ct2) {$\auth$};
        \end{scope}
        \node[font=\large,below of=dot1,node distance=2cm] {$\ctxt = \ctxt_1 \parallel \ctxt_2$};

        \draw[line] (tsht) |- (b_nw1.west);
        \path[line] (key1) edge (b_sw1)
                    (b_ne1) edge (op1)
                    (b_se1) edge (b_sw2)
                    (op1) edge (b_nw2)
                    (b_ne2) edge (op2)
                    (b_se2) edge (b_sw3)
                    (op2) edge (b_nw3)
                    (ms1) edge (op1)
                    (ms2) edge (op2);

        \draw[-angle 60] (dot1.center) -- (ct0);
        \draw[-angle 60] (dot2.center) -- (ct1);
        \draw[-angle 60] (dot3.center) -- (ct2);
        \draw (b_ne3) -- (12.5,0.5);
        \draw (b_se2) -- (8.5,-0.5);
        \draw (b_se3) -- (12.5,-0.5);

    \end{tikzpicture}
    }
    \caption{\NAME based on a Sponge. Padding of data is excluded from the figure.}
    \label{fig:Sponge}
\end{figure}
% ----------------------------------------------------------------

The realization of $\NAME^{\pi,\ell,n}$ (see \figref{fig:Sponge}) is indexed by a permutation $\pi$ of width $b$ and two parameters $\ell$ and $n\leq b$ which specify the way it parses the message blocks: it considers at most $\ell$ message blocks of size $n$ bits. The parameter $\ell$ can be arbitrarily large, but will be used to show how the length influences the security bound. $\NAME^{\pi,\ell,n}$ operates on keys of size $\kappa\leq b-n$ bits, messages and ciphertexts can be of any length at most $\mu=\ell\cdot n-1$ (note that the scheme does not use ciphertext expansion, hence $\mu=\nu$), and the sizes of the meta data and nonce should satisfy $\sigma+\tau\leq n-1$. The size of the authentication tag is $\alpha\leq n$ (this bound is merely for simplicity, the scheme easily generalizes to $\alpha>n$). We require $\mu+\alpha+\tau+\sigma\leq\lambdamax$. The formal encryption and decryption functionalities are given in Algorithms~\ref{algo:piEnc} and \ref{algo:piDec}.

% \noindent\begin{minipage}[tb]{\linewidth}
%     \vspace{-15pt}
    \begin{algorithm}[t]
    \caption{\;\;$\mathtt{Enc}^{\pi,\ell,n}$}\label{algo:piEnc}
        \begin{algorithmic}[1]
            \Require{$(\key,\msg,\meta,\nonce)\in\bink\times\binm\times\bint\times\bins$}
            \Ensure{$(\ctxt,\auth)\in\binm\times\bina$}
            \State{$\ell'\gets\lceil (|\msg|+1)/n\rceil$}
            \State{$\msg_1\parallel\cdots\parallel \msg_{\ell'}\xleftarrow{n\text{- }\mathrm{blocks}} \pad_{\ell'\cdot n}(\msg)$}
            \State{$s_0\gets \pad_n(\nonce\|\meta)\parallel 0^{b-n-|\key|}\parallel  \key$}
            \For{$i=1,\ldots,\ell'$}
                \State{$s_i\gets \pi(s_{i-1})$}
                \State{$s_i\gets s_i \xor \big(\msg_i\parallel 0^*\big)$}
                \State{$\ctxt_i\gets \lceil s_i\rceil_n$}
            \EndFor
            \State{$s_{\ell'+1}\gets \pi(s_{\ell'})$}
            \State{\Return $(\lceil \ctxt_1\parallel\cdots\parallel \ctxt_{\ell'} \ rceil_{|\msg|},\lceil s_{\ell'+1}\rceil_{\alpha})$}
        \end{algorithmic}
    \end{algorithm}
    % \vspace{-40pt}
    \begin{algorithm}[t]
    \caption{\;\;$\mathtt{Dec}^{\pi,\ell,n}$}\label{algo:piDec}
        \begin{algorithmic}[1]
            \Require{$(\key,\ctxt,\auth,\meta,\nonce)\in\bink\times\binm\times\bina\times\bint\times\bins$}
            \Ensure{$\msg\in\binm$ or $\bot$}
            \State{$\ell'\gets\lceil (|\ctxt|+1)/n\rceil$}
            \State{$\ctxt_1\parallel\cdots\parallel \ctxt_{\ell'}\xleftarrow{n\text {-}\mathrm{blocks}} \pad_{\ell'\cdot n}(\ctxt)$}
            \State{$s_0\gets \pad_n(\nonce\|\meta)\parallel 0^{b-n-|\key|}\parallel  \key$}
            \For{$i=1,\ldots,\ell'-1$}
                \State{$s_i\gets \pi(s_{i-1})$}
                \State{$\msg_i\gets \lceil s_i\rceil_n \xor \ctxt_i$}
                \If{$i<\ell'$}
                    \State{$s_i\gets \ctxt_i \parallel \lfloor s_i\rfloor_{b-n}$}
                \Else
                    \State{$s_i\gets \lceil \ctxt_i \rceil_{|\ctxt|\bmod n} \parallel \lfloor s_i\rfloor_{b-(|\ctxt|\bmod n)}$}
                \EndIf
            \EndFor
            \State{$\msg\gets \lceil \msg_1\parallel\cdots\parallel \msg_{\ell'} \rceil_{|\ctxt|}$}
            \State{$s_{\ell'+1}\gets \pi(s_{\ell'})$}
            \State{\Return $\lceil s_{\ell'+1}\rceil_{\alpha}=\auth\;?\;\msg : \bot $}
        \end{algorithmic}
    \end{algorithm}
%     \vspace{-15pt}
% \end{minipage}

%\medskip
\desc{Security.}
$\NAME^{\pi,\ell,n}$ is in fact a full-state duplex construction~\cite{asiacrypt/MenninkRV15}, but it is easier to explain the security of the construction in terms of the Inner-Keyed Sponge (\IKS) of Andreeva \etal~\cite{ADMV15-FSE}. This construction gets as input a key $k$, an arbitrarily sized message $m$, and a natural number $\rho$, and it outputs a digest $z$ of size $\rho$. That is $\IKS^\pi(k,m,\rho) = z\in\bin{\rho}$.
It is defined as the classical Sponge with an outer part of size $n$ and an inner part of size $b-n$, and with the capacity part being initialized using the key. We consider a specific case of \IKS where $\rho\leq n$, which means that the squeezing part of the Sponge takes exactly one round.

The security of variable-input-length $\IKS:\calK\times\bin{\ast}\to\bin{n}$ based on a permutation $\pi$ is slightly different from the CPA security of \secref{sec:tweety}; it differs in two aspects: first, $\IKS$ is variable length, so it is compared with a random oracle $\RO:\bin{\ast}\to\bin{n}$, and second, it is based on an underlying idealized permutation $\pi$ and the adversary also has two-sided oracle access to $\pi$. Denote by $\perm(\bin{b})$ the set of $b$-bit permutations. Abusing notation, we refer to the security of \IKS against an adversary that has access to either $(\IKS,\pi^{\pm})$ or $(\RO,\pi^{\pm})$, where $k\getR\calK$, $\pi\getR\perm(\bin{b})$, and $\RO$ is a random oracle, by
$\advcpa{\IKS}(\A)$. We define by $\advcpa{\IKS}(Q,S)$ the maximum advantage over all adversaries with total complexity $Q$, and that make at most $S$ primitive queries to $\pi^\pm$. Here, the total complexity $Q$ counts the number of \emph{fresh calls} to $\pi$ if $\A$ were conversing with $\IKS$.

Note that if no authentication is needed, then $\mathtt{Enc}^{\pi,\ell,n}$ and $\mathtt{Dec}^{\pi,\ell,n}$ do not require the computation of $s_{\ell'+1}\gets \pi(s_{\ell'})$ at the end, which saves a permutation call. Related to this, we define $\ell_\alpha$ as follows.
\begin{align*}
\ell_\alpha =
    \begin{cases}
    \ell\,, \text{ if }\alpha=0\,,\\
    \ell+1\,, \text{ if }\alpha>0\,.
    \end{cases}
\end{align*}

\begin{theorem}\label{thm:Sponge}
    Assume $\pi\getR\perm(\bin{b})$ is an ideal permutation. We have
    %
    \begin{align*}
    \advcpa{\NAME^{\pi,\ell,n}}(Q,T) &\leq \frac{(\ell_aQ)^2}{2^{b-n}} + \frac{\ell_aQS}{2^\kappa}\,,\\
    \advauth{\NAME^{\pi,\ell,n}}(Q,R,T) &\leq \frac{(\ell_aQ)^2}{2^{b-n}} + \frac{\ell_aQS}{2^\kappa} + \frac{R}{2^\alpha}\,.
    \end{align*}
    %
    where $S$ is the maximal number of evaluations of $\pi$ that can be made in time $T$.
\end{theorem}
The proof is given in Appendix~\ref{app:Sponge}.


\section{Applications of \NAME}\label{sec:appplications}
In this section we apply the \NAME constructions to various scenarios: low-latency messaging, secure mix formatting, and microblogging. Beyond these examples, \NAME is in fact suitable for any application requiring a compact output with high efficiency and security benefits.

\subsection{Secret Messaging}\label{sec:secmsg}

The popularity of secret message services has been increasing since Edward Snowden's whistleblowing events. Secret message protocols such as OTR~\cite{wpes/BorisovGB04}, TextSecure\footnote{Cf., \url{https://whispersystems.org}.}, and Wickr\footnote{Cf., \url{https://wickr.com}.} have been deployed into widely used mobile application. Most use common symmetric encryption schemes under an authenticated mode of operation, such as AES-CCM. In addition, for the purpose of forward secrecy, each scheme requires a re-keying protocol for providing a different session key for each communication. The usage of \NAME in such protocols allows for higher security and efficiency (for short messages) and provides the possibility to use these protocols through common text messaging channels, which are limited to 140 characters (1120 bits) per message.

One recent proposal that would be especially suitable to be instantiated with AITO is Vuvuzela \cite{van2015vuvuzela}. Compared with its closest alternatives (e.g., Tor), Vuvuzela achieves better anonymity and performance, but its proposed implementation is geared towards short messages (240 bytes of content). A combination of \NAME with Vuvuzela would allow for achieving higher security of the message contents together with the extreme anonymity of messaging. This would mean slightly shorter message content. %The system design  would not need to be changed or modified, but the implementation would only change from their proposed cryptographic library to one with support for \NAME.

\subsection{Secure Mix Formatting}\label{sec:applmix}
Mix networks rely on (cryptography based) mix message formats that provide nice efficiency and security properties. Sphinx~\cite{sp/DanezisG09} is the most compact cryptographic mix message format which is provably secure and efficient. To deliver such properties, Sphinx relies on the \emph{Sphinx blinding logic} technique for generating a session key consisting of nested MAC computations over the public pseudonyms of each predecessor mix. The private key associated to the public key (i.e., pseudonym) is only known by the user, while the session key is used for the encryption of the payload message.

Internally, Sphinx uses a plurality of cryptographic primitives. First, there are five hash functions, which are used to cryptographically hash group elements to key bit strings. Then, it uses a pseudorandom generator and a MAC function for the computation of the nested MAC. Finally, it uses an encryption scheme that encrypts the payload at every mix.

% The hash functions are instantiated using appropriately truncated SHA256 hash functions, using SHA256-HMAC-128 as the MAC function.
For the encryption, Sphinx relies on the LIONESS blockcipher by Anderson and Biham~\cite{DBLP:conf/fse/AndersonB96a}. This blockcipher is made out of the SEAL stream cipher and a keyed version of the SHA-1 hash function, and evaluates these functions on the message via a Feistel structure. In more detail, denote the stream cipher by $S_k$ and the keyed hash function by $H_k$. Consider a LIONESS key $k=(k_1,k_2,k_3,k_4)$, where $k_1,k_3$ will be used to key the stream cipher and $k_2,k_4$ to key the hash function. To encrypt a message $m$, LIONESS first splits it into two blocks $m_l\|m_r\gets m$. These two blocks are then transformed using a four-round Feistel structure:
\begin{align*}
m_r &\gets m_r\xor S_{k_1}(m_l)\,,\\
m_l &\gets m_l\xor H_{k_2}(m_r)\,,\\
m_r &\gets m_r\xor S_{k_3}(m_l)\,,\\
m_l &\gets m_l\xor H_{k_4}(m_r)\,.
\end{align*}
The updated $m_l\|m_r$ constitutes the ciphertext $c$.

LIONESS enjoys a security proof if the underlying hash function SHA-1 and stream cipher SEAL are secure~\cite{DBLP:conf/fse/AndersonB96a}, therewith making it particularly useful for Sphinx because of its goal to achieve provable security. However, LIONESS dates back to 1996, and has been outpaced by reality. In more detail, attacks on SEAL~\cite{DBLP:conf/fse/Fluhrer01a} and SHA-1~\cite{DBLP:conf/asiacrypt/CanniereR06,DBLP:conf/crypto/KarpmanPS15,DBLP:conf/eurocrypt/Stevens13,DBLP:journals/iacr/StevensKP15,DBLP:conf/crypto/WangYY05a}, the most recent result being a free-start collision attack on the full SHA-1, shine a negative light on the security of the LIONESS mode.

A naive solution to this situation is to replace SEAL by a more modern stream cipher and to replace SHA-1 by SHA-3, but there is little point in doing so: versatility of Sponges in general and SHA-3 in particular enables encryption using SHA-3 on the fly; putting a four-round Feistel construction on top of it is overkill. Instead, it makes more sense to simply \emph{replace} LIONESS by a keyed version of the SHA-3. The \NAME Sponge construction of Section~\ref{sec:tweetySponge} is particularly suited for this purpose, as it is an AE scheme based on the SHA-3 permutation. In this way, it seems logical to also replace the other cryptographic functionalities in Sphinx by SHA-3 or SHA-3 based alternatives. Alternatively, one can use the Threefish based version of \NAME (\secref{sec:tweetytbc} or \secref{sec:tweetylrw}), and use the Skein hash function family~\cite{FLS+11} to serve for hashing, as it already uses Threefish natively.

Either approach makes the encryption functionality of Sphinx more secure and more efficient. \figref{fig:sphinx} depicts our proposal of using \NAME in Sphinx. In addition, \NAME supports tweaks as input which could be used for the processing of the header, it allows for authentication, and could potentially be used as MAC function. These advantages could be exploited to integrate part of the nested MAC functionality of Sphinx within \NAME. As a bonus, Sphinx using \NAME \emph{additionally} authenticates the payload for free, a feature that was missing in the original Sphinx.

% ------------------------------------------------------------------------
\begin{figure}[t]
    \centering
    \resizebox{0.7\linewidth}{!}{%
    \begin{tikzpicture}%
    [%
        auto,font=\small\sffamily,
        myarrow/.style={-angle 60,>=stealth',shorten >=1pt}
    ]
        % Top rectangle
        \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=2pt] (7,4) -- (0,4);
        \node at (3.5,5) {Sphinx Header};

        \draw [fill=white] (0,3) rectangle (1,4);
        \node at (0.5,3.5) {$\alpha$};
        \draw [fill=white] (1.1,3) rectangle (5,4);
        \node at (3,3.5) {$\beta$};
        \draw [fill=white] (5.1,3) rectangle (7,4);
        \node at (6,3.5) {$\gamma$};
        %
        \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=2pt] (10,4) -- (7.1,4);
        \node at (8.5,5) {Payload};
        \draw [fill=white] (7.1,3) rectangle (10,4);
        \node at (8.5,3.5) {$\delta$};% $\tau = t - \mu$};
        

        % encrypt block
        \draw [fill=white] (1,1) rectangle (5.5,2);
        \node[font=\normalsize] at (3.25,1.5) {Sphinx Mix Header};


        % encrypt block
        \draw [fill=gray!30,very thick] (7.5,1) rectangle (9.5,2);
        \node[font=\normalsize] at (8.5,1.5) {\NAME};

        % Bottom rectangles ....
        % left
        \draw [fill=white] (0,-1) rectangle (1,0);
        \node at (0.5,-0.5) {$\alpha'$};
        \draw [fill=white] (1.1,-1) rectangle (5,0);
        \node at (3,-0.5) {$\beta'$};        
        \draw [fill=white] (5.1,-1) rectangle (7,0);
        \node at (6,-0.5) {$\gamma'^*$};
        \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=2pt] (0,-1) -- (10,-1);
        \node at (5,-1.75) {Route to Mix $n'$};
        % \node at (3.5,-1) {Tweakable blockcipher Output};

        \draw [fill=white] (7.1,-1) rectangle (10,0);
        \node at (8.5,-0.5) {$\delta'$};

        \node[font=\normalsize\sffamily] at (-0.1,2.3) {Mix $n$};
        \node[font=\normalsize\sffamily] (secret) at (-0.1,1.9) {secret $x_n$};

        \begin{scope}[myarrow,thick]
          \draw (secret) |- (1,1.5);
          \draw (5.5,1.75) -- (7.5,1.75);
          \draw (0.5,3) -- (0.5,2.5) -- (1.5,2.5) -- (1.5,2); % alpha
          \draw (3,3) -- (3,2); % beta
          \draw (6,3) -- (6,2.5) -- (5,2.5) -- (5,2); % gamma
          \draw (8.5,3) -- (8.5,2);
          % 
          \draw (1.5,1) -- (1.5,0.5) -- (0.5,0.5) -- (0.5,0); % alpha
          \draw (3,1) -- (3,0); % beta
          \draw (6,3) -- (6,2.5) -- (5,2.5) -- (5,2); % gamma
          \draw (8.5,1) -- (8.5,0);
          \draw (8.5,0.5) -- (6.3,0.5) -- (6.3,0);
          \draw (3,0.4) -- (5.8,0.4) -- (5.8,1.15) -- (7.5,1.15);  
          \draw (5,1) -- (5,0.6) -- (5.8,0.6);
        \end{scope}
        

        % concat
        \draw[fill=white] (5.8,0.5) circle (0.3cm);
        \node at (5.8,0.5) {$\parallel$};
        \node at (6.5,2.1) {session key $s_n$};
        \node at (7.25,0.7) {$auth$ tag};
        \node at (6.5,1.4) {$(\beta' \parallel \gamma')$};
        \node at (4.8,0.75) {$\gamma'$};
        \node at (3.25,0.6) {$\beta'$};
        % 
    \end{tikzpicture}
    }
    \caption{Using \NAME in Sphinx to process a Sphinx message $( (\alpha,\beta,\gamma),\delta)$ into $( (\alpha',\beta',\gamma'^*),\delta)$ at Mix $n$ with the secret $x_n$. Note that the key derivation from $s_n = \mathsf{keyderive}(\alpha, x_n)$, blinding $\alpha_n = \mathsf{blind}(\alpha,s_n)$, and $(\beta,\gamma) \rightarrow (\beta',\gamma')$ computations occur as in the original Sphinx (see \cite[Figure~3]{sp/DanezisG09}). The session key $s_n$ is used as the key, whereas the header $(\beta',\gamma')$ is used as metadata on the input of \NAME. }
    \label{fig:sphinx}
\end{figure}
% ------------------------------------------------------------------------

\subsection{Microblogging}\label{sec:applmicro}

The text input size limitation on microblogging systems, such as Twitter or Instagram, makes \NAME a particularly suitable solution for sharing secret messages with a high level of security (significantly higher than ordinary encryption modes).
Although the sharing of secret messages on platforms like these sounds illogical at first sense, the incorporation of \NAME is useful for sharing private messages among small segregated audiences.

The high level idea of applying \NAME to microblogging is as follows:
\begin{itemize}
  \item The time stamp of a tweet functions as the nonce $\nonce$;
  \item The hashtags (or part of them) function as a public meta data $\meta$;
  \item The tweet itself (and some hashtags, if needed) is authenticated and encrypted.
\end{itemize}
%
We denote the time stamp by $\tstamp$ and the hashtags by $\hasht$. Due to Twitter's limitation of 140 characters, we take $\lambdamax=1120$ bits, but we use the fact that the time stamp is implicit in the tweet. Thus, we require that $\nu+\alpha+\tau\leq1120$. We remark that the Unix time stamp is conventionally written in $32$ bits. This makes all three \NAME\ constructions  suitable for the application. %This is enough until January 19, 2038, before which all systems should be migrated to $64$-bit stamps.

Note that our specific application of \NAME to microblogging, allows the possibility of users to selectively decide on the information to share with providers without affecting their privacy, a term recently defined as the \emph{``gist''} of information shared~\cite{esorics/BilogrevicFCU14}. Based on this gist, the receiver could choose not to decrypt messages with a for him/her unappealing gist, while providers could enforce data utility and generate revenues.

Without loss of generality, we consider users to be registered, use, and share private information on any Twitter-like system. We also assume that users share a symmetric key using auxiliary out-of-band channels. For example, the users could employ the techniques from \cite{gunther2012cryptographic} to share the necessary keys with the intended recipients. This would also provide some anonymity for the audience as stated in \cite{gunther2012cryptographic}. In the most simple case, the users can get the keys by performing an authenticated Diffie-Hellman or by simply encrypting the secret with the public keys of the intended recipients. However, the exact details for this key exchange are beyond the scope of \NAME mechanism and this paper.

For a specific instantiation, we suggest the framework of \figref{fig:twitteroverview}. \NAME operates by parsing a $1120$-bit tweet into a message/hashtag-tuple $(\msg,\hasht)\in\binm\times\bint$. Using the time stamp $\tstamp\in\bins$, it is then encrypted to a ciphertext $\ctxt\in\binn$ and authenticated using tag $\auth\in\bina$ (absent if no authentication is needed, in which case we have $\alpha=0$). Thus, the encrypted tweet is of the form $(\ctxt,\auth,\hasht)\in\binn\times\bina\times\bint$ (the time stamp $\tstamp$ is implicit from the tweet).
%
In this configuration, nonce respecting behavior of users corresponds to them being ``time stamp respecting,'' and we assume that two tweets under the same secret key are never encrypted with the same time stamp.


% ------------------------------------------------------------------------
\begin{figure}[t]
    \centering
    \resizebox{0.64\linewidth}{!}{%
    \begin{tikzpicture}%
    [%
        auto,font=\small\sffamily,
        myarrow/.style={-angle 60,>=stealth',shorten >=1pt}
    ]
        % Top rectangle
        \draw [fill=white] (0,4.5) rectangle (10,5.5);
        \node at (5,5) {total size $t = 1120~bits$ (UTF-8 \emph{140 ``[A-Za-z0-9\_]'' characters)}};
        \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=2pt] (10,5.5) -- (0,5.5);
        \node at (5,6.5) {Normal Tweet};

        \draw [fill=white] (0,3) rectangle (7,4);
        \node at (3.5,3.5) {message (\msg)};
        %
        \draw [fill=white] (7.1,3) rectangle (10,4);
        \node at (8.5,3.5) {\#hashtags (\hasht)};% $\tau = t - \mu$};
        %
        \draw[dashed,thin] (0,4) -- (0,4.5);
        \draw[dashed,thin] (10,4) -- (10,4.5);

        % encrypt block
        \draw [fill=gray!30,very thick] (4,1.5) rectangle (6,2.5);
        \node at (5,2) {\NAME};

        % Bottom rectangles ....
        % left
        \draw [fill=white] (0,0) rectangle (7,1);
        \node at (3.5,0.5) {encryption (\ctxt) and authentication tag (\auth)};
        \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=2pt] (0,0) -- (10,0);
        \node at (5,-1) {\NAME (Encrypted) Output};
        % \node at (3.5,-1) {Tweakable blockcipher Output};

        % right
        \draw [fill=white] (7.1,0) rectangle (10,1);
        \node at (8.5,0.5) {\#hashtags (\hasht)};

        \draw[myarrow,thick] (5,3) -- (5,2.5);
        \draw[myarrow,thick] (5,1.5) -- (5,1);
        \draw[myarrow,thick,angle 60-angle 60] (8.5,1) |- (6,2);
        \draw[thick] (8.5,2) -- (8.5,3);
        \node (l) at (2,2.3) {$\key$};
        \node (t) at (2,1.7) {$\tstamp$};
        \draw[myarrow,thick] (l) -- (4,2.3);
        \draw[myarrow,thick] (t) -- (4,1.7);
        %
    \end{tikzpicture}
    }
    \caption{Using \NAME for microblogging to share private messages, while allowing filtering and providing limited data utility through the hashtags.}
    \label{fig:twitteroverview}
\end{figure}
% ------------------------------------------------------------------------

%Moreover, other privacy-friendly architectures have been suggested to replace existing platforms. Hummingbird~\cite{sp/CristofaroSTW12} presents a variant of Twitter that provably guarantees confidentiality of tweet contents, hashtags, and follower interests. Hummingbird bases its design on private set intersection methods~\cite{asiacrypt/CristofaroKT10} to match the authorized followers to the private tweets, and uses blockcipher to protect content.

\section{Practical Analysis}\label{sec:practical}
We consider the efficiency of various instantiations of \NAME in the context of the applications of Section~\ref{sec:appplications}. 

    \subsection{Performance}\label{sec:performance}
        \tabref{tab:comparison} summarizes the performances of the three instantiations of \NAME compared with AES-CBC. In this comparison we focused on messages satisfying $\lambdamax=1120$ and $\sigma=|\tstamp|\leq64$, making it particularly applicable to the examples of Sections~\ref{sec:secmsg} and \ref{sec:applmicro} (but the results are scalable to a certain degree). The comparison omits authentication (hence $\alpha=|\auth|=0$).

        For the tweakable blockcipher based modes, we have opted for \fish, as already discussed in Section~\ref{sec:tweetytbc}. For the Sponge based instantiation of \NAME, we have opted to use the Keccak permutation $\keccak:\bin{1600}\to\bin{1600}$~\cite{BDPA11} with various specific choices of $(\ell,n)$. Note that the complexity of $\NAME^{\keccak,\ell,n}$ increases linearly in $\ell$, and it is beneficial to keep $\ell$ small. We remark that a speed-up can be achieved by alternatively using the Keyak permutation~\cite{BDP+15}, which has less rounds and is thwarted to usage in keyed modes.
        %If $\ell=1$ and $n=1024$, the messages can be of size at most $1024$ bits, and $\nonce\|\meta$ is of size at most $1023$ bits. Security up to approximately $\frac{1600-n}{2}=288$ is achieved. In contrast, taking $\ell=2$ and $n=576$ gives flexible message lengths, $\nonce\|\meta$ should be of size at most $575$, and $512$-bit security is achieved.
        The c/b's in the table are derived from the speed of the Keccak permutation, AES-CBC, and $\fish$ on an Intel Core 2 for long messages \cite{Cryptopp,FLS+11,BDPA12}.

        We see that the three options for \NAME are mutually competitive, but all of them significantly outperform a classic mode like AES-CBC. This is caused by the fact that AES only has an 128-bit state, and hence a mode of operation has to be placed on top. Consequently, such a scheme on the one hand requires no less than $8$ blockcipher invocations, and on the other hand achieves only $128$-bit security (and distinguishing attacks can be performed in a complexity of about $2^{64}$~\cite{BDJR97}).

        \begin{table*}[tb]
            \centering
            \rowcolors{3}{}{lightgray}
            \caption{Comparison of the different versions of \NAME without authentication, compared with AES-CBC. A size is ``flex'' if it can take any value up to the trivial upper bounds ($|\ctxt|+|\hasht|\leq1120$ bits and $|\tstamp|\leq64$ bits). The size of the key is omitted, as it is always possible to take a key of size at least the security bound}\label{tab:comparison}
            \scalebox{0.9}{
            \begin{tabular}{@{\,}lcccccccccc}
                \toprule
                &\phantom{xxx}& \multicolumn{3}{c}{Size of} &\phantom{xxx}& \multicolumn{3}{c}{Efficiency} &\phantom{xxx}& Security\\
                %
                \cmidrule{3-5}\cmidrule{7-9}\cmidrule{11-11}
                %
                && $\ctxt$ &\phantom{xx}& $\hasht\|\tstamp$ && \phantom{\:}primitive\phantom{\:}           &\phantom{xx}& c/b           && bits\\
                %
                \midrule
                %
                AES-CBC         && flex       && flex     && $8\cdot$AES       && 16.0          && 64 \\
                %
                \fish          && 1024       && $<\!128$&& $1\cdot$\fish     && 6.5           && 512 \\
                %
                $\LRW[\fish]$  && 1024       && flex     && $2\cdot$\fish     && 13            && 512 \\
                %
                $\keccak,\ell,n$&&$\leq\!\ell\!\cdot\!n$&&$<\!n$&& $\ell\cdot$\keccak&& $\ell\cdot$12.5&& $\frac{1600-n}{2}$\\
                %
                $\phantom{\keccak,}\!\:1,1024$&&$\leq\!1024$&&$<\!1024$&& $1\cdot$\keccak&& 12.5&& $288$\\
                %
                $\phantom{\keccak,}\!\:1,800$&&$\leq\!800$&&$<\!800$&& $1\cdot$\keccak&& 12.5&& $400$\\
                %
                $\phantom{\keccak,}\!\:2,576$&& flex &&$<\!576$&& $2\cdot$\keccak&& 25&& $512$\\
                \bottomrule
            \end{tabular}
            }
        \end{table*}


    \subsection{Implementation}\label{sec:applmicro-prototype}
        %
        To demonstrate the viability and efficiency of our proposal, we have implemented \NAME (for $\lambdamax=1120$ and $\sigma\leq 64$) in Javascript and C. The first one allows easy portability among web applications and different browsers running on client-side, while the latter increases performance of the different instantiations of \NAME using the available C libraries for Threefish (Skein3Fish) and Keccak (KeccakCodePackage). The performances comply with the data from \tabref{tab:comparison}.
        %\footnote{\url{https://github.com/wernerd/Skein3Fish}}
        %\footnote{\url{https://github.com/gvanas/KeccakCodePackage}}
        
        Most applications (as mentioned in Section~\ref{sec:appplications}) use UTF-8 encoding of messages, which makes the bit length of a 140 character message non-constant as the representation of a UTF-8 encoded character is of size between $1$ and $4$ bytes. To get enough space for any expansion and/or overhead that the encryption might induce, it is possible to encode two bytes (16 bits) of the ciphertext into a single UTF-8 character.

        %
        % The current prototype is compatible with Firefox 14+, but it could be easily ported to other browsers extensions, e.g., to Chrome, as it is written in simple Javascript.
        % Specifically, the \texttt{Enc} and \texttt{Dec} operations are as follows:

        % \begin{description}
        %     \item[]\texttt{Enc:} The user selects the Twitter text input area, and the extension launches a dialog where the user inserts the secret message and the public hashtags. The extension encrypts using the message, the hashtag, with the server time stamp, and the key as input and publishes the result into the Twitter text area.
        %     \smallskip
        %     \item[]\texttt{Dec:} The Firefox extension parses the messages on the Twitter-feed, and for each message transparently decrypts and replaces the result with the secret message.
        % \end{description}
        %

        % \medskip
        % \desc{\boldmath{\NAME}.} The cryptographic module of \NAME-App comprises the Javascript implementation of the \NAME cipher designs based on Threefish, allowing easy portability to other browser implementations, e.g., Chrome. However, in order to increase performance, the \NAME cryptographic module can also be used, interacting with Firefox through a local socket connection. In particular, the different instantiations of \NAME were implemented using the available C libraries for Threefish and Keccak: Skein3Fish\footnote{\url{https://github.com/wernerd/Skein3Fish}} and KeccakCodePackage,\footnote{\url{https://github.com/gvanas/KeccakCodePackage}} respectively.
        % Therefore, the performance of \NAME-Sponge (2 permutations of Keccak-1600) takes approximately 4~$ms$, whereas \NAME-Threefish-1024 takes also about 5~$ms$. Hence
        % The performances comply with the data from \tabref{tab:comparison}.

        %
        % For the sake of simplicity, the \NAME implementation uses a passphrase as input to a key derivation function to generate the secret key, whereas the exchange of the key is assumed to be performed using a secure and authenticated offline channel. However, the secret key distribution could be made by posting a QR code image containing the encryption of the secret key using the public key of the intended recipients.
        %
        % In addition, while it only supports desktop browsers at the moment, \NAME-App is perfectly suitable for resource-constrained devices, such as smartphones.
        % This is crucial considering that a significant portion of users access Twitter via their mobile devices. Even the somewhat increased size of the key will not be a problem in these settings.

        % \medskip
        % \desc{Encoding of Messages.}
        % As aforementioned, Internet services like Twitter use UTF-8 to encode shared messages. Thus, the bit length of a 140 character message is not constant, as the representation of a UTF-8 encoded character can be range between 1--4 bytes.\footnote{See for example \url{unicode.org/faq/utf_bom.html}} However, if only ASCII characters are used, then UTF-8 encoding will only take one byte per character, and we get the $8\times140 = 1120$ bits that is used as a starting point of our constructions.

        % One problem with UTF-8 encoding is that after encryption, when we have an arbitrary sequence of bits, it is likely that it is no longer valid UTF-8 and thus we need to do some encoding for the ciphertext. In our implementation we have chosen to encode two bytes (16 bits) of the ciphertext into a single UTF-8 character and thus get more than enough space for any expansion and/or overhead that the encryption might induce. The encoding works by simply mapping the two bytes into the Unicode character table\footnote{See for example \url{http://unicode-table.com/en/}} and encoding this character as valid UTF-8.

        % Traditional encoding schemes for encrypted data are base64 and base56, but these schemes' overhead will not allow encrypted and encoded tweets to be represented in only single tweets as the textual output is much longer than 140 characters if we have 1120 bits (or more) of ciphertext. With our encoding, it is possible to have the ciphertext in a single tweet, although the actual binary length of our encoding can add more overhead than the traditional schemes in some cases. This is of course specific to Twitter and UTF-8 encoding and in other possible applications the encoding can be done in other ways that are most suitable to that OSN.

% ----------------------------------------------------------------
%\section{Related Work}\label{sec:relatedwork}
% Along with the increased popularity of OSNs several privacy concerns start to arise which have prompted a large interest within the research community. As a result, several privacy-preserving solutions have been proposed to deliver OSN content confidentiality by means of existing cryptographic mechanisms. However, there is a lack of tailored designs that take into account the space limitation and the general design of OSNs. For instance, systems like FaceCloak~\cite{cse/LuoXH09} use blockciphers under different modes of operation such as AES-CBC to protect the content. Scramble~\cite{pet/BeatoKW11} and FSEO~\cite{codaspy/BeatoICPL13} use a broadcast encryption mechanism that encrypts the content using a blockcipher under a mode of operation. It attaches a header with the public-key encryptions of the key used by the blockcipher, representing the access control list of the content. Similarly, Persona~\cite{sigcomm/BadenBSBS09} and EaSiER~\cite{asiaccs/JahidMB11} use attribute-based encryption mechanisms to protect confidentiality while allowing access control definition by attributes.

% Tweetcipher~\cite{other/tweetcipher} was presented by a group of cryptographers as a compact authenticated encryption algorithm initiated through Twitter discussions. Although Tweetcipher is based on Sponge and Salsa20~\cite{estream/salsa20} constructions, it aims at delivering authentication and requires six tweets, whereas \NAME requires only one tweet with easy re-keying and public hashtags.

%
% In general, such constructions require large entropy which may not be allowed by OSNs like Twitter. Also those constructions demand at least $8$ AES evaluations achieving only $64$-bit indistinguishability security. Aligned with the fact that general tweets are of a relatively short (but larger than $128$ bits) length, the dedicated constructions presented by the different \NAME approaches achieve higher efficiency results and a much higher level of security. This can be seen from \tabref{tab:comparison}. In addition, \NAME can be used together with the broadcast and attribute-based encryptions solutions as a tailored symmetric encryption, and with Hummingbird system for protecting tweets.

% ----------------------------------------------------------------
\section{Conclusion}\label{sec:concl}
This paper presented \NAME, a novel family of compact and highly secure authenticated encryption schemes that are based on either tweakable blockciphers of Sponge functions. We have shown that \NAME can be deployed in various privacy-oriented applications that aim at short messages, including direct messaging protocols such as OTR and Vuvuzela, the Sphinx mix network, and online social networks and microblogging services such as Twitter and Instagram. Due to its specific design goals, \NAME performs better than its competitors on applications like these. Applications beyond the ones of Section~\ref{sec:appplications} likely exist. In any case, our work demonstrates that in certain scenarios, an application-oriented cryptographic design may be more suitable than the generic solutions.

We remark that, although the tweakable blockcipher-based versions of \NAME offer resistance against nonce reuse (with a slight security degradation), this is not the case for the Sponge based version. This may be problematic in certain scenarios. For instance, in our application to microblogging (Section~\ref{sec:applmicro}), this would translate to time stamp respecting adversaries. In the case of protection against time stamp misuse, for example by the OSN itself, the \NAME can accommodate a client generated time stamp. This would add some overhead (of 32 bits), but could protect against this type of attack. %In any case, there are many incentives for a platform such as Twitter to remain honest, such as bad publicity.

%Furthermore, in order to fit more information than the common 1120 bits (i.e., 140 characters using Latin UTF-8 alphabet) into single tweets, one could employ bit packing schemes. For instance, by using larger character sets, such as emoji characters and Chinese characters, one can accommodate extra information as these characters are larger than 8 bits. This requires that the overhead of the encryption and other information is embedded in the 140 characters allowed by Twitter for single tweets by encoding the overhead and cryptotext in some character set larger than the original. In \NAME, this is not necessary, if one adheres to UTF-8 and basic Latin alphabet. To accommodate other character systems and also even emoji, one could extend \NAME with some bit packing scheme.
%
% Our application does not provide key exchange between the participants and this can be seen as a limitation of our system. We assume that this key exchange can take place in whatever means the users of the system feel is best for their intentions. It can be offline or online (based on some PKI). \NAME can then be used after the key has been agreed upon and distributed to the necessary recipients.

    %\bigskip\noindent\textsc{Acknowledgments. }This work was supported in part by the Research Council KU Leuven: GOA TENSE (GOA/11/007). Bart Mennink is a Postdoctoral Fellow of the Research Foundation -- Flanders (FWO).

% ----------------------------------------------------------------
\bibliographystyle{splncs}
\bibliography{tweetybib}

\clearpage
\appendix
\section{Proof of \thref{thm:tbc}}\label{app:tbc}
%\begin{proof}
    We start with the secrecy of $\NAME^{\fish}$. Let $\A$ be an adversary that makes $Q$ queries and runs in time $T$. It has access to either $\mathtt{Enc}_\key$ or $\$$. Note that $Q$ evaluations of $\NAME^{\fish}$ induce $Q$ evaluations of $\fish$. We replace $\fish$ by an ideal tweakable permutation $\tpi\getR\tperm(\bin{128},\bin{1024})$. Now, any query $\mathtt{Enc}^{\tpi}(\key, \msg, \meta, \nonce)$ is responded with
    %
    \begin{align*}
    \ctxt\|\auth = \tpi(\key,\pad_{128}(\nonce\|\meta),\pad_{1024}(\msg))\,.
    \end{align*}

    \noindent
    As $\A$ is required to be nonce respecting, every query is made under a new nonce, which means that every query initiates a new instance of $\tpi$, and $\ctxt\|\auth$ is a random $1024$-bit value. This means that $\mathtt{Enc}^{\tpi}_\key$ is perfectly indistinguishable from $\$$.

    For authenticity, the first part of the proof is identical: we replace $\fish$ by ideal tweakable permutation $\tpi\getR\tperm(\bin{128},\bin{1024})$, where now the $Q+R$ evaluations of $\NAME^{\fish}$ induce $Q+R$ evaluations of $\fish$. It remains to consider the probability to forge an authentication tag for $\NAME^{\tpi}$. By \cite{DBLP:journals/iacr/BellareGM04}, it suffices to consider any attempt and sum over all $R$ attempts. Consider any forgery attempt $(\ctxt,\auth,\meta,\nonce)$. Note that, as $\A$ is required to be nonce respecting, there has been at most one encryption query under meta data $\meta$ and nonce $\nonce$. Therefore, the value
    %
    \begin{align*}
    m = \tpi^{-1}(\key,\pad_{128}(\nonce\|\meta),\ctxt\|\auth)
    \end{align*}

    \noindent
    is randomly drawn from a set of size at least $2^n-1$, and satisfies $\lfloor m\rfloor_\alpha=0$ with probability at most $2^{n-\alpha}/(2^n-1)$.
%\qed\end{proof}

\section{Proof of \thref{thm:lrw}}\label{app:lrw}
%\begin{proof}
    Note that the derivation in \thref{thm:tbc} not only applies to \fish, but to any tweakable blockcipher. Applied to $\LRW[\fish]$ we get
    \begin{align*}
    \advcpa{\NAME^{\LRW[\fish]}}(Q,T)    &\leq \advsprp{\LRW[\fish]}(Q,T'')\,,\\
    \advauth{\NAME^{\LRW[\fish]}}(Q,R,T) &\leq \advsprp{\LRW[\fish]}(Q+R,T'') + \frac{R2^{n-\alpha}}{2^n-1}\,,
    \end{align*}
    where $T''\approx T$. In \cite{LRW02} it is proven that
    \begin{align*}
        \advsprp{\LRW[\fish]}(Q,T'') \leq \Theta\left(\frac{Q^2}{2^n}\right) + \advsprp{\fish}(2Q,T')\,,
    \end{align*}
    where $T'\approx T''$.
%\qed\end{proof}

\section{Proof of \thref{thm:Sponge}}\label{app:Sponge}
%\begin{proof}
    Let $\A$ be an adversary that makes $Q$ queries and runs in time $T$. It has access to either $\mathtt{Enc}_\key$ or $\$$. Consider any evaluation $\mathtt{Enc}_\key$ on input of $(\msg,\meta,\nonce)$. If we define $k=0^{b-n-|\key|}\|\key$, then its output is as follows,
    %
    \begin{align*}
    \ctxt=&\;\IKS^\pi(k,\pad_n(\nonce\|\meta),n) \xor \msg_1 \parallel\\
         &\;\IKS^\pi(k,\pad_n(\nonce\|\meta)\| \msg_1,n) \xor \msg_2 \parallel\\
         &\;\cdots\,\\
         &\;\IKS^\pi(k,\pad_n(\nonce\|\meta)\| \msg_1\cdots \msg_{\ell-2},n) \xor \msg_{\ell-1} \parallel\\
         &\;\lceil\IKS^\pi(k,\pad_n(\nonce\|\meta)\| \msg_1\cdots \msg_{\ell-1},n) \xor \msg_\ell\rceil_{|\msg|\bmod n}\,,\\
    \auth=&\;\IKS^\pi(k,\pad_n(\nonce\|\meta)\| \msg_1\cdots \msg_{\ell},\alpha)
    \end{align*}
    Where abusing notation, $|\msg|\bmod n\in\{1,\ldots,n\}$. In other words, any evaluation of $\mathtt{Enc}_\key$ entails $\ell_\alpha$ evaluations of $\IKS$ (the computation of $\auth$ is omitted if $\alpha=0$). Each of these evaluations adds $1$ to the complexity (as it is simply an extension of the previous one). Thus, after $Q$ evaluations of $\mathtt{Enc}_\key$, \IKS is evaluated with a total complexity $\ell_a Q$. We replace $\IKS$ by a random oracle $\RO$. This step costs us $\advcpa{\IKS}(\ell_a Q,S)$, where $S$ is as described in the theorem statement.

    Now, for the case of secrecy, recall that $\A$ is nonce respecting. Consequently, all evaluations of $\RO$ are made for a different input. This is clear for the $\ell+1$ queries for a single evaluation; different evaluations of $\mathtt{Enc}_\key$ are made under a different $\nonce$ as the adversary is nonce respecting. Consequently, every query to $\mathtt{Enc}_\key$ is responded with a uniformly randomly generated $|\msg|$-bit value, and thus,
    \begin{align*}
    \advcpa{\NAME^{\pi,\ell,n}}(Q,T) \leq \advcpa{\IKS}(\ell_a Q,S)\,.
    \end{align*}
    Next, for authenticity, it suffices to only focus on the value $\auth$. Consider any forgery attempt $(\ctxt,\auth,\meta,\nonce)$. Let $\msg$ be the message that is derived by $\mathtt{Dec}^{\pi,\ell,n}$. As the forgery is required to be non-trivial, $\RO$ has never been queries on
    \begin{align*}
    \pad_n(\nonce\|\meta)\| \msg_1\cdots \msg_{\ell}
    \end{align*}
    before. Its response $\auth$ is thus a randomly generated value and the forgery is successful with probability $1/2^\alpha$. Again using \cite{DBLP:journals/iacr/BellareGM04},
    \begin{align*}
    \advauth{\NAME^{\pi,\ell,n}}(Q,R,T) \leq \advcpa{\IKS}(\ell_a Q,S) + \frac{R}{2^\alpha}\,.
    \end{align*}
    Now, in \cite{ADMV15-FSE} it is proven that\footnote{We have slightly re-interpreted the result in order to accommodate the different key length.}
    \begin{align*}
    \advcpa{\IKS}(Q',S) \leq \frac{(Q')^2}{2^{b-n}} + \frac{Q'S}{2^\kappa} \,,
    \end{align*}
    which completes the proof of both secrecy and authenticity.
%\qed\end{proof}

\end{document}

