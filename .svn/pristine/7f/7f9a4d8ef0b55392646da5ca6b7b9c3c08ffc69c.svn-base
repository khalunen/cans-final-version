\documentclass[USenglish,oneside,twocolumn]{article}

\usepackage[utf8]{inputenc}%(only for the pdftex engine)
%\RequirePackage[no-math]{fontspec}%(only for the luatex or the xetex engine)
\usepackage[big]{dgruyter_NEW}
\usepackage{etex}


%%%%%%%%%%%%%%%%%%%%%%%% General Packages %%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{pdflscape}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath,mathtools}
\usepackage{inputenc}
\usepackage{hyperref}
\usepackage{paralist}   % Required for compactum
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{threeparttable}
\usepackage[table]{xcolor}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\usepackage{enumerate}
\usepackage{xspace}
\usepackage{multirow}
\usepackage{colortbl}
\usepackage{enumitem}


% For theorems
\newtheorem{theorem}{Theorem}

\usepackage{tikz}
\usetikzlibrary{decorations.pathreplacing}
\usetikzlibrary{arrows}
\usetikzlibrary{positioning}
%%%%%%%%%%%%%%%%%%%%%%%% Custom Macros %%%%%%%%%%%%%%%%%%%%%%%%

% References
% -------------------------------------------------------
\newcommand{\figref}[1]{{Figure}~\ref{#1}}      % Figure
\newcommand{\tabref}[1]{{Table}~\ref{#1}}       % Table
\newcommand{\secref}[1]{{Section}~\ref{#1}}     % Section
\newcommand{\appref}[1]{{Appendix}~\ref{#1}}    % Appendix
\newcommand{\defref}[1]{{Definition}~\ref{#1}}  % Definition
\newcommand{\thref}[1]{{Theorem}~\ref{#1}}      % Theorem
\newcommand{\remref}[1]{{Remark}~\ref{#1}}      % Remark
% -------------------------------------------------------

% Description
% -------------------------------------------------------
\newcommand{\desc}[1]{\vspace{0.15cm} \noindent \textbf{#1}}

% Tweety-related
% -------------------------------------------------------
\newcommand{\tweety}{\ensuremath{\mathrm{Tweety}}\xspace}
\newcommand{\key}{\ensuremath{\mathit{key}}}
\newcommand{\hasht}{\ensuremath{\mathit{ht}}}
\newcommand{\tstamp}{\ensuremath{\mathit{ts}}}
\newcommand{\msg}{\ensuremath{\mathit{msg}}}
\newcommand{\ctxt}{\ensuremath{\mathit{ctxt}}}
\newcommand{\auth}{\ensuremath{\mathit{auth}}}
\newcommand{\fish}{\ensuremath{\mathrm{3fish}}\xspace}
\newcommand{\LRW}{\ensuremath{\mathrm{LRW}}\xspace}
\newcommand{\LRWa}{\ensuremath{\mathrm{LRW1}}\xspace}
\newcommand{\LRWb}{\ensuremath{\mathrm{LRW2}}\xspace}
\newcommand{\TwSp}{\ensuremath{\mathrm{TwSp}}\xspace}
\newcommand{\Sp}{\ensuremath{\mathrm{Sp}}\xspace}
\newcommand{\keccak}{\ensuremath{\pi_{\mathrm{keccak}}}\xspace}
\newcommand{\IKS}{\ensuremath{\mathrm{IKS}}\xspace}

% Others
% -------------------------------------------------------
\newcommand{\etal}{et al.}
\newcommand{\xor}{\oplus}
\newcommand{\getR}{\xleftarrow{{\scriptscriptstyle\$}}}
\newcommand{\tE}{\widetilde{E}}
\newcommand{\tpi}{\widetilde{\pi}}
\newcommand{\func}{\mathsf{Func}}
\newcommand{\perm}{\mathsf{Perm}}
\newcommand{\tperm}{\widetilde{\mathsf{Perm}}}
\newcommand{\RO}{\mathcal{RO}}
\newcommand{\bin}[1]{\{0,1\}^{#1}}
\newcommand{\bink}{\bin{\kappa}}
\newcommand{\bint}{\bin{\leq\tau}}
\newcommand{\bins}{\bin{\sigma}}
\newcommand{\binm}{\bin{\leq\mu}}
\newcommand{\binn}{\bin{\leq\nu}}
\newcommand{\bina}{\bin{\alpha}}
\newcommand{\adv}[2]{\ensuremath{\mathbf{Adv}_{#2}^{\mathrm{#1}}}}
\newcommand{\advsprp}[1]{\adv{\widetilde{sprp}}{#1}}
\newcommand{\advcpa}[1]{\adv{cpa}{#1}}
\newcommand{\advauth}[1]{\adv{auth}{#1}}
\newcommand{\A}{\mathcal{A}}
\newcommand{\calK}{\mathcal{K}} %key
\newcommand{\calT}{\mathcal{T}} %cipher-tweak
\newcommand{\calM}{\mathcal{M}} %cipher-in
\newcommand{\calC}{\mathcal{C}} %cipher-out
\newcommand{\pad}{\mathsf{pad}}
\newcommand{\unpad}{\mathsf{unpad}}
\definecolor{lightgray}{gray}{0.9}
% -------------------------------------------------------


% Personal Comments
% -------------------------------------------------------
\newcommand{\filipe}[1]{{\color{red}\textsf{Filipe says:} \emph{#1}}}
\newcommand{\kimmo}[1]{{\color{blue}\textsf{Kimmo says:} \emph{#1}}}
\newcommand{\bart}[1]{{\color{orange}\textsf{Bart says:} \emph{#1}}}
% -------------------------------------------------------

\DOI{foobar}

\cclogo{\includegraphics{by-nc-nd.pdf}}

\begin{document}

  \author[1]{Anonymous}
  \affil[1]{(Anonymous Submission)}
  % \author*[1]{Filipe Beato}

  % \author*[2]{Kimmo Halunen}

  % \author*[3]{Bart Mennink}

  % % \author[4]{Fourth Author}

  % \affil[1]{ESAT/COSIC, KU Leuven and iMinds, Leuven, Belgium, E-mail: filipe.beato@kuleuven.be}

  % \affil[2]{VTT Technical Research Center of Finland, Oulu, Finland, E-mail: kimmo.halunen@vtt.fi}

  % \affil[3]{ESAT/COSIC, KU Leuven and iMinds, Leuven, Belgium, E-mail: bart.mennink@kuleuven.be}

  % \affil[4]{Affil, E-mail: email@email.edu}

  \title{\huge Tweety: Tweet Secrets Efficiently}
  \runningtitle{Tweety: Tweet Secrets Efficiently}

  \begin{abstract}
    {Online social networks such as Twitter provide users with easy and reliable channels for dissemination of information. These networks play a fundamental role in quick dissemination of information as well as coordinating and amplifying grassroots movements, as demonstrated by recent Arab spring events.
    %
    At the same time, those networks store treasure troves of information to support their economical business model through targeted advertisements, and have become prime targets of censorship and surveillance based on the content shared.
    %
    % Add more privacy issues + motivation
    %
    In this paper, we propose Tweety, a novel and secure privacy mechanism tailored for usage in social media websites. Tweety guarantees semantic security while complying with the commonly imposed space restrictions and allowing limited user defined targeted advertisement. After formalizing Tweety we present three distinct designs based on different primitives, tweakable blockciphers and Sponge functions, that offer higher levels of security than existing alternatives.
    Furthermore, we implemented a prototype demonstrating the improved efficiency and low overhead of our constructions, mainly related to the increased key sizes for better security.}
  \end{abstract}
  \keywords{Privacy, social media, tweakable blockciphers, Sponge.}
%  \classification[PACS]{}
 % \communicated{...}
 % \dedication{...}

  \journalname{Proceedings on Privacy Enhancing Technologies}
\DOI{Editor to enter DOI}
  \startpage{1}
  \received{..}
  \revised{..}
  \accepted{..}

  \journalyear{2015}
  \journalvolume{2015}
  \journalissue{2}

\maketitle

\section{Introduction}\label{sec:intro}


With the large growth of Internet services modern users rely more on digital and ubiquitous communications. Services such as Online Social Networks (OSNs) and mobile direct messaging have become prominent communication channels by providing efficient as well as reliable sharing tools for dissemination and exchange of information. At the same time, given their prominent design, providers end up centralizing and storing large amounts of information about the users and their communications, thus leading to several privacy threats.
%
Most popular OSNs, such as Facebook, Google+, and Twitter, provide users with certain privacy controls over their content and with secured direct messaging. While secure messaging usually employs end-to-end encryption mechanisms~\cite{sp/UngerDBFPG015}. However, this process relies not only on the diligence of the users but also on the trustworthiness of the providers in protecting stored content from possible adversaries.  Nevertheless, providers require access to the content in order to comply with their economical model, such as targeted advertisement~\cite{NEWS/SLT:facebooksued4,HOTNEts:RiedererECKR11}, consequently exposing users to several privacy issues.
%
% Online Social Networks (OSNs), such as Facebook, Google+, and Twitter, alongside direct messaging solutions such as WhatsApp and iMessage,
% In particular, Twitter has facilitated a very rapid-fire style of information sharing helping for example grassroots democracy movements in many places over the world.
% Given their prominent role and design, OSNs end up centralizing and storing large amounts of information, exposing users to several privacy threats.
% Although most popular OSNs provide users with certain privacy controls over their content and with secured direct messaging, this process relies not only on the diligence of the users but also on the trustworthiness of the providers in protecting stored content from possible adversaries.
% corrent this sentence!
This has lead to several reports of mass breaches on the information shared on OSNs~\cite{NEWS/FBBug15}, as is evident from the recent accounts of surveillance programs like Prism~\cite{NEWS/WP:prism13}, and the recent iCloud mega leak~\cite{NEWS/FBS:icloud14}, amplifying the privacy issues.
%


% addd examples of the problems we are solving!

% cite Whatâ€™s the Gist? Privacy-Preserving Aggregation of User Profiles

% Moreover,
% business model shit
% breaches
% efficiency
% key management
%
These issues motivate the need to implement more reliable user-centric privacy protection mechanisms, such as end-to-end encryption. One possible solution is to encrypt all the data shared and transferred, for instance using a standard encryption modes of operation, such as AES-CTR or AES-CBC, or a secure messaging protocol, such as OTR~\cite{wpes/BorisovGB04}.
%
However, those constructions have several shortcomings. For instance, sharing encrypted information breaks the business model relying on the mining of the shared content to provide targeted advertisements, which could cause providers to restrict and censor the distribution of the encrypted content. It has been shown that is possible to keep data utility and privacy by allowing providers to access limited information~\cite{esorics/BilogrevicFCU14}. Also, those general constructions do not take into account the limitations and specific properties of OSN, such as the space constraints (140 characters, about 1120~$bits$) and the use of hashtags for filtering and marking specific events, in the case of Twitter and Instagram. For instance, an adaption of the CTR or CBC mode of operation with AES-128\footnote{http://codecereal.blogspot.ch/2011/06/encrypted-tweets.html} to those properties, achieves $128$-bit security \emph{at most}, and even allows for distinguishability attacks in complexity about $2^{64}$ (cf.~Bellare \etal~\cite{BDJR97}), while requiring at least $8$ AES evaluations.
%
% Although direct messaging services apply similar mechanisms to protect the communication among users, these are generally inefficient and often require keys to be managed by providers.


%
In this paper we propose \emph{Tweety}, a novel privacy mechanism tailored for restricted space messaging services, such as Twitter-like OSNs, that selectively reveals parts of your shared content while keeping the majority of the data available only to selected recipients. Besides access control by means of encryption, it additionally allows for authenticity, ensuring integrity of data. In particular, Tweety employs recent advances in tweakable blockciphers and Sponge functions to achieve efficient authenticated encryption and high levels of security. We show that these constructions achieve provable security that is better than existing possibilities for this type of authenticated encryption with a tolerable cost in key size. Furthermore, our construction helps to save some computational resources at the recipient side of the communication as it is possible filter messages based on the hashtags, and thus limit the number of decryption operations. For instance, one could choose not to decrypt messages with the hashtag ``\#football'' from a certain (or every) user. This provides energy saving benefits with some resource constrained devices, while enabling providers to keep the data utility of some information to support their economical business model. Although we consider Twitter as the main application, Tweety mechanisms can be applied and used in many different applications, allowing security, integrity, and efficiency while enabling providers to prevail some data utility. For instance, it can be plugged into several messaging protocols by replacing the symmetric key operation allowing higher security and usage on single tweets. As well as used to increase the 128-bit security and efficiency of anonymized messages in a mix-network such as Sphinx~\cite{sp/DanezisG09}. 



%
The paper is organized as follows: \secref{sec:model} introduces the required notation, and formally describes Tweety and the assumed threat model. After describing in \secref{sec:tweetytbc} the basic approach of Tweety based on Threefish \cite{FLS+11}, \secref{sec:tweetylrw} extends to allow expanded tweak space. \secref{sec:tweetySponge} presents another version of Tweety based on Sponge functions \cite{BDPA07}. Then, we describe our proof-of-concept implementation in \secref{sec:prototype}, while \secref{sec:relatedwork} reviews related work. Finally, \secref{sec:concl} discusses the results and concludes the paper.



\section{Model}\label{sec:model}
This section introduces the required notation, Tweety, and the respective threat model. Without loss of generality, we consider users to be registered, use, and share private information on Twitter. We also assume that users share a symmetric key using auxiliary out-of-band channels. For example, by performing a authenticated Diffie-Hellman or by simply encrypting the secret with the public keys of the intended recipients. However, this is beyond the scope of Tweety mechanism.


\subsection{Notation}
For $n\in\mathbb{N}$, $\bin{n}$ is the set of $n$-bit strings, and $\bin{\leq n}=\bigcup_{i=0}^n\bin{i}$. For two bit strings $M,N$, their concatenation is denoted $M\|N$, and if $M$ and $N$ are of the same size, $M\xor N$ denotes their bitwise XOR. Furthermore, if $M\in\bin{\leq n-1}$, then $\pad_n(M)=M\|10^{n-1-|M|}$. For a string $N\in\bin{n}$, we define by $\unpad_n(N)$ the unique string $M\in\bin{\leq n-1}$ such that $\pad_n(M)=N$. For $m\leq n$ and $N\in\bin{n}$, we denote by $\lceil N\rceil_m$ the leftmost $m$ bits and by $\lfloor N\rfloor_{n-m}$ the rightmost $n-m$ bits of $N$, in such a way that $N=\lceil N\rceil_m\|\lfloor N\rfloor_{n-m}$.

% ------------------------------------------------------------------------
\begin{figure}[t]
    \centering
    \resizebox{1\linewidth}{!}{%
    \begin{tikzpicture}%
    [%
        auto,font=\small\sffamily,
        myarrow/.style={-angle 60,>=stealth',shorten >=1pt}
    ]
        % Top rectangle
        \draw [fill=white] (0,4.5) rectangle (10,5.5);
        \node at (5,5) {total size $t = 1120~bits$ (UTF-8 \emph{140 ``[A-Za-z0-9\_]'' characters)}};
        \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=2pt] (10,5.5) -- (0,5.5);
        \node at (5,6.5) {Normal Tweet};

        \draw [fill=white] (0,3) rectangle (7,4);
        \node at (3.5,3.5) {message (\msg)};
        %
        \draw [fill=white] (7.1,3) rectangle (10,4);
        \node at (8.5,3.5) {\#hashtags (\hasht)};% $\tau = t - \mu$};
        %
        \draw[dashed,thin] (0,4) -- (0,4.5);
        \draw[dashed,thin] (10,4) -- (10,4.5);

        % encrypt block
        \draw [fill=white] (4,1.5) rectangle (6,2.5);
        \node at (5,2) {Tweety};

        % Bottom rectangles ....
        % left
        \draw [fill=white] (0,0) rectangle (7,1);
        \node at (3.5,0.5) {encryption (\ctxt) and authentication tag (\auth)};
        \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=2pt] (0,0) -- (10,0);
        \node at (5,-1) {Tweety (Encrypted) Output};
        % \node at (3.5,-1) {Tweakable blockcipher Output};

        % right
        \draw [fill=white] (7.1,0) rectangle (10,1);
        \node at (8.5,0.5) {\#hashtags (\hasht)};

        \draw[myarrow,thick] (5,3) -- (5,2.5);
        \draw[myarrow,thick] (5,1.5) -- (5,1);
        \draw[myarrow,thick,angle 60-angle 60] (8.5,1) |- (6,2);
        \draw[thick] (8.5,2) -- (8.5,3);
        \node (l) at (2,2.3) {$\key$};
        \node (t) at (2,1.7) {$\tstamp$};
        \draw[myarrow,thick] (l) -- (4,2.3);
        \draw[myarrow,thick] (t) -- (4,1.7);
        %
    \end{tikzpicture}
    }
    \caption{Tweety design overview}
    \label{fig:twitteroverview}
\end{figure}
% ------------------------------------------------------------------------
\subsection{Tweety}\label{sec:tweety}

Tweety allows users to encrypt and authenticate content of the tweets while leaving (some) hashtags public. These public hashtags serve a twofold purpose: information for targeted advertisements, and to allow users to enforce selective control of tweets. \figref{fig:twitteroverview} illustrates the general design of Tweety.
%
The key principle of \tweety is inspired by tweakable blockciphers, where the public hashtags and also the time stamp of the tweet act as the tweak. Conversely, \tweety operates by parsing a $1120$-bit tweet into a message/hashtag-tuple $(\msg,\hasht)\in\binm\times\bint$, behaving then like a symmetric encryption scheme: using a secret key $\key\in\bink$, the message $\msg$ is encrypted to a ciphertext $\ctxt\in\binn$, where $\hasht$ and time stamp $\tstamp\in\bins$ function as the tweak. It additionally outputs an authentication tag $\auth\in\bina$ (absent if no authentication is needed, in which case we have $\alpha=0$). Thus, the encrypted tweet is of the form $(\ctxt,\auth,\hasht)\in\binn\times\bina\times\bint$ (the time stamp $\tstamp$ is implicit from the tweet). We assume that two tweets under the same secret key are never made with the same time stamp.

Note that we allow for a small amount of ciphertext expansion (from $\mu$ to $\nu$ bits), as long as $\mu+\tau\leq\nu+\alpha+\tau\leq 1120$. Inspired by the Unix time stamping, the size of the time stamp, $\sigma$, is considered to be between $32$ and $64$ bits. In more detail, the Unix time stamp is conventionally written in $32$ bits. This is enough until January 19, 2038, before which all systems should be migrated to $64$-bit stamps.

%
% \subsection{Specification}

More formally, we consider \tweety to be composed of three algorithms: \texttt{KeyGen}, \texttt{PTweet}, and \texttt{PRead}. \texttt{KeyGen} is a randomized algorithm that gets as input $\kappa\in\mathbb{N}$ and outputs a random key $\key \leftarrow \bink$, whereas the \texttt{PTweet} and \texttt{PRead} algorithms are defined as follows:
%
\begin{align*}
&\texttt{PTweet}\!:\\
&\quad\algorithmicrequire\ (\key, \msg, \hasht, \tstamp)\in\\
&\qquad\;\; \bink\times\binm\times\bint\times\bins\,,\\
&\quad\algorithmicensure\ (\ctxt, \auth, \hasht)\in\\
&\qquad\;\; \binn\times\bina\times\bint\,,\\
&\texttt{PRead}\!:\\
&\quad\algorithmicrequire\ (\key, \ctxt, \auth, \hasht, \tstamp)\in\\
&\qquad\;\; \bink\times\binn\times\bina\times\bint\times\bins\,,\\
&\quad\algorithmicensure\ \msg\in\binm \text{ or }\bot\,.
\end{align*}
%
\texttt{PRead} outputs the unique $\msg$ that satisfies $\texttt{PTweet}(\key,\msg,\hasht,\tstamp)=(\ctxt,\auth,\hasht)$, or it returns $\bot$ if no such message exists. The output of $\hasht$ by \texttt{PTweet} will sometimes be left out and considered to be implicit.

\subsection{Threat Model}
%We consider an adversary to be any entity attempting to passively access the shared information by monitoring the communication channel, with no incentive to tamper with the content. Such adversaries should not learn the content shared, beyond that revealed in the hashtags. Otherwise the adversary is considered to break both confidentiality and privacy.
We consider an adversary $\A$ to be any entity attempting to passively access the shared information by monitoring the communication channel, with no incentive to tamper with the content. However, it is allowed to generate encrypted tweets under a secret and unknown key itself. In this case, $\A$ should not learn the encrypted content, beyond that revealed in the hashtags.

More technically, we consider adversary $\A$ that has query access to the encryption functionality $\mathtt{PTweet}$ under a secret key $\key$, and it tries to find irregularities among the queries, i.e., some relation that is not likely to hold for a random function. Here, $\A$ is required to be time stamp respecting, meaning that every query must be made under a different time stamp (see also \secref{sec:concl}).\footnote{More formally, we assume that two tweets are never posted under the same key at the exact same time. This is reasonable if the key is used by a relatively small set of users.} For a function $F$, let $\func(F)$ be the set of all functions $f$ with the same interface as $F$. The advantage of an adversary $\A$ in breaking the secrecy of \tweety is defined as follows:
%
\begin{align*}
    &\advcpa{\tweety}(\A) = \\
        &\;\;\;\left|
        \begin{array}{l}
        \Pr\left(\key\getR\mathtt{KeyGen}(\kappa)\;:\;\A^{\mathtt{PTweet}_{\key}} = 1 \right)\:-\\[6pt]\qquad\qquad\!\Pr\left(\$\getR\func(\mathtt{PTweet}_{\key})\;:\;\A^{\$} = 1\right)
        \end{array} \right|\,.
\end{align*}
%
We define by $\advcpa{\tweety}(Q,T)$ the maximum advantage over all adversaries that make at most $Q$ encryption queries and operate in time $T$.

For the authenticity of $\tweety$, we consider $\A$ to have access to the encryption functionality $\mathtt{PTweet}$ under a secret key $\key$, and we say that $\A$ \emph{forges} an encrypted tweet if it manages to output a tuple $(\ctxt, \auth, \hasht, \tstamp)\in\binn\times\bina\times\bint\times\bins$ such that $\texttt{PRead}(\key,\ctxt, \auth, \hasht, \tstamp)=\msg\neq\bot$ and $(\msg,\hasht,\tstamp)$ was never queried to $\mathtt{PTweet}$ before. Note that the forgery attempt may be made under a time stamp $\tstamp$ that has appeared before. The advantage of $\A$ in breaking the authenticity of \tweety is defined as follows:
%
\begin{align*}
    &\advauth{\tweety}(\A) = \\
        &\;\;\;\Pr\left(\key\getR\mathtt{KeyGen}(\kappa)\;:\;\A^{\mathtt{PTweet}_{\key}} \text{ forges} \right)\,.
\end{align*}
%
We define by $\advauth{\tweety}(Q,R,T)$ the maximum advantage over all adversaries that make at most $Q$ encryption queries, $R$ forgery attempts, and operate in time $T$.
%

% \subsection{Realization}
% A way to realize \tweety is by using a standard encryption mode of operation, such as AES-CTR or AES-CBC. However, this construction only achieves $64$-bit security (cf.~Bellare \etal~\cite{BDJR97}) and needs at least $8$ AES evaluations (not taking into account the handling of the tweak). Because tweets are of a relatively short (but larger than $128$ bits) length, better options are to use dedicated functions, as these may be more efficient and (as becomes clear later) achieve a much higher level of security. We identify three basic approaches in realizing \tweety, each discussed in the following three sections.
% \secref{sec:tweetytbc}, \secref{sec:tweetylrw}, and \secref{sec:tweetySponge}.

% \section{Approach 1: Large Tweakable blockcipher}
\section{Tweety: Basic Construction}\label{sec:tweetytbc}
The first approach is to apply a large tweakable blockcipher. A tweakable blockcipher $\tE:\calK\times\calT\times\calM\to\calM$ takes as input a key $k\in\calK$, a tweak $t\in\calT$, and a message $m\in\calM$, and outputs a ciphertext $c\in\calM$. It is a permutation for every choice of $(k,t)$.

For \tweety, we suggest using \emph{Threefish}, a tweakable blockcipher by Ferguson et al.~used for the Skein hash function family~\cite{FLS+11}. Threefish supports block sizes of 256, 512, and 1024 bits. The key size equals the block size, and the tweak size is $128$ bits. We focus on the largest variant, Threefish-1024, which for readability we simply denote \fish:
%
\begin{align*}
&\fish\!:\\
&\quad\algorithmicrequire\ (k,t,m)\in\bin{1024}\times\bin{128}\times\bin{1024}\,,\\
&\quad\algorithmicensure\ c\in\bin{1024}\,.
\end{align*}
%
\fish can be used to encrypt tweets directly, a construction which we dub $\tweety^\fish$. It operates on keys of size $\kappa=1024$ bits, messages can be of arbitrary length but of size at most $\mu=1023-\alpha$, and the sizes of the time stamp and hashtag should satisfy $\sigma+\tau\leq 127$. The ciphertexts are of size \emph{exactly} $\nu=1024-\alpha$ bits, where $\alpha$ is the size of the authentication tag. The latter is required to make decryption possible. Note that if $\sigma=32$, these parameters satisfy $\mu+\tau\leq\nu+\alpha+\tau\leq 1120$. At a high level, the encryption consists of putting $m=\pad_{1024}(\msg)$ and $t=\pad_{128}(\tstamp\|\hasht)$, and the ciphertext and authentication tag are derived as $\ctxt\|\auth=c$. Formally, the encryption and decryption of $\tweety^\fish$ are defined as in Algorithms~1 and 2.

%\noindent\begin{minipage}[t]{\linewidth}
%\vspace{0pt}
\begin{algorithm}[H]
\caption*{\textbf{Algorithm 1} $\mathtt{PTweet}^{\fish}$}%\label{algo:PTweet}
    \begin{algorithmic}[1]
        \Require{$(\key,\msg,\hasht,\tstamp)\in\newline\bink\times\binm\times\bint\times\bins$}
        \Ensure{$(\ctxt,\auth)\in\bin{\nu}\times\bina$}
        \State{$c \gets \fish(\key,\pad_{128}(\tstamp\|\hasht),\pad_{1024}(\msg))$}
        \State{\Return $(\lceil c\rceil_\nu,\lfloor c\rfloor_{\alpha})$}
    \end{algorithmic}
\end{algorithm}
\vspace{-20pt}
\begin{algorithm}[H]
\caption*{\textbf{Algorithm 2} $\mathtt{PRead}^{\fish}$}%\label{algo:PRead}
    \begin{algorithmic}[1]
        \Require{$(\key,\ctxt,\auth,\hasht,\tstamp)\in\newline\bink\times\bin{\nu}\times\bina\times\bint\times\bins$}
        \Ensure{$\msg\in\binm$ or $\bot$}
        \State{$m\gets \fish^{-1}(\key,\pad_{128}(\tstamp\|\hasht),\ctxt\|\auth)$}
        \State{$\msg\gets \unpad_{\mu+1}(\lceil m \rceil_{\mu+1})$}
        \State{\Return $ \lfloor m\rfloor_\alpha=0\;?\;\msg : \bot$}
    \end{algorithmic}
\end{algorithm}
%\end{minipage}


\desc{Security.}
In this section we formally derive the security under the assumption that \fish is a secure tweakable blockcipher, so that the security of $\tweety^{\fish}$ directly follows.
%
The security of a tweakable blockcipher $\tE:\calK\times\calT\times\calM\to\calM$ is captured by an adversary $\A$ that has adaptive two-sided oracle access to either $\tE_k$ for some secret key $k\getR\calK$, or ideal tweakable permutation $\tpi$ with tweak space $\calT$ and message space $\calM$, and tries to distinguish both worlds. Denote by $\tperm(\calT,\calM)$ the set of tweakable permutations. We define the strong PRP security of $\tE$ as
%
\begin{align*}
    &\advsprp{\tE}(\A) = \\
        &\;\;\;\left|
        \begin{array}{l}
        \Pr\left(k\getR\calK\;:\;\A^{\tE_k^{\pm}} = 1 \right)\:-\\[6pt]\qquad\qquad\!\Pr\left(\tpi\getR\tperm(\calT,\calM)\;:\;\A^{\tpi^{\pm}} = 1\right)
        \end{array} \right|\,.
\end{align*}
%
By $\advsprp{\tE}(Q,T)$ we denote the maximum security advantage of any adversary $\A$ that makes $Q$ queries and runs in time $T$.

\begin{theorem}\label{thm:tbc}
    Let $n=1024$ be the state size of \fish. We have
    \begin{align*}
    \advcpa{\tweety^{\fish}}(Q,T) &\leq \advsprp{\fish}(Q,T')\,,\\
    \advauth{\tweety^{\fish}}(Q,R,T) &\leq \advsprp{\fish}(Q\!+\!R,T')\!+\!\frac{R2^{n-\alpha}}{2^n-1}\,,
    \end{align*}
    where $T'\approx T$.
\end{theorem}

\begin{proof}
    We start with the secrecy of $\tweety^{\fish}$. Let $\A$ be an adversary that makes $Q$ queries and runs in time $T$. It has access to either $\mathtt{PTweet}_\key$ or $\$$. Note that $Q$ evaluations of $\tweety^{\fish}$ induce $Q$ evaluations of $\fish$. We replace $\fish$ by an ideal tweakable permutation $\tpi\getR\tperm(\bin{128},\bin{1024})$. Now, any query $\mathtt{PTweet}^{\tpi}(\key, \msg, \hasht, \tstamp)$ is responded with
    
    \begin{align*}
    \ctxt\|\auth = \tpi(\key,\pad_{128}(\tstamp\|\hasht),\pad_{1024}(\msg))\,.
    \end{align*}

    \noindent
    As $\A$ is required to be time stamp respecting, every query is made under a new time stamp, which means that every query initiates a new instance of $\tpi$, and $\ctxt\|\auth$ is a random $1024$-bit value. This means that $\mathtt{PTweet}^{\tpi}_\key$ is perfectly indistinguishable from $\$$.

    For authenticity, the first part of the proof is identical: we replace $\fish$ by ideal tweakable permutation $\tpi\getR\tperm(\bin{128},\bin{1024})$, where now the $Q+R$ evaluations of $\tweety^{\fish}$ induce $Q+R$ evaluations of $\fish$. It remains to consider the probability to forge an authentication tag for $\tweety^{\tpi}$. By \cite{DBLP:journals/iacr/BellareGM04}, it suffices to consider any attempt and sum over all $R$ attempts. Consider any forgery attempt $(\ctxt,\auth,\hasht,\tstamp)$. Note that, as $\A$ is required to be time stamp respecting, there has been at most one encryption query under hashtag $\hasht$ and time stamp $\tstamp$. Therefore, the value
    
    \begin{align*}
    m = \tpi^{-1}(\key,\pad_{128}(\tstamp\|\hasht),\ctxt\|\auth)
    \end{align*}
    
    \noindent
    is randomly drawn from a set of size at least $2^n-1$, and satisfies $\lfloor m\rfloor_\alpha=0$ with probability at most $2^{n-\alpha}/(2^n-1)$.
    % This completes the proof.
    % \hfill \qed
\end{proof}
We briefly remark that the construction is even secure under \emph{release of unverified plaintext}, where $\msg$ is disclosed before tag verification is done \cite{asiacrypt/AndreevaBLMMY14}.

% \section{Approach 2: Large Tweakable blockcipher with Expanded Tweak Space}
\section{Tweety: Expanded Tweak Space}\label{sec:tweetylrw}

The Tweety basic construction presents a rather small tweak space, and the usage of a larger time stamp results in a limitation on the size of the hashtag. A way to resolve this is to employ a random oracle that maps the time stamp and (larger) hashtag to a string of size $128$ bits, but this would significantly degrade the security of the construction to $64$ bits. Another way to enlarge the tweak space without adjusting the cipher itself is by using it in a tweakable mode of operation.
%some Ian-stuff.

Liskov \etal~\cite{LRW02} introduced two tweakable modes of operation: while these constructions are originally designed to add a tweak input to a blockcipher, they can equally well be applied to tweakable blockciphers themselves to enlarge the tweak space. We will consider one of these constructions, which makes two evaluations of the underlying cipher:\footnote{The other construction is less relevant as it requires an additional key and as it needs a universal hash function with a $1024$-bit range (or smaller, in which case the security of the construction degrades).}
%
\begin{align*}
&\LRW[\fish]\!:\\
&\quad\algorithmicrequire\ (k,t,t',m)\in\bin{1024}\:\times\\
&\qquad\qquad\qquad \bin{1024}\times\bin{128}\times\bin{1024}\,,\\
&\quad\algorithmicensure\ \fish(k,t',\fish(k,t',m)\xor t)\in\bin{1024}\,.
\end{align*}
%
This construction can be used to realize $\tweety^{\LRW[\fish]}$ as illustrated in \figref{fig:LRW} and described as in Algorithms~3 and 4. The conditions on the sizes of the inputs and outputs carry over from Section~\ref{sec:tweetytbc}, with the difference that the hashtags should now be of size at most $\tau\leq 1023$, a condition clearly satisfied as $1120\geq \nu+\alpha+\tau=1024+\tau$.
%if time stamp is 32 bits then $\LRW[\fish]$ is not at all needed.

% ----------------------------------------------------------------
\begin{figure}[t]
    \centering
    \resizebox{1\linewidth}{!}{%
    \begin{tikzpicture}
        [%
            auto,thick,%
            block/.style={draw,thick,rectangle,minimum height=5em,minimum width=5em},
            xor/.style={draw,circle,append after command={[shorten >=\pgflinewidth, shorten <=\pgflinewidth,] (\tikzlastnode.north) edge (\tikzlastnode.south)(\tikzlastnode.east) edge (\tikzlastnode.west)}},
            line/.style={draw, -latex',shorten <=1bp,shorten >=1bp,-angle 60}
        ]
        % box 1
        \node[block,anchor=center] (b1) at (0,0) {3fish};
        % box 2
        \node[block,anchor=center] (b2) at (4,0) {3fish};
        % oplus sign
        \node[xor,scale=1.2] (op) at (2,0) {};

        % labels
        \begin{scope}[node distance=2cm]
            \node[above of=b1] (key1) {$key$};
            \node[above of=b2] (key2) {$key$};
            \node[left of=b1]  (message) {\msg};
            \node[right of=b2] (cipher) {$\ctxt\|\auth$};
            \node[below of=b1] (tp1) {$ts$};
            \node[below of=b2] (tp2) {$ts$};
        \end{scope}
        \node[above of=op,node distance=2cm] (t) {$ht$};
        \path[line] (b1) edge (op)
                    (op) edge (b2)
                    (message) edge (b1)
                    (b2) edge (cipher)
                    (key1) edge (b1)
                    (key2) edge (b2)
                    (tp1) edge (b1)
                    (tp2) edge (b2)
                    (t) edge (op);

    \end{tikzpicture}
    }
    \caption{\tweety based on $\LRW[\fish]$. Padding of data is excluded from the figure}\label{fig:LRW}
\end{figure}
% ----------------------------------------------------------------

%\noindent\begin{minipage}[t]{\linewidth}
%\vspace{0pt}
\begin{algorithm}[H]
\caption*{\textbf{Algorithm 3} $\mathtt{PTweet}^{\LRW[\fish]}$}%\label{algo:PTweet}
    \begin{algorithmic}[1]
        \Require{$(\key,\msg,\hasht,\tstamp)\in\newline\bink\times\binm\times\bint\times\bins$}
        \Ensure{$(\ctxt,\auth)\in\bin{\nu}\times\bina$}
        \State{$c \gets \LRW[\fish](\key,\newline
            \phantom{.}\quad\qquad\qquad\pad_{1024}(\hasht),\pad_{128}(\tstamp),\pad_{1024}(\msg))$}
        \State{\Return $(\lceil c\rceil_\nu,\lfloor c\rfloor_{\alpha})$}
    \end{algorithmic}
\end{algorithm}
\vspace{-20pt}
\begin{algorithm}[H]
\caption*{\textbf{Algorithm 4} $\mathtt{PRead}^{\LRW[\fish]}$}%\label{algo:PRead}
    \begin{algorithmic}[1]
        \Require{$(\key,\ctxt,\auth,\hasht,\tstamp)\in\newline\bink\times\bin{\nu}\times\bina\times\bint\times\bins$}
        \Ensure{$\msg\in\binm$ or $\bot$}
        \State{$m\gets \LRW[\fish]^{-1}(\key,\newline
            \phantom{.}\quad\qquad\qquad\pad_{1024}(\hasht),\pad_{128}(\tstamp),\ctxt\|\auth)$}
        \State{$\msg\gets \unpad_{\mu+1}(\lceil m \rceil_{\mu+1})$}
        \State{\Return $\lfloor m\rfloor_\alpha=0\;?\;\msg : \bot$}
    \end{algorithmic}
\end{algorithm}
%\end{minipage}

\medskip
\desc{Security.}
The security of $\tweety^{\LRW[\fish]}$ in fact follows from \thref{thm:tbc} and a result from \cite{LRW02}.

\begin{theorem}\label{thm:lrw}
    Let $n=1024$ be the state size of \fish. We have
    \begin{align*}
    &\advcpa{\tweety^{\LRW[\fish]}}(Q,T) \leq \Theta\!\left(\!\frac{Q^2}{2^n}\!\right)\! + \advsprp{\fish}(2Q,T')\,,\\
    &\advauth{\tweety^{\LRW[\fish]}}(Q,R,T) \leq\\
    &\qquad\Theta\!\left(\!\frac{(Q\!+\!R)^2}{2^n}\!\right)\! + \advsprp{\fish}(2(Q\!+\!R),T') + \frac{R2^{n-\alpha}}{2^n-1}\,,
    \end{align*}
    where $T'\approx T$.
\end{theorem}

\begin{proof}
    Note that the derivation in \thref{thm:tbc} not only applies to \fish, but to any tweakable blockcipher. Applied to $\LRW[\fish]$ we get
    \begin{align*}
    &\advcpa{\tweety^{\LRW[\fish]}}(Q,T) \leq \advsprp{\LRW[\fish]}(Q,T'')\,,\\
    &\advauth{\tweety^{\LRW[\fish]}}(Q,R,T) \leq\\
    &\qquad\qquad\qquad\advsprp{\LRW[\fish]}(Q\!+\!R,T'') + \frac{R2^{n-\alpha}}{2^n-1}\,,
    \end{align*}
    where $T''\approx T$. In \cite{LRW02} it is proven that
    \begin{align*}
        \advsprp{\LRW[\fish]}(Q,T'') \leq \Theta\!\left(\!\frac{Q^2}{2^n}\!\right)\! + \advsprp{\fish}(2Q,T')\,,
    \end{align*}
    where $T'\approx T''$.
    % This completes the proof. \qed
\end{proof}

% ----------------------------------------------------------------
\section{Tweety: Sponge Construction}\label{sec:tweetySponge}

The Sponge functions were originally introduced by Bertoni \etal~\cite{BDPA07} for cryptographic hashing, but can also be used in a broad spectrum of keyed applications, including message authentication~\cite{BDPA11-SKEW,ADMV15-FSE,crypto/GaziPT15} and stream encryption~\cite{BDPA11-SAC,asiacrypt/MenninkRV15}. They are also particularly useful for tweet encryption given the tweet size and the flexibility in the state size of the Sponge. In more detail, we suggest the following function realization, which resembles ideas of the full-state duplex mode \cite{asiacrypt/MenninkRV15}, transformed to the tweakable setting, as depicted in \figref{fig:Sponge}. We stress, however, that the keyed Sponges are merely stream-based encryption, and a unique time stamp is required for every encryption.


% ----------------------------------------------------------------
\begin{figure}[t]
    \centering
    \resizebox{1\linewidth}{!}{%
    \begin{tikzpicture}
        [%
            auto,thick,%
            block/.style={draw,thick,rectangle,minimum height=5em,minimum width=5em,font=\Large},
            xor/.style={draw,circle,append after command={[shorten >=\pgflinewidth, shorten <=\pgflinewidth,] (\tikzlastnode.north) edge (\tikzlastnode.south)(\tikzlastnode.east) edge (\tikzlastnode.west)}},
            line/.style={draw, shorten <=1bp,shorten >=1bp,-angle 60}
        ]
        % box 1
        \node[block,anchor=center] (b1) at (0,0) {$\pi$};
        \begin{scope}[node distance=0.7cm]
            \node (b_nw1) at (-0.7,0.5) {};
            \node (b_sw1) at (-0.7,-0.5) {};
            \node (b_ne1) at (0.7,0.5) {};
            \node (b_se1) at (0.7,-0.5) {};
        \end{scope}
        % box 2
        \node[block,anchor=center] (b2) at (5,0) {$\pi$};
        \begin{scope}[node distance=0.7cm]
            \node (b_nw2) at (4.3,0.5) {};
            \node (b_sw2) at (4.3,-0.5){};
            \node (b_ne2) at (5.7,0.5) {};
            \node (b_se2) at (5.7,-0.5) {};
        \end{scope}
        % box 3
        \node[block,anchor=center] (b3) at (10,0) {$\pi$};
        \begin{scope}[node distance=0.7cm]
            \node (b_nw3) at (9.3,0.5) {};
            \node (b_sw3) at (9.3,-0.5){};
            \node (b_ne3) at (10.7,0.5) {};
            \node (b_se3) at (10.7,-0.5) {};
        \end{scope}

        % oplus sign
        \node[xor,scale=1.2] (op1) at (2,0.5) {};
        \node[xor,scale=1.2] (op2) at (7,0.5) {};
        \node[right of=op1,node distance=1.2cm] (dot1) {\LARGE$\cdot$};
        \node[right of=op2,node distance=1.2cm] (dot2) {\LARGE$\cdot$};
        \node[right of=b_ne3,node distance=1.2cm] (dot3) {\LARGE$\cdot$};
        %\node at (12.5,0) {$\ldots$};

        % % labels
        \begin{scope}[node distance=2cm]
            \node[left of=b_nw1] (tsht) {$ts \parallel ht$};
            \node[left of=b_sw1] (key1) {$key$};
        \end{scope}
        \begin{scope}[node distance=1.4cm]
            \node[above of=op1]  (ms1) {$\msg_1$};
            \node[above of=op2] (ms2) {$\msg_2$};
            \node[above of=dot1] (ct0) {$\ctxt_1$};
            \node[above of=dot2] (ct1) {$\ctxt_2$};
            \node[above of=dot3] (ct2) {$\auth$};
        \end{scope}
        \node[below of=dot1,node distance=2cm] {$\ctxt = \ctxt_1 \parallel \ctxt_2$};

        \path[line] (tsht) edge (b_nw1.west)
                    (key1) edge (b_sw1)
                    (b_ne1) edge (op1)
                    (b_se1) edge (b_sw2)
                    (op1) edge (b_nw2)
                    (b_ne2) edge (op2)
                    (b_se2) edge (b_sw3)
                    (op2) edge (b_nw3)
                    (ms1) edge (op1)
                    (ms2) edge (op2);

        \draw[-angle 60] (dot1.center) -- (ct0);
        \draw[-angle 60] (dot2.center) -- (ct1);
        \draw[-angle 60] (dot3.center) -- (ct2);
        \draw (b_ne3) -- (12.5,0.5);
        \draw (b_se2) -- (8.5,-0.5);
        \draw (b_se3) -- (12.5,-0.5);

    \end{tikzpicture}
    }
    \caption{\tweety based on a Sponge. Padding of data is excluded from the figure}\label{fig:Sponge}
\end{figure}
% ----------------------------------------------------------------

The realization of $\tweety^{\pi,\ell,n}$ is indexed by a permutation $\pi$ of width $b$ and two parameters $\ell$ and $n\leq b$ which specify the way it parses the message blocks: it considers at most $\ell$ message blocks of size $n$ bits. It operates on keys of size $\kappa\leq b-n$ bits, messages and ciphertexts can be of arbitrary length at most $\mu=\ell\cdot n-1$ (note that the scheme does not use ciphertext expansion), and the sizes of the time stamp and hashtag should satisfy $\sigma+\tau\leq n-1$. The size of the authentication tag is $\alpha\leq n$ (this bound is merely for simplicity, the scheme easily generalizes to $\alpha>n$). We additionally still require $\mu+\alpha+\tau\leq 1120$. The formal encryption and decryption functionalities are given in Algorithms~5 and 6.

%\noindent\begin{minipage}[t]{\linewidth}
%\vspace{0pt}
\begin{algorithm}[H]
\caption*{\textbf{Algorithm 5} $\mathtt{PTweet}^{\pi,\ell,n}$}%\label{algo:PTweet}
    \begin{algorithmic}[1]
        \Require{$(\key,\msg,\hasht,\tstamp)\in\newline\bink\times\binm\times\bint\times\bins$}
        \Ensure{$(\ctxt,\auth)\in\binm\times\bina$}
        \State{$\ell'\gets\lceil (|\msg|+1)/n\rceil$}
        \State{$\msg_1\parallel\cdots\parallel \msg_{\ell'}\xleftarrow{n\text{-}\mathrm{blocks}} \pad_{\ell'\cdot n}(\msg)$}
        \State{$s_0\gets \pad_n(\tstamp\|\hasht)\parallel 0^{b-n-|\key|}\parallel \key$}
        \For{$i=1,\ldots,\ell'$}
            \State{$s_i\gets \pi(s_{i-1})$}
            \State{$s_i\gets s_i \xor \big(\msg_i\parallel 0^*\big)$}
            \State{$\ctxt_i\gets \lceil s_i\rceil_n$}
        \EndFor
        \State{$s_{\ell'+1}\gets \pi(s_{\ell'})$}
        \State{\Return $(\lceil \ctxt_1\parallel\cdots\parallel \ctxt_{\ell'} \rceil_{|\msg|},\lceil s_{\ell'+1}\rceil_{\alpha})$}
    \end{algorithmic}
\end{algorithm}
\vspace{-20pt}
\begin{algorithm}[H]
\caption*{\textbf{Algorithm 6} $\mathtt{PRead}^{\pi,\ell,n}$}%\label{algo:PRead}
    \begin{algorithmic}[1]
        \Require{$(\key,\ctxt,\auth,\hasht,\tstamp)\in\newline\bink\times\binm\times\bina\times\bint\times\bins$}
        \Ensure{$\msg\in\binm$ or $\bot$}
        \State{$\ell'\gets\lceil (|\ctxt|+1)/n\rceil$}
        \State{$\ctxt_1\parallel\cdots\parallel \ctxt_{\ell'}\xleftarrow{n\text{-}\mathrm{blocks}} \pad_{\ell'\cdot n}(\ctxt)$}
        \State{$s_0\gets \pad_n(\tstamp\|\hasht)\parallel 0^{b-n-|\key|}\parallel \key$}
        \For{$i=1,\ldots,\ell'-1$}
            \State{$s_i\gets \pi(s_{i-1})$}
            \State{$\msg_i\gets \lceil s_i\rceil_n \xor \ctxt_i$}
            \If{$i<\ell'$}
                \State{$s_i\gets \ctxt_i \parallel \lfloor s_i\rfloor_{b-n}$}
            \Else
                \State{$s_i\gets \lceil \ctxt_i \rceil_{|\ctxt|\bmod n} \parallel \lfloor s_i\rfloor_{b-(|\ctxt|\bmod n)}$}
            \EndIf
        \EndFor
        \State{$\msg\gets \lceil \msg_1\parallel\cdots\parallel \msg_{\ell'} \rceil_{|\ctxt|}$}
        \State{$s_{\ell'+1}\gets \pi(s_{\ell'})$}
        \State{\Return $\lceil s_{\ell'+1}\rceil_{\alpha}=\auth\;?\;\msg : \bot$}
    \end{algorithmic}
\end{algorithm}
%\end{minipage}

%\medskip
\desc{Security.}
$\tweety^{\pi,\ell,n}$ is in fact a full-state duplex construction~\cite{asiacrypt/MenninkRV15}, but for the sake of presentation, it is easier to explain the security of the construction in terms of the Inner-Keyed Sponge (\IKS) of Andreeva \etal~\cite{ADMV15-FSE}. This construction gets as input a key $k$, an arbitrarily sized message $m$, and a natural number $\rho$, and it outputs a digest $z$ of size $\rho$:
\begin{align*}
\IKS^\pi(k,m,\rho) = z\in\bin{\rho}\,.
\end{align*}
It is defined as the classical Sponge with an outer part of size $n$ and an inner part of size $b-n$, and with the capacity part being initialized using the key. We consider a specific case of \IKS where $\rho\leq n$, which means that the squeezing part of the Sponge takes exactly one round.

The security of variable-input-length $\IKS:\calK\times\bin{\ast}\to\bin{n}$ based on a permutation $\pi$ is slightly different from the CPA security of \secref{sec:tweety}; it differs in two aspects: first, $\IKS$ is variable length, so it is compared with a random oracle $\RO:\bin{\ast}\to\bin{n}$, and second, it is based on an underlying idealized permutation $\pi$ and the adversary also has two-sided oracle access to $\pi$. Denote by $\perm(\bin{b})$ the set of $b$-bit permutations. Abusing notation, we refer to the security of \IKS against an adversary that has access to either $(\IKS,\pi^{\pm})$ or $(\RO,\pi^{\pm})$, where $k\getR\calK$, $\pi\getR\perm(\bin{b})$, and $\RO$ is a random oracle, by
$\advcpa{\IKS}(\A)$. We define by $\advcpa{\IKS}(Q,S)$ the maximum advantage over all adversaries with total complexity $Q$, and that make at most $S$ primitive queries to $\pi^\pm$. Here, the total complexity $Q$ counts the number of \emph{fresh calls} to $\pi$ if $\A$ were conversing with $\IKS$.

Note that if no authentication is needed, then $\mathtt{PTweet}^{\pi,\ell,n}$ and $\mathtt{PRead}^{\pi,\ell,n}$ do not require the computation of $s_{\ell'+1}\gets \pi(s_{\ell'})$ at the end, which saves a permutation call. Related to this, we define $\ell_\alpha$ as follows.
\begin{align*}
\ell_\alpha =
    \begin{cases}
    \ell\,, \text{ if }\alpha=0\,,\\
    \ell+1\,, \text{ if }\alpha>0\,.
    \end{cases}
\end{align*}

\begin{theorem}\label{thm:Sponge}
    Assume $\pi\getR\perm(\bin{b})$ is an ideal permutation. We have
    %
    \begin{align*}
    \advcpa{\tweety^{\pi,\ell,n}}(Q,T) &\leq \frac{(\ell_aQ)^2}{2^{b-n}} + \frac{\ell_aQS}{2^\kappa}\,,\\
    \advauth{\tweety^{\pi,\ell,n}}(Q,R,T) &\leq \frac{(\ell_aQ)^2}{2^{b-n}} + \frac{\ell_aQS}{2^\kappa} + \frac{R}{2^\alpha}\,.
    \end{align*}
    %
    where $S$ is the maximal number of evaluations of $\pi$ that can be made in time $T$.
\end{theorem}

\begin{proof}
    Let $\A$ be an adversary that makes $Q$ queries and runs in time $T$. It has access to either $\mathtt{PTweet}_\key$ or $\$$. Consider any evaluation $\mathtt{PTweet}_\key$ on input of $(\msg,\hasht,\tstamp)$. If we define $k=0^{b-n-|\key|}\|\key$, then its output is as follows,
    %

    \noindent
    \scalebox{0.8}{\;\begin{minipage}{\linewidth}
    \begin{align*}
    \ctxt=&\;\IKS^\pi(k,\pad_n(\tstamp\|\hasht),n) \xor \msg_1 \parallel\\
         &\;\IKS^\pi(k,\pad_n(\tstamp\|\hasht)\| \msg_1,n) \xor \msg_2 \parallel\\
         &\;\IKS^\pi(k,\pad_n(\tstamp\|\hasht)\| \msg_1,n) \xor \msg_2 \parallel\\
         &\;\cdots\,\\
         &\;\IKS^\pi(k,\pad_n(\tstamp\|\hasht)\| \msg_1\cdots \msg_{\ell-2},n) \xor \msg_{\ell-1} \parallel\\
         &\;\lceil\IKS^\pi(k,\pad_n(\tstamp\|\hasht)\| \msg_1\cdots \msg_{\ell-1},n) \xor \msg_\ell\rceil_{|\msg|\bmod n}\,,\\
    \auth=&\;\IKS^\pi(k,\pad_n(\tstamp\|\hasht)\| \msg_1\cdots \msg_{\ell},\alpha)
    \end{align*}
    \end{minipage}}

\bigskip
\noindent
Where abusing notation, $|\msg|\bmod n\in\{1,\ldots,n\}$. In other words, any evaluation of $\mathtt{PTweet}_\key$ entails $\ell_\alpha$ evaluations of $\IKS$ (the computation of $\auth$ is omitted if $\alpha=0$). Each of these evaluations adds $1$ to the complexity (as it is simply an extension of the previous one). Thus, after $Q$ evaluations of $\mathtt{PTweet}_\key$, \IKS is evaluated with a total complexity $\ell_a Q$. We replace $\IKS$ by a random oracle $\RO$. This step costs us $\advcpa{\IKS}(\ell_a Q,S)$, where $S$ is as described in the theorem statement.

    Now, for the case of secrecy, recall that $\A$ is time stamp respecting. Consequently, all evaluations of $\RO$ are made for a different input. This is clear for the $\ell+1$ queries for a single evaluation; different evaluations of $\mathtt{PTweet}_\key$ are made under a different $\tstamp$ as the adversary is time stamp respecting. Consequently, every query to $\mathtt{PTweet}_\key$ is responded with a uniformly randomly generated $|\msg|$-bit value, and thus,
    \begin{align*}
    \advcpa{\tweety^{\pi,\ell,n}}(Q,T) \leq \advcpa{\IKS}(\ell_a Q,S)\,.
    \end{align*}
    Next, for authenticity, it suffices to only focus on the value $\auth$. Consider any forgery attempt $(\ctxt,\auth,\hasht,\tstamp)$. Let $\msg$ be the message that is derived by $\mathtt{PRead}^{\pi,\ell,n}$. As the forgery is required to be non-trivial, $\RO$ has never been queries on
    \begin{align*}
    \pad_n(\tstamp\|\hasht)\| \msg_1\cdots \msg_{\ell}
    \end{align*}
    before. Its response $\auth$ is thus a randomly generated value and the forgery is successful with probability $1/2^\alpha$. Again using \cite{DBLP:journals/iacr/BellareGM04},
    \begin{align*}
    \advauth{\tweety^{\pi,\ell,n}}(Q,R,T) \leq \advcpa{\IKS}(\ell_a Q,S) + \frac{R}{2^\alpha}\,.
    \end{align*}
    Now, in \cite{ADMV15-FSE} it is proven that\footnote{We have slightly re-interpreted the result in order to accommodate the different key length.}
    \begin{align*}
    \advcpa{\IKS}(Q',S) \leq \frac{(Q')^2}{2^{b-n}} + \frac{Q'S}{2^\kappa} \,,
    \end{align*}
    which completes the proof of both secrecy and authenticity.
    % This completes the proof.
    % \qed
\end{proof}

\medskip
\desc{Instantiation.}
For $\pi$, we suggest to use the Keccak permutation $\keccak:\bin{1600}\to\bin{1600}$, and the following specific choices of $(\ell,n)$. As the complexity of the {$\tweety^{\keccak,\ell,n}$} increases linearly in $\ell$, we suggest to use $\ell\leq 2$. If $\ell=1$ and $n=1024$, the messages can be of size at most $1024$ bits, and $\tstamp\|\hasht$ is of size at most $1023$ bits. Security up to approximately $\frac{1600-n}{2}=288$ is achieved. In contrast, taking $\ell=2$ and $n=576$ gives flexible message lengths, $\tstamp\|\hasht$ should be of size at most $575$, and $512$-bit security is achieved.

\section{Implementation}\label{sec:prototype}
%
To demonstrate the viability of our proposal, we implemented a proof-of-concept prototype Tweety-App as a Firefox extension.\footnote{Source of our implementations is freely available upon request.}
% , comprising the different Tweety approaches.
%
The current prototype is compatible with Firefox 14+, but it could be easily ported to other browsers extensions, e.g., to Chrome, as it is written in simple Javascript.
Specifically, the \texttt{PTweet} and \texttt{PRead} operations are as follows:

\begin{description}
    \item[]\texttt{PTweet:} The user selects Twitter text area, and the extension launches a dialog where the user inserts the secret message and the public hashtags. The extension encrypts using the message, the hashtag, with the server time stamp, and the key as input and publishes the result into the Twitter text area.
    \smallskip
    \item[]\texttt{PRead:} The Firefox extension parses the messages on the Twitter-feed, and, for each message transparently decrypts and replaces the result with the secret message.
\end{description}
%

\medskip
\desc{Tweety.} The cryptographic module of Tweety-App comprises the Javascript implementation of the Tweety cipher designs based on Threefish, allowing easy portability to other browser implementations, e.g., Chrome. However, in order to increase the performance the Tweety cryptographic module can also be used, interacting with Firefox through a local socket connection In particular, the different instantiations of Tweety were implemented using the available C libraries for Threefish and Keccak: Skein3Fish\footnote{\url{https://github.com/wernerd/Skein3Fish}} and KeccakCodePackage,\footnote{\url{https://github.com/gvanas/KeccakCodePackage}} respectively. 
% Therefore, the performance of Tweety-Sponge (2 permutations of Keccak-1600) takes approximately 4~$ms$, whereas Tweety-Threefish-1024 takes also about 5~$ms$. Hence
The performance of the three different instantiations comply with the values depicted in \tabref{tab:comparison}. Hence, Tweety-App demonstrates that the efficiency of the different Tweety approaches is much higher than other constructions, such as AES-CBC.

% 
For the sake of simplicity, the Tweety implementation uses a passphrase as input to a key derivation function to generate the secret key, whereas the exchange of the key is assumed to be performed using a secure and authenticated offline channel. However, the secret key distribution could be made by posting a QR code image containing the encryption of the secret key using the public key of the intended recipients.

%
In addition, while it only supports desktop browsers at the moment, Tweety-App is perfectly suitable for resource-constrained devices, such as smartphones.
This is crucial considering that a significant portion of users access Twitter via their mobile devices. Even the somewhat increased size of the key will not be a problem in these settings.

\medskip
\desc{Encoding of Messages.}
As aforementioned, Internet services like Twitter use UTF-8 to encode shared messages. Thus, the bit length of a 140 character message is not constant, as the representation of a UTF-8 encoded character can be range between 1--4 bytes.\footnote{See for example \url{unicode.org/faq/utf_bom.html}} However, if only ASCII characters are used, then UTF-8 encoding will only take one byte per character, and we get the $8\times140 = 1120$ bits that is used as a starting point of our constructions.

One problem with UTF-8 encoding is that after encryption, when we have an arbitrary sequence of bits, it is likely that it is no longer valid UTF-8 and thus we need to do some encoding for the ciphertext. In our implementation we have chosen to encode two bytes (16 bits) of the ciphertext into a single UTF-8 character and thus get more than enough space for any expansion and/or overhead that the encryption might induce. The encoding works by simply mapping the two bytes into the Unicode character table\footnote{See for example \url{http://unicode-table.com/en/}} and encoding this character as valid UTF-8.

Traditional encoding schemes for encrypted data are base64 and base56, but these schemes' overhead will not allow encrypted and encoded tweets to be represented in only single tweets as the textual output is much longer than 140 characters if we have 1120 bits (or more) of ciphertext. With our encoding, it is possible to have the ciphertext in a single tweet, although the actual binary length of our encoding can add more overhead than the traditional schemes in some cases. This is of course specific to Twitter and UTF-8 encoding and in other possible applications the encoding can be done in other ways that are most suitable to that OSN.


\begin{table*}[tb]
    \centering
    \rowcolors{3}{}{lightgray}
    \caption{Comparison of the different versions of \tweety without authentication, compared with AES-CBC. A size is ``flex'' if it can take any value up to the trivial upper bounds ($|\ctxt|+|\hasht|\leq1120$ bits and $|\tstamp|\leq64$ bits). The size of the key is omitted, as it is always possible to take a key of size at least the security bound}\label{tab:comparison}
    \scalebox{1.2}{\begin{tabular}{@{\quad\:\,}lcccccccccc@{\quad\:\,}}
        %\toprule
        &\phantom{xxx}& \multicolumn{3}{c}{Size of} &\phantom{xxx}& \multicolumn{3}{c}{Efficiency} &\phantom{xxx}& Security\\
        %
        \cmidrule{3-5}\cmidrule{7-9}\cmidrule{11-11}
        %
        && $\ctxt$ &\phantom{xx}& $\hasht\|\tstamp$ && \phantom{\:}primitive\phantom{\:}           &\phantom{xx}& c/b           && bits\\
        %
        \midrule
        %
        AES-CBC         && flex       && flex     && $8\cdot$AES       && 16.0          && 64 \\
        %
        \fish          && 1024       && $<\!128$&& $1\cdot$\fish     && 6.5           && 512 \\
        %
        $\LRW[\fish]$  && 1024       && flex     && $2\cdot$\fish     && 13            && 512 \\
        %
        $\keccak,\ell,n$&&$\leq\!\ell\!\cdot\!n$&&$<\!n$&& $\ell\cdot$\keccak&& $\ell\cdot$12.5&& $\frac{1600-n}{2}$\\
        %
        $\phantom{\keccak,}\!\:1,1024$&&$\leq\!1024$&&$<\!1024$&& $1\cdot$\keccak&& 12.5&& $288$\\
        %
        $\phantom{\keccak,}\!\:1,800$&&$\leq\!800$&&$<\!800$&& $1\cdot$\keccak&& 12.5&& $400$\\
        %
        $\phantom{\keccak,}\!\:2,576$&& flex &&$<\!576$&& $2\cdot$\keccak&& 25&& $512$\\
        %\bottomrule
    \end{tabular}
    }
\end{table*}

% ----------------------------------------------------------------
\section{Related Work}\label{sec:relatedwork}
Along with the increased popularity of OSNs several privacy concerns start to arise which have prompted a large interest within the research community. As a result, several privacy-preserving solutions have been proposed to deliver OSN content confidentiality by means of existing cryptographic mechanisms. However, there is a lack of tailored designs that take into account the space limitation and the general design of OSNs. For instance, systems like FaceCloak~\cite{cse/LuoXH09} use blockciphers under different modes of operation such as AES-CBC to protect the content. Scramble~\cite{pet/BeatoKW11} and FSEO~\cite{codaspy/BeatoICPL13} use a broadcast encryption mechanism that encrypts the content using a blockcipher under a mode of operation. It attaches a header with the public-key encryptions of the key used by the blockcipher, representing the access control list of the content. Similarly, Persona~\cite{sigcomm/BadenBSBS09} and EaSiER~\cite{asiaccs/JahidMB11} use attribute-based encryption mechanisms to protect confidentiality while allowing access control definition by attributes.

Tweetcipher~\cite{other/tweetcipher} was presented by a group of cryptographers as a compact authenticated encryption algorithm initiated through Twitter discussions. Although Tweetcipher is based on Sponge and Salsa20~\cite{estream/salsa20} constructions, it aims at delivering authentication and requires six tweets, whereas Tweety requires only one tweet with easy re-keying and public hashtags.

Moreover, other privacy-friendly architectures have been suggested to replace existing platforms. Hummingbird~\cite{sp/CristofaroSTW12} presents a variant of Twitter that provably guarantees confidentiality of tweet contents, hashtags, and follower interests. Hummingbird bases its design on private set intersection methods~\cite{asiacrypt/CristofaroKT10} to match the authorized followers to the private tweets, and uses blockcipher to protect content.

%
In general, such constructions require large entropy which may not be allowed by OSNs like Twitter. Also those constructions demand at least $8$ AES evaluations achieving only $64$-bit indistinguishability security. Aligned with the fact that general tweets are of a relatively short (but larger than $128$ bits) length, the dedicated constructions presented by the different Tweety approaches achieve higher efficiency results and a much higher level of security. This can be seen from \tabref{tab:comparison}. In addition, Tweety can be used together with the broadcast and attribute-based encryptions solutions as a tailored symmetric encryption, and with Hummingbird system for protecting tweets.



% ----------------------------------------------------------------
% \section{Conclusions}
% ----------------------------------------------------------------
\section{Discussion and Conclusions}\label{sec:concl}
This paper presented Tweety, a customized mechanism for selectively revealing parts of your tweets publicly, while keeping the majority of information secret. We described different options for realizing this and compared their efficiency. The constructions employ tweakable blockciphers and Sponge permutations achieving provable security that is greater than existing mechanisms and systems or naive constructions from normal blockciphers.

Although encryption is possible with existing general blockciphers, such as AES-128, these solutions do not provide similar level of security and efficiency as Tweety when applied to the Twitter setting. This is also demonstrated in \tabref{tab:comparison}: security of the Tweety system goes up to approximately $512$ bits, while encrypting more efficiently than, for instance, AES-CBC.\footnote{The c/b's in the table are in fact derived from the speed of the Keccak permutation, AES-CBC, and $\fish$ on an Intel Core 2 for long messages \cite{Cryptopp,FLS+11,BDPA12}. These are included in the table for comparison.}
%
Furthermore, in order to fit more information than the common 1120 bits (i.e., 140 characters using Latin UTF-8 alphabet) into single tweets, one could employ bit packing schemes. For instance, by using larger character sets, such as emoji characters and Chinese characters, one can accommodate extra information as these characters are larger than 8 bits.
%
% This requires that the overhead of the encryption and other information is embedded in the 140 characters allowed by Twitter for single tweets by encoding the overhead and cryptotext in some character set larger than the original.
%
% In Tweety, this is not necessary, if one adheres to UTF-8 and basic Latin alphabet. To accommodate other character systems and also even emoji, one could extend Tweety with some bit packing scheme.

%
% Our application does not provide key exchange between the participants and this can be seen as a limitation of our system. We assume that this key exchange can take place in whatever means the users of the system feel is best for their intentions. It can be offline or online (based on some PKI). \tweety can then be used after the key has been agreed upon and distributed to the necessary recipients.

%
Tweety is proven secure against time-stamp respecting adversaries. In the case of protection against time stamp misuse, for example by the OSN itself, the \tweety can accommodate a client generated time stamp. This would add some overhead (32 or 64 bits), but could protect against this type of attack. For the \fish constructions the security for time stamp misusing adversaries is reduced and for the \keccak construction the proof does not hold as the adversary can learn the XOR of two ciphertexts. Adding this client generated explicit time stamp would make the use of plain \fish construction harder due to the limited size of the tweak space, but the other two options would still be viable. In any case, the time stamp misusing adversary will not directly learn the plaintext or the key used in encryption even if the proof of security does not hold. In addition, there are many incentives for the platform such as Twitter to remain honest such as bad publicity.%right?

%Time stamp misuse:
%\begin{itemize}
%    \item server never learns the content
%    \item users can detect tamper
%    \item server is assumed to not actively change messages because (1. doesnâ€™t  care or not motivated to learn as fear of, for instance, â€œbad publicityâ€; 2. the message are â€œundetectableâ€ according to some indistinguishability property such as social indistinguishability)
% \end{itemize}

    %\bigskip\noindent\textsc{Acknowledgments. }This work was supported in part by the Research Council KU Leuven: GOA TENSE (GOA/11/007). Bart Mennink is a Postdoctoral Fellow of the Research Foundation -- Flanders (FWO).

% ----------------------------------------------------------------
\bibliographystyle{acm}
\bibliography{tweetybib}


\end{document}
