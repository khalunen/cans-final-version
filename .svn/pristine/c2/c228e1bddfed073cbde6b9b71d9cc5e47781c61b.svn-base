\documentclass{llncs}



%%%%%%%%%%%%%%%%%%%%%%%% General Packages %%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{pdflscape}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath,mathtools}
\usepackage{inputenc}
\usepackage{hyperref}
\usepackage{paralist}   % Required for compactum
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{threeparttable}
\usepackage[table]{xcolor}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\usepackage{enumerate}
\usepackage{xspace}
\usepackage{multirow}
\usepackage{colortbl}
\usepackage{enumitem}


% For theorems
% \newtheorem{theorem}{Theorem}

\usepackage{tikz}
\usetikzlibrary{decorations.pathreplacing}
\usetikzlibrary{arrows}
\usetikzlibrary{positioning}
%%%%%%%%%%%%%%%%%%%%%%%% Custom Macros %%%%%%%%%%%%%%%%%%%%%%%%

% References
% -------------------------------------------------------
\newcommand{\figref}[1]{{Figure}~\ref{#1}}      % Figure
\newcommand{\tabref}[1]{{Table}~\ref{#1}}       % Table
\newcommand{\secref}[1]{{Section}~\ref{#1}}     % Section
\newcommand{\appref}[1]{{Appendix}~\ref{#1}}    % Appendix
\newcommand{\defref}[1]{{Definition}~\ref{#1}}  % Definition
\newcommand{\thref}[1]{{Theorem}~\ref{#1}}      % Theorem
\newcommand{\remref}[1]{{Remark}~\ref{#1}}      % Remark
% -------------------------------------------------------

% Description
% -------------------------------------------------------
\newcommand{\desc}[1]{\vspace{0.15cm} \noindent \textbf{#1}}

% NEWFUCTION-related
% -------------------------------------------------------
\newcommand{\NAME}{\ensuremath{\mathrm{AITO}}\xspace}
\newcommand{\key}{\ensuremath{\mathit{key}}}
\newcommand{\hasht}{\ensuremath{\mathit{ht}}}
\newcommand{\tstamp}{\ensuremath{\mathit{ts}}}
\newcommand{\meta}{\ensuremath{\mathit{meta}}} %was hasht
\newcommand{\nonce}{\ensuremath{\mathit{nonce}}} %was tstamp
\newcommand{\msg}{\ensuremath{\mathit{msg}}}
\newcommand{\ctxt}{\ensuremath{\mathit{ctxt}}}
\newcommand{\auth}{\ensuremath{\mathit{auth}}}
\newcommand{\fish}{\ensuremath{\mathrm{3fish}}\xspace}
\newcommand{\LRW}{\ensuremath{\mathrm{LRW}}\xspace}
\newcommand{\LRWa}{\ensuremath{\mathrm{LRW1}}\xspace}
\newcommand{\LRWb}{\ensuremath{\mathrm{LRW2}}\xspace}
\newcommand{\TwSp}{\ensuremath{\mathrm{TwSp}}\xspace}
\newcommand{\Sp}{\ensuremath{\mathrm{Sp}}\xspace}
\newcommand{\keccak}{\ensuremath{\pi_{\mathrm{keccak}}}\xspace}
\newcommand{\IKS}{\ensuremath{\mathrm{IKS}}\xspace}

% Others
% -------------------------------------------------------
\newcommand{\etal}{et al.}
\newcommand{\xor}{\oplus}
\newcommand{\getR}{\xleftarrow{{\scriptscriptstyle\$}}}
\newcommand{\tE}{\widetilde{E}}
\newcommand{\tpi}{\widetilde{\pi}}
\newcommand{\func}{\mathsf{Func}}
\newcommand{\perm}{\mathsf{Perm}}
\newcommand{\tperm}{\widetilde{\mathsf{Perm}}}
\newcommand{\RO}{\mathcal{RO}}
\newcommand{\bin}[1]{\{0,1\}^{#1}}
\newcommand{\bink}{\bin{\kappa}}
\newcommand{\bint}{\bin{\leq\tau}}
\newcommand{\bins}{\bin{\sigma}}
\newcommand{\binm}{\bin{\leq\mu}}
\newcommand{\binn}{\bin{\leq\nu}}
\newcommand{\bina}{\bin{\alpha}}
\newcommand{\adv}[2]{\ensuremath{\mathbf{Adv}_{#2}^{\mathrm{#1}}}}
\newcommand{\advsprp}[1]{\adv{\widetilde{sprp}}{#1}}
\newcommand{\advcpa}[1]{\adv{cpa}{#1}}
\newcommand{\advauth}[1]{\adv{auth}{#1}}
\newcommand{\A}{\mathcal{A}}
\newcommand{\calK}{\mathcal{K}} %key
\newcommand{\calT}{\mathcal{T}} %cipher-tweak
\newcommand{\calM}{\mathcal{M}} %cipher-in
\newcommand{\calC}{\mathcal{C}} %cipher-out
\newcommand{\pad}{\mathsf{pad}}
\newcommand{\unpad}{\mathsf{unpad}}
\definecolor{lightgray}{gray}{0.9}
% -------------------------------------------------------


% Personal Comments
% -------------------------------------------------------
\newcommand{\filipe}[1]{{\color{red}\textsf{Filipe says:} \emph{#1}}}
\newcommand{\kimmo}[1]{{\color{blue}\textsf{Kimmo says:} \emph{#1}}}
%\newcommand{\bart}[1]{{\color{orange}\textsf{Bart says:} \emph{#1}}}
\newcommand{\bart}[1]{{\color{orange}\emph{#1}}}
% -------------------------------------------------------




\begin{document}

\title{\boldmath{\NAME}: Compact Authenticated Encryption for Private and Secret Messaging}
  % \runningtitle{\NAME: Compact Authenticated Encryption for Private and Secret Messaging}
%\author{}
%\institutions
\maketitle
\begin{abstract}
    {Compact messaging services, such as microblogging and direct messaging, provide users with easy and reliable channels for dissemination of information. %These networks play a fundamental role in quick and ubiquitous dissemination of information.
    % %
    At the same time, networks offering those services store treasure troves of information to support their business model through targeted advertisements, and have become prime targets of censorship and surveillance based on the shared content.
    Current approaches that deliver privacy in such systems use traditional encryption techniques requiring large entropy and lack flexibility to selectively provide data utility, and thus, becoming unappealing for the service providers and unsuitable to compact messaging.
    % Traditional approaches for encrypting and authenticating this content offer security, but lack flexibility to selectively reveal some information for the providers to use. This makes them unappealing for the service porviders. Furthermore, a dedicated design for compact messaging could give more security and greater efficiency.
    %
    % Add more privacy issues + motivation
    %
    We present \NAME, a novel and secure authenticated encryption scheme tailored for usage in any compact messaging service. \NAME guarantees semantic security while complying with the commonly imposed space restrictions in several services and allowing limited user defined data utility for providers. It consists of three distinct instantiations based on different primitives, namely tweakable blockciphers and Sponge functions, and offers higher levels of security than existing alternatives.
    In addition, we describe how \NAME can be efficiently applied to different deployed systems, such as OTR, Sphinx, and Twitter. Finally, we discuss an implementation of a prototype, demonstrating the improved efficiency and low overhead of our constructions.}
\end{abstract}

\section{Introduction}\label{sec:intro}
With the large growth of Internet services, modern users rely more on digital and ubiquitous communications. Services such as Online Social Networks (OSNs), microblogging, and mobile direct messaging have become prominent communication channels by providing efficient as well as reliable sharing tools for dissemination and exchange of information. At the same time, given their prominent design and current business models, providers end up centralizing and storing large amounts of information about the users and their communications, thus leading to several privacy threats. For example, it is important for the users to be able to protect the content posted on OSN as well as have some mechanism for anonymous sending and receiving of messages over otherwise public or non-anonymous OSNs.

Encrypting the content delivered over such services is one way of protection. While many messaging services offer the possibility to encrypt messages, in OSNs this is usually not the case, and in many cases the business model of the OSN requires that it can collect and analyze the posted content and other information. Thus, allowing and facilitating the sharing of encrypted content, possibly even anonymously, is against their interests. Finding a good balance between privacy of the content and (some) ability to use some user-specified information about that content would be a win-win situation for privacy and the economic viability of the majority of today's OSNs.

One important tool in modern cryptography for achieving these goals is \emph{authenticated encryption} (AE), which means that the content of a message is not only encrypted to some recipient, but also the integrity of that content is protected (and possibly the sender is also authenticated to the recipient). Many AE schemes have been introduced in the past, and the ongoing CAESAR competition~\cite{CAESAR} for the design of new AE schemes has induced renewed attention to the field.

\subsection{Existing Solutions}
The classical approach to AE design is blockcipher based, where a generic mode of operation is built on top of a blockcipher in order to process data blocks iteratively (see, for instance, \cite{DBLP:conf/ccs/RogawayBBK01,DBLP:conf/asiacrypt/Rogaway04,DBLP:conf/fse/BellareRW04,DBLP:conf/fse/KrovetzR11,DBLP:conf/asiacrypt/AndreevaBLMTY13,DBLP:conf/eurocrypt/Minematsu14,DBLP:conf/acisp/DattaN14,DBLP:conf/eurocrypt/HoangKR15}). The usage of a mode of operation of this form entails overhead, e.g. in the form of padding, and the security level is in the end dominated by what the underlying primitive offers. For instance, by plugging the AES blockcipher into the above constructions, we achieve $128$-bit security \emph{at most}, and sometimes there is a possibility for distinguishability attacks in complexity of about $2^{64}$ (cf.~Bellare \etal~\cite{BDJR97}).

A more novel approach is to build authentication on top of a public permutation. This line of research has been popularized by the SpongeWrap construction~\cite{BDPA11-SAC}, and various Sponge based CAESAR submissions follow this idea, such as \cite{DEMS14,MGH+14,BDP+14,AJN14,GMS14,ABB+14,Saa14STRIBOB}. These constructions use a permutation much larger in size than 128 bits, which in some cases allows for an increased level of security. However, all of above constructions offer 256-bit security at most~\cite{DBLP:conf/asiacrypt/JovanovicLM14}. In addition, recent advances on keyed Sponges have shown that a potentially significant speed-up is possible by compressing in full-state mode \cite{asiacrypt/MenninkRV15}.

\kimmo{The text below relates more to AES and not Sponges?? Reorder?}
In general, such constructions require large entropy which may not be allowed by OSNs like Twitter and short messaging services, with the space constraints (140 characters, about 1120~$bits$). Also those constructions demand at least $8$ AES evaluations achieving only $64$-bit indistinguishability security. Aligned with the fact that general tweets (or text messages) are of a relatively short (but larger than $128$ bits) length, the dedicated constructions presented by the different \NAME approaches achieve higher efficiency results and a much higher level of security. 

Also, sharing encrypted information breaks business model of several systems relying on the mining of the shared content to provide targeted advertisements, which could cause providers to restrict and censor the distribution of the encrypted content. In fact, it has been shown that is actually possible to keep data utility and privacy by allowing providers to access the \emph{"gist"} of information, i.e., a set limited information released that does not affect user's privacy~\cite{esorics/BilogrevicFCU14}.

% 
\subsection{Contributions and Outline}
In this paper we propose \emph{\NAME}, a novel AE scheme that is tailored for compact messages (\secref{sec:model}). Besides providing access control to the content by means of encryption, it additionally allows for authenticity, ensuring integrity of data. In particular, \NAME employs recent advances in tweakable blockciphers (Sections \ref{sec:tweetytbc} and \ref{sec:tweetylrw}) and keyed Sponge functions (\secref{sec:tweetySponge}) to achieve efficient authenticated encryption and high levels of security. We show that these constructions achieve provable security that is better than existing possibilities for this type of authenticated encryption with a tolerable cost in key size. We also give three practical use cases for \NAME in protecting privacy in OSN settings.

% These issues motivate the need to implement more reliable user-centric privacy protection mechanisms, such as end-to-end encryption. One possible solution is to encrypt all the data shared and transferred, for instance using a standard encryption modes of operation, such as AES-CTR or AES-CBC, or a secure messaging protocol, such as OTR~\cite{wpes/BorisovGB04}.
%
%\bart{I think the majority of this paragraph can be removed? Please verify and update.}
%However, those constructions have several shortcomings. For instance, sharing encrypted information breaks the business model relying on the mining of the shared content to provide targeted advertisements, which could cause providers to restrict and censor the distribution of the encrypted content. It has been shown that is possible to keep data utility and privacy by allowing providers to access limited information~\cite{esorics/BilogrevicFCU14}. Also, those general constructions do not take into account the limitations and specific properties of OSN, such as the space constraints (140 characters, about 1120~$bits$) and the use of hashtags for filtering and marking specific events, in the case of Twitter and Instagram. For instance, an adaption of the CTR or CBC mode of operation with AES-128\footnote{http://codecereal.blogspot.ch/2011/06/encrypted-tweets.html} to those properties, achieves $128$-bit security \emph{at most}, and even allows for distinguishability attacks in complexity about $2^{64}$ (cf.~Bellare \etal~\cite{BDJR97}), while requiring at least $8$ AES evaluations.

\NAME can be applied and used in many different applications, allowing security, integrity, and efficiency while enabling providers to prevail some data utility.
For instance, it can be plugged into several messaging protocols, such as OTR~\cite{wpes/BorisovGB04} by replacing the symmetric key operation allowing higher security, as well as increasing efficiency for refreshing the session keys (\secref{sec:secmsg}). Furthermore, \NAME can be used to increase the 128-bit security and efficiency of anonymized messages in a mix-network, such as Sphinx~\cite{sp/DanezisG09}. We propose that using \NAME in the Sphinx mix-network scenario instead of the original LIONESS cipher from 1996 will provide greater security and also better performance with smaller headers (\secref{sec:applmix}).
In addition, \NAME could be applied to Twitter, the widely popular microblogging service (\secref{sec:applmicro}), to enable secret messaging and access control by means of encryption, while enabling providers to keep the data utility of some information to support their business model, allowing users to selectively select the \emph{"gist"} of information shared. Consequently also helping in saving some computational resources at the recipient side of the communication as it is possible to filter messages based on the hashtags, and thus limit the number of decryption operations. For instance, one could choose not to decrypt messages with the hashtag ``\#football'' from a certain (or every) user. %\bart{The order of above text is unlogical. Either reshuffle these texts or reshuffle the subsections of Section 6} 
% In addition, it offers the flexibility to enable providers to keep the a gist of data utility of some information to support their business model.

In the final sections, we discuss our three constructions and present
% related work (\secref{sec:relatedwork}) and 
our conclusions (\secref{sec:concl}).



% This can be seen from \tabref{tab:comparison}. In addition, \NAME can be used together with the broadcast and attribute-based encryptions solutions as a tailored symmetric encryption, and with Hummingbird system for protecting tweets.



% \subsection{Use Cases}
% Most popular OSNs, such as Facebook, Google+, and Twitter, provide users with certain privacy controls over their content and with secured direct messaging. While secure messaging usually employs end-to-end encryption mechanisms~\cite{sp/UngerDBFPG015}. However, this process relies not only on the diligence of the users but also on the trustworthiness of the providers in protecting stored content from possible adversaries.  Nevertheless, providers require access to the content in order to comply with their economical model, such as targeted advertisement~\cite{NEWS/SLT:facebooksued4,HOTNEts:RiedererECKR11}, consequently exposing users to several privacy issues.
%
% Online Social Networks (OSNs), such as Facebook, Google+, and Twitter, alongside direct messaging solutions such as WhatsApp and iMessage,
% In particular, Twitter has facilitated a very rapid-fire style of information sharing helping for example grassroots democracy movements in many places over the world.
% Given their prominent role and design, OSNs end up centralizing and storing large amounts of information, exposing users to several privacy threats.
% Although most popular OSNs provide users with certain privacy controls over their content and with secured direct messaging, this process relies not only on the diligence of the users but also on the trustworthiness of the providers in protecting stored content from possible adversaries.
% corrent this sentence!
% This has lead to several reports of mass breaches on the information shared on OSNs~\cite{NEWS/FBBug15}, as is evident from the recent accounts of surveillance programs like Prism~\cite{NEWS/WP:prism13}, and the recent iCloud mega leak~\cite{NEWS/FBS:icloud14}, amplifying the privacy issues.
%


% addd examples of the problems we are solving!

% cite Whatâ€™s the Gist? Privacy-Preserving Aggregation of User Profiles

% Moreover,
% business model shit
% breaches
% efficiency
% key management
%
% These issues motivate the need to implement more reliable user-centric privacy protection mechanisms, such as end-to-end encryption. One possible solution is to encrypt all the data shared and transferred, for instance using a standard encryption modes of operation, such as AES-CTR or AES-CBC, or a secure messaging protocol, such as OTR~\cite{wpes/BorisovGB04}.
%
% However, those constructions have several shortcomings. For instance, sharing encrypted information breaks the business model relying on the mining of the shared content to provide targeted advertisements, which could cause providers to restrict and censor the distribution of the encrypted content. It has been shown that is possible to keep data utility and privacy by allowing providers to access limited information~\cite{esorics/BilogrevicFCU14}. Also, those general constructions do not take into account the limitations and specific properties of OSN, such as the space constraints (140 characters, about 1120~$bits$) and the use of hashtags for filtering and marking specific events, in the case of Twitter and Instagram. For instance, an adaption of the CTR or CBC mode of operation with AES-128\footnote{http://codecereal.blogspot.ch/2011/06/encrypted-tweets.html} to those properties, achieves $128$-bit security \emph{at most}, and even allows for distinguishability attacks in complexity about $2^{64}$ (cf.~Bellare \etal~\cite{BDJR97}), while requiring at least $8$ AES evaluations.
%
% Although direct messaging services apply similar mechanisms to protect the communication among users, these are generally inefficient and often require keys to be managed by providers.


%



\section{Model}\label{sec:model}
This section introduces the required notation, \NAME, and the respective threat model.

\subsection{Notation}
For $n\in\mathbb{N}$, $\bin{n}$ is the set of $n$-bit strings, and $\bin{\leq n}=\bigcup_{i=0}^n\bin{i}$. For two bit strings $M,N$, their concatenation is denoted by $M\|N$ and $M\xor N$ denotes their bitwise XOR. Furthermore, if $M\in\bin{\leq n-1}$, then $\pad_n(M)=M\|10^{n-1-|M|}$. For a string $N\in\bin{n}$, we define by $\unpad_n(N)$ the unique string $M\in\bin{\leq n-1}$ such that $\pad_n(M)=N$. For $m\leq n$ and $N\in\bin{n}$, we denote by $\lceil N\rceil_m$ the leftmost $m$ bits and by $\lfloor N\rfloor_{n-m}$ the rightmost $n-m$ bits of $N$, in such a way that $N=\lceil N\rceil_m\|\lfloor N\rfloor_{n-m}$.

\newcommand{\lambdamax}{\lambda_{\mathrm{max}}}

\subsection{\NAME}\label{sec:tweety}
\NAME is an authenticated encryption scheme for short data. Let $\lambdamax\in\mathbb{N}$ be an integer that specifies the maximal size of an authenticated ciphertext (for instance $\lambdamax=1024$ or $1120$). Let $\mu,\nu,\alpha,\tau,\sigma\in\mathbb{N}$ be size values that satisfy $\mu\leq\nu$ and $\nu+\alpha+\tau+\sigma\leq\lambdamax$. Here, $\mu$ will denote the size of the message, $\nu$ the size of the ciphertext, $\tau$ the size of the meta data, and $\sigma$ the size of the nonce. The value $\alpha$ determines the size of the authentication tag. If no authentication is needed, we simply have $\alpha=0$.

\NAME is composed of three algorithms: \texttt{KeyGen}, \texttt{Enc}, and \texttt{Dec}. \texttt{KeyGen} is a randomized algorithm that gets as input $\kappa\in\mathbb{N}$ and outputs a random key $\key \leftarrow \bink$, whereas the \texttt{Enc} and \texttt{Dec} algorithms are defined as follows:
%
\begin{align*}
&\texttt{Enc}\!:\\
&\quad\algorithmicrequire\ (\key, \msg, \meta, \nonce)\in\\
&\qquad\;\; \bink\times\binm\times\bint\times\bins\,,\\
&\quad\algorithmicensure\ (\ctxt, \auth)\in\\
&\qquad\;\; \binn\times\bina\,,\\
&\texttt{Dec}\!:\\
&\quad\algorithmicrequire\ (\key, \ctxt, \auth, \meta, \nonce)\in\\
&\qquad\;\; \bink\times\binn\times\bina\times\bint\times\bins\,,\\
&\quad\algorithmicensure\ \msg\in\binm \text{ or }\bot\,.
\end{align*}
%
\texttt{Dec} outputs the unique $\msg$ that satisfies $\texttt{Enc}(\key,\msg,\meta,\nonce)=(\ctxt,\auth)$, or it returns $\bot$ if no such message exists. \texttt{Enc} implicitly also outputs $\meta$ and $\nonce$. Note that we allow for a small amount of ciphertext expansion (from $\mu$ to $\nu$ bits), as long as the encrypted ciphertext $(\ctxt,\auth,\meta,\nonce)$ is of size at most $\lambdamax$.

Various approaches of authenticated encryption schemes exist; see for instance the CAESAR competition~\cite{CAESAR} for the design of a new authenticated encryption scheme. These schemes are often generic modes of operation that process data blocks iteratively. \NAME, however, is designed for small data, and orthogonal design approaches turn out to be more suitable. Particularly, the key principle of the design of \NAME is inspired by tweakable blockciphers, where the meta data and nonce function as the tweak. Nevertheless, a similar threat model applies, and we discuss it next.

\subsection{Threat Model}
%We consider an adversary to be any entity attempting to passively access the shared information by monitoring the communication channel, with no incentive to tamper with the content. Such adversaries should not learn the content shared, beyond that revealed in the meta data. Otherwise the adversary is considered to break both confidentiality and privacy.
We consider an adversary $\A$ to be any entity attempting to passively access the shared information by monitoring the communication channel, with no incentive to tamper with the content. However, it is allowed to generate encryptions under a secret and unknown key itself. In this case, $\A$ should not learn the encrypted content, beyond that revealed in the meta data.

More technically, adversary $\A$ has query access to the encryption functionality $\mathtt{Enc}$ under a secret key $\key$, and it tries to find irregularities among the queries, i.e., some relation that is not likely to hold for a random function. Here, $\A$ is required to be nonce respecting, meaning that every query must be made under a different nonce (see also \secref{sec:concl}). For a function $F$, let $\func(F)$ be the set of all functions $f$ with the same interface as $F$. The advantage of an adversary $\A$ in breaking the secrecy of \NAME is defined as follows:
%
\begin{align*}
    &\advcpa{\NAME}(\A) = \\
        &\;\;\;\left|
        \begin{array}{l}
        \Pr\left(\key\getR\mathtt{KeyGen}(\kappa)\;:\;\A^{\mathtt{Enc}_{\key}} = 1 \right)\:-\\[6pt]\quad\qquad\qquad\!\Pr\left(\$\getR\func(\mathtt{Enc}_{\key})\;:\;\A^{\$} = 1\right)
        \end{array} \right|\,.
\end{align*}
%
We define by $\advcpa{\NAME}(Q,T)$ the maximum advantage over all adversaries that make at most $Q$ encryption queries and operate in time $T$.

For the authenticity of $\NAME$, we consider $\A$ to have access to the encryption functionality $\mathtt{Enc}$ under a secret key $\key$, and we say that $\A$ \emph{forges} an authentication tag if it manages to output a tuple $(\ctxt, \auth, \meta, \nonce)\in\binn\times\bina\times\bint\times\bins$ such that $\texttt{Dec}(\key,\ctxt, \auth, \meta, \nonce)=\msg\neq\bot$ and $(\msg,\meta,\nonce)$ was never queried to $\mathtt{Enc}$ before. Note that the forgery attempt may be made under a nonce $\nonce$ that has appeared before. The advantage of $\A$ in breaking the authenticity of \NAME is defined as follows:
%
\begin{align*}
    &\advauth{\NAME}(\A) = \\
        &\;\;\;\Pr\left(\key\getR\mathtt{KeyGen}(\kappa)\;:\;\A^{\mathtt{Enc}_{\key}} \text{ forges} \right)\,.
\end{align*}
%
We define by $\advauth{\NAME}(Q,R,T)$ the maximum advantage over all adversaries that make at most $Q$ encryption queries, $R$ forgery attempts, and operate in time $T$.
%

\section{\NAME: Basic Construction}\label{sec:tweetytbc}
The first approach is to apply a large tweakable blockcipher. A tweakable blockcipher $\tE:\calK\times\calT\times\calM\to\calM$ takes as input a key $k\in\calK$, a tweak $t\in\calT$, and a message $m\in\calM$, and outputs a ciphertext $c\in\calM$. It is a permutation for every choice of $(k,t)$.

For \NAME, we suggest using \emph{Threefish}, a tweakable blockcipher by Ferguson et al.~used for the Skein hash function family~\cite{FLS+11}. Threefish supports block sizes of 256, 512, and 1024 bits. The key size equals the block size, and the tweak size is $128$ bits. We focus on the largest variant, Threefish-1024, which for readability we simply denote \fish:
%
\begin{align*}
&\fish\!:\\
&\quad\algorithmicrequire\ (k,t,m)\in\bin{1024}\times\bin{128}\times\bin{1024}\,,\\
&\quad\algorithmicensure\ c\in\bin{1024}\,.
\end{align*}
%
\fish can be used for authenticated encryption directly, a construction which we dub $\NAME^\fish$. It operates on keys of size $\kappa=1024$ bits, messages can be of arbitrary length but of size at most $\mu=1023-\alpha$, and the sizes of the meta data and nonce should satisfy $\sigma+\tau\leq 127$. The ciphertexts are of size \emph{exactly} $\nu=1024-\alpha$ bits, where $\alpha$ is the size of the authentication tag. The latter is required to make decryption possible. At a high level, the encryption consists of putting $m=\pad_{1024}(\msg)$ and $t=\pad_{128}(\nonce\|\meta)$, and the ciphertext and authentication tag are derived as $\ctxt\|\auth=c$. Formally, the encryption and decryption of $\NAME^\fish$ are defined as in Algorithms~1 and 2.

%\noindent\begin{minipage}[t]{\linewidth}
%\vspace{0pt}
\begin{algorithm}[H]
\caption*{\textbf{Algorithm 1} $\mathtt{Enc}^{\fish}$}%\label{algo:Enc}
    \begin{algorithmic}[1]
        \Require{$(\key,\msg,\meta,\nonce)\in\newline\bink\times\binm\times\bint\times\bins$}
        \Ensure{$(\ctxt,\auth)\in\bin{\nu}\times\bina$}
        \State{$c \gets \fish(\key,\pad_{128}(\nonce\|\meta),\pad_{1024}(\msg))$}
        \State{\Return $(\lceil c\rceil_\nu,\lfloor c\rfloor_{\alpha})$}
    \end{algorithmic}
\end{algorithm}
\vspace{-20pt}
\begin{algorithm}[H]
\caption*{\textbf{Algorithm 2} $\mathtt{Dec}^{\fish}$}%\label{algo:Dec}
    \begin{algorithmic}[1]
        \Require{$(\key,\ctxt,\auth,\meta,\nonce)\in\newline\bink\times\bin{\nu}\times\bina\times\bint\times\bins$}
        \Ensure{$\msg\in\binm$ or $\bot$}
        \State{$m\gets \fish^{-1}(\key,\pad_{128}(\nonce\|\meta),\ctxt\|\auth)$}
        \State{$\msg\gets \unpad_{\mu+1}(\lceil m \rceil_{\mu+1})$}
        \State{\Return $ \lfloor m\rfloor_\alpha=0\;?\;\msg : \bot$}
    \end{algorithmic}
\end{algorithm}
%\end{minipage}


\desc{Security.}
In this section we formally derive the security under the assumption that \fish is a secure tweakable blockcipher, so that the security of $\NAME^{\fish}$ directly follows.
%
The security of a tweakable blockcipher $\tE:\calK\times\calT\times\calM\to\calM$ is captured by an adversary $\A$ that has adaptive two-sided oracle access to either $\tE_k$ for some secret key $k\getR\calK$, or ideal tweakable permutation $\tpi$ with tweak space $\calT$ and message space $\calM$, and tries to distinguish both worlds. Denote by $\tperm(\calT,\calM)$ the set of tweakable permutations. We define the strong PRP security of $\tE$ as
%
\begin{align*}
    &\advsprp{\tE}(\A) = \\
        &\;\;\;\left|
        \begin{array}{l}
        \Pr\left(k\getR\calK\;:\;\A^{\tE_k^{\pm}} = 1 \right)\:-\\[6pt]\quad\qquad\qquad\!\Pr\left(\tpi\getR\tperm(\calT,\calM)\;:\;\A^{\tpi^{\pm}} = 1\right)
        \end{array} \right|\,.
\end{align*}
%
By $\advsprp{\tE}(Q,T)$ we denote the maximum security advantage of any adversary $\A$ that makes $Q$ queries and runs in time $T$.

\begin{theorem}\label{thm:tbc}
    Let $n=1024$ be the state size of \fish. We have
    \begin{align*}
    \advcpa{\NAME^{\fish}}(Q,T) &\leq \advsprp{\fish}(Q,T')\,,\\
    \advauth{\NAME^{\fish}}(Q,R,T) &\leq \advsprp{\fish}(Q\!+\!R,T')\!+\!\frac{R2^{n-\alpha}}{2^n-1}\,,
    \end{align*}
    where $T'\approx T$.
\end{theorem}

\begin{proof}
    We start with the secrecy of $\NAME^{\fish}$. Let $\A$ be an adversary that makes $Q$ queries and runs in time $T$. It has access to either $\mathtt{Enc}_\key$ or $\$$. Note that $Q$ evaluations of $\NAME^{\fish}$ induce $Q$ evaluations of $\fish$. We replace $\fish$ by an ideal tweakable permutation $\tpi\getR\tperm(\bin{128},\bin{1024})$. Now, any query $\mathtt{Enc}^{\tpi}(\key, \msg, \meta, \nonce)$ is responded with
    %
    \begin{align*}
    \ctxt\|\auth = \tpi(\key,\pad_{128}(\nonce\|\meta),\pad_{1024}(\msg))\,.
    \end{align*}

    \noindent
    As $\A$ is required to be nonce respecting, every query is made under a new nonce, which means that every query initiates a new instance of $\tpi$, and $\ctxt\|\auth$ is a random $1024$-bit value. This means that $\mathtt{Enc}^{\tpi}_\key$ is perfectly indistinguishable from $\$$.

    For authenticity, the first part of the proof is identical: we replace $\fish$ by ideal tweakable permutation $\tpi\getR\tperm(\bin{128},\bin{1024})$, where now the $Q+R$ evaluations of $\NAME^{\fish}$ induce $Q+R$ evaluations of $\fish$. It remains to consider the probability to forge an authentication tag for $\NAME^{\tpi}$. By \cite{DBLP:journals/iacr/BellareGM04}, it suffices to consider any attempt and sum over all $R$ attempts. Consider any forgery attempt $(\ctxt,\auth,\meta,\nonce)$. Note that, as $\A$ is required to be nonce respecting, there has been at most one encryption query under meta data $\meta$ and nonce $\nonce$. Therefore, the value
    %
    \begin{align*}
    m = \tpi^{-1}(\key,\pad_{128}(\nonce\|\meta),\ctxt\|\auth)
    \end{align*}

    \noindent
    is randomly drawn from a set of size at least $2^n-1$, and satisfies $\lfloor m\rfloor_\alpha=0$ with probability at most $2^{n-\alpha}/(2^n-1)$.
    % This completes the proof.
    % \hfill \qed
\end{proof}
We briefly remark that the construction is even secure under \emph{release of unverified plaintext}, where $\msg$ is disclosed before tag verification is done \cite{asiacrypt/AndreevaBLMMY14}.


\section{\NAME: Expanded Tweak Space}\label{sec:tweetylrw}

The \NAME basic construction presents a rather small tweak space, limiting the sizes of the meta data and nonce. In other words, the usage of a larger nonce results in a limitation on the size of the meta data. A way to resolve this is to employ a random oracle that maps the (larger) meta data and nonce to a string of size $128$ bits, but this would significantly degrade the security of the construction to $64$ bits. Another way to enlarge the tweak space without adjusting the cipher itself is by using it in a tweakable mode of operation.

Liskov \etal~\cite{LRW02} introduced two tweakable modes of operation: while these constructions are originally designed to add a tweak input to a blockcipher, they can equally well be applied to tweakable blockciphers themselves to enlarge the tweak space. We will consider one of these constructions, which makes two evaluations of the underlying cipher:\footnote{The other construction is less relevant as it requires an additional key and needs a universal hash function with a $1024$-bit range (or smaller, in which case the security of the construction degrades).}
%
\begin{align*}
&\LRW[\fish]\!:\\
&\quad\algorithmicrequire\ (k,t,t',m)\in\bin{1024}\:\times\\
&\qquad\qquad\qquad \bin{1024}\times\bin{128}\times\bin{1024}\,,\\
&\quad\algorithmicensure\ \fish(k,t',\fish(k,t',m)\xor t)\in\bin{1024}\,.
\end{align*}
%
This construction can be used to realize $\NAME^{\LRW[\fish]}$ as illustrated in \figref{fig:LRW} and described as in Algorithms~3 and 4. The conditions on the sizes of the inputs and outputs carry over from Section~\ref{sec:tweetytbc}, with the difference that meta data should now be of size at most $\tau\leq 1023$.

% ----------------------------------------------------------------
\begin{figure}[t]
    \centering
    \resizebox{1\linewidth}{!}{%
    \begin{tikzpicture}
        [%
            auto,thick,%
            block/.style={draw,thick,rectangle,minimum height=5em,minimum width=5em},
            xor/.style={draw,circle,append after command={[shorten >=\pgflinewidth, shorten <=\pgflinewidth,] (\tikzlastnode.north) edge (\tikzlastnode.south)(\tikzlastnode.east) edge (\tikzlastnode.west)}},
            line/.style={draw, -latex',shorten <=1bp,shorten >=1bp,-angle 60}
        ]
        % box 1
        \node[block,anchor=center] (b1) at (0,0) {3fish};
        % box 2
        \node[block,anchor=center] (b2) at (4,0) {3fish};
        % oplus sign
        \node[xor,scale=1.2] (op) at (2,0) {};

        % labels
        \begin{scope}[node distance=2cm]
            \node[above of=b1] (key1) {$key$};
            \node[above of=b2] (key2) {$key$};
            \node[left of=b1]  (message) {\msg};
            \node[right of=b2] (cipher) {$\ctxt\|\auth$};
            \node[below of=b1] (tp1) {$\nonce$};
            \node[below of=b2] (tp2) {$\nonce$};
        \end{scope}
        \node[above of=op,node distance=2cm] (t) {$\meta$};
        \path[line] (b1) edge (op)
                    (op) edge (b2)
                    (message) edge (b1)
                    (b2) edge (cipher)
                    (key1) edge (b1)
                    (key2) edge (b2)
                    (tp1) edge (b1)
                    (tp2) edge (b2)
                    (t) edge (op);

    \end{tikzpicture}
    }
    \caption{\NAME based on $\LRW[\fish]$. Padding of data is excluded from the figure}\label{fig:LRW}
\end{figure}
% ----------------------------------------------------------------

%\noindent\begin{minipage}[t]{\linewidth}
%\vspace{0pt}
\begin{algorithm}[H]
\caption*{\textbf{Algorithm 3} $\mathtt{Enc}^{\LRW[\fish]}$}%\label{algo:Enc}
    \begin{algorithmic}[1]
        \Require{$(\key,\msg,\meta,\nonce)\in\newline\bink\times\binm\times\bint\times\bins$}
        \Ensure{$(\ctxt,\auth)\in\bin{\nu}\times\bina$}
        \State{$c \gets \LRW[\fish](\key,\newline
            \phantom{.}\quad\qquad\pad_{1024}(\meta),\pad_{128}(\nonce),\pad_{1024}(\msg))$}
        \State{\Return $(\lceil c\rceil_\nu,\lfloor c\rfloor_{\alpha})$}
    \end{algorithmic}
\end{algorithm}
\vspace{-20pt}
\begin{algorithm}[H]
\caption*{\textbf{Algorithm 4} $\mathtt{Dec}^{\LRW[\fish]}$}%\label{algo:Dec}
    \begin{algorithmic}[1]
        \Require{$(\key,\ctxt,\auth,\meta,\nonce)\in\newline\bink\times\bin{\nu}\times\bina\times\bint\times\bins$}
        \Ensure{$\msg\in\binm$ or $\bot$}
        \State{$m\gets \LRW[\fish]^{-1}(\key,\newline
            \phantom{.}\quad\qquad\pad_{1024}(\meta),\pad_{128}(\nonce),\ctxt\|\auth)$}
        \State{$\msg\gets \unpad_{\mu+1}(\lceil m \rceil_{\mu+1})$}
        \State{\Return $\lfloor m\rfloor_\alpha=0\;?\;\msg : \bot$}
    \end{algorithmic}
\end{algorithm}
%\end{minipage}

\medskip
\desc{Security.}
The security of $\NAME^{\LRW[\fish]}$ in fact follows from \thref{thm:tbc} and a result from \cite{LRW02}.

\begin{theorem}\label{thm:lrw}
    Let $n=1024$ be the state size of \fish. We have
    \begin{align*}
    &\advcpa{\NAME^{\LRW[\fish]}}(Q,T) \leq \Theta\!\left(\!\frac{Q^2}{2^n}\!\right)\! + \advsprp{\fish}(2Q,T')\,,\\
    &\advauth{\NAME^{\LRW[\fish]}}(Q,R,T) \leq\\
    &\qquad\Theta\!\left(\!\frac{(Q\!+\!R)^2}{2^n}\!\right)\! + \advsprp{\fish}(2(Q\!+\!R),T') + \frac{R2^{n-\alpha}}{2^n-1}\,,
    \end{align*}
    where $T'\approx T$.
\end{theorem}

\begin{proof}
    Note that the derivation in \thref{thm:tbc} not only applies to \fish, but to any tweakable blockcipher. Applied to $\LRW[\fish]$ we get
    \begin{align*}
    &\advcpa{\NAME^{\LRW[\fish]}}(Q,T) \leq \advsprp{\LRW[\fish]}(Q,T'')\,,\\
    &\advauth{\NAME^{\LRW[\fish]}}(Q,R,T) \leq\\
    &\qquad\qquad\qquad\advsprp{\LRW[\fish]}(Q\!+\!R,T'') + \frac{R2^{n-\alpha}}{2^n-1}\,,
    \end{align*}
    where $T''\approx T$. In \cite{LRW02} it is proven that
    \begin{align*}
        \advsprp{\LRW[\fish]}(Q,T'') \leq \Theta\!\left(\!\frac{Q^2}{2^n}\!\right)\! + \advsprp{\fish}(2Q,T')\,,
    \end{align*}
    where $T'\approx T''$.
    % This completes the proof. \qed
\end{proof}

% ----------------------------------------------------------------
\section{\NAME: Sponge Construction}\label{sec:tweetySponge}

The Sponge functions were originally introduced by Bertoni \etal~\cite{BDPA07} for cryptographic hashing, but can also be used in a broad spectrum of keyed applications, including message authentication~\cite{BDPA11-SKEW,ADMV15-FSE,crypto/GaziPT15} and stream encryption~\cite{BDPA11-SAC,asiacrypt/MenninkRV15}. They are also particularly useful for compact authenticated encryption, and hence to instantiate \NAME. In more detail, we suggest the following function realization, which resembles ideas of the full-state duplex mode \cite{asiacrypt/MenninkRV15}, transformed to the tweakable setting, as depicted in \figref{fig:Sponge}. We stress, however, that the keyed Sponges are merely stream based encryption, and a unique nonce is required for every encryption.


% ----------------------------------------------------------------
\begin{figure}[t]
    \centering
    \resizebox{1\linewidth}{!}{%
    \begin{tikzpicture}
        [%
            auto,thick,%
            block/.style={draw,thick,rectangle,minimum height=5em,minimum width=5em,font=\Large},
            xor/.style={draw,circle,append after command={[shorten >=\pgflinewidth, shorten <=\pgflinewidth,] (\tikzlastnode.north) edge (\tikzlastnode.south)(\tikzlastnode.east) edge (\tikzlastnode.west)}},
            line/.style={draw, shorten <=1bp,shorten >=1bp,-angle 60}
        ]
        % box 1
        \node[block,anchor=center] (b1) at (0,0) {$\pi$};
        \begin{scope}[node distance=0.7cm]
            \node (b_nw1) at (-0.7,0.5) {};
            \node (b_sw1) at (-0.7,-0.5) {};
            \node (b_ne1) at (0.7,0.5) {};
            \node (b_se1) at (0.7,-0.5) {};
        \end{scope}
        % box 2
        \node[block,anchor=center] (b2) at (5,0) {$\pi$};
        \begin{scope}[node distance=0.7cm]
            \node (b_nw2) at (4.3,0.5) {};
            \node (b_sw2) at (4.3,-0.5){};
            \node (b_ne2) at (5.7,0.5) {};
            \node (b_se2) at (5.7,-0.5) {};
        \end{scope}
        % box 3
        \node[block,anchor=center] (b3) at (10,0) {$\pi$};
        \begin{scope}[node distance=0.7cm]
            \node (b_nw3) at (9.3,0.5) {};
            \node (b_sw3) at (9.3,-0.5){};
            \node (b_ne3) at (10.7,0.5) {};
            \node (b_se3) at (10.7,-0.5) {};
        \end{scope}

        % oplus sign
        \node[xor,scale=1.2] (op1) at (1.7,0.5) {};
        \node[xor,scale=1.2] (op2) at (6.8,0.5) {};
        \node[right of=op1,node distance=1.4cm] (dot1) {\LARGE$\cdot$};
        \node[right of=op2,node distance=1.4cm] (dot2) {\LARGE$\cdot$};
        \node[right of=b_ne3,node distance=1.2cm] (dot3) {\LARGE$\cdot$};
        %\node at (12.5,0) {$\ldots$};

        % % labels
        \begin{scope}[font=\Large,node distance=2cm]
            \node[above left of=b_nw1] (tsht) {$\nonce \parallel \meta$};
            \node[left of=b_sw1] (key1) {$key$};
        \end{scope}
        \begin{scope}[font=\Large,node distance=1.4cm]
            \node[above of=op1]  (ms1) {$\msg_1$};
            \node[above of=op2] (ms2) {$\msg_2$};
            \node[above of=dot1] (ct0) {$\ctxt_1$};
            \node[above of=dot2] (ct1) {$\ctxt_2$};
            \node[above of=dot3] (ct2) {$\auth$};
        \end{scope}
        \node[font=\large,below of=dot1,node distance=2cm] {$\ctxt = \ctxt_1 \parallel \ctxt_2$};

        \draw[line] (tsht) |- (b_nw1.west);
        \path[line] (key1) edge (b_sw1)
                    (b_ne1) edge (op1)
                    (b_se1) edge (b_sw2)
                    (op1) edge (b_nw2)
                    (b_ne2) edge (op2)
                    (b_se2) edge (b_sw3)
                    (op2) edge (b_nw3)
                    (ms1) edge (op1)
                    (ms2) edge (op2);

        \draw[-angle 60] (dot1.center) -- (ct0);
        \draw[-angle 60] (dot2.center) -- (ct1);
        \draw[-angle 60] (dot3.center) -- (ct2);
        \draw (b_ne3) -- (12.5,0.5);
        \draw (b_se2) -- (8.5,-0.5);
        \draw (b_se3) -- (12.5,-0.5);

    \end{tikzpicture}
    }
    \caption{\NAME based on a Sponge. Padding of data is excluded from the figure.}
    \label{fig:Sponge}
\end{figure}
% ----------------------------------------------------------------

The realization of $\NAME^{\pi,\ell,n}$ is indexed by a permutation $\pi$ of width $b$ and two parameters $\ell$ and $n\leq b$ which specify the way it parses the message blocks: it considers at most $\ell$ message blocks of size $n$ bits. It operates on keys of size $\kappa\leq b-n$ bits, messages and ciphertexts can be of arbitrary length at most $\mu=\ell\cdot n-1$ (note that the scheme does not use ciphertext expansion, hence $\mu=\nu$), and the sizes of the meta data and nonce should satisfy $\sigma+\tau\leq n-1$. The size of the authentication tag is $\alpha\leq n$ (this bound is merely for simplicity, the scheme easily generalizes to $\alpha>n$). We additionally still require $\mu+\alpha+\tau+\sigma\leq\lambdamax$. The formal encryption and decryption functionalities are given in Algorithms~5 and 6.

%\noindent\begin{minipage}[t]{\linewidth}
%\vspace{0pt}
\begin{algorithm}[tb]
\caption*{\textbf{Algorithm 5} $\mathtt{Enc}^{\pi,\ell,n}$}%\label{algo:Enc}
    \begin{algorithmic}[1]
        \Require{$(\key,\msg,\meta,\nonce)\in\newline\bink\times\binm\times\bint\times\bins$}
        \Ensure{$(\ctxt,\auth)\in\binm\times\bina$}
        \State{$\ell'\gets\lceil (|\msg|+1)/n\rceil$}
        \State{$\msg_1\parallel\cdots\parallel \msg_{\ell'}\xleftarrow{n\text{-}\mathrm{blocks}} \pad_{\ell'\cdot n}(\msg)$}
        \State{$s_0\gets \pad_n(\nonce\|\meta)\parallel 0^{b-n-|\key|}\parallel \key$}
        \For{$i=1,\ldots,\ell'$}
            \State{$s_i\gets \pi(s_{i-1})$}
            \State{$s_i\gets s_i \xor \big(\msg_i\parallel 0^*\big)$}
            \State{$\ctxt_i\gets \lceil s_i\rceil_n$}
        \EndFor
        \State{$s_{\ell'+1}\gets \pi(s_{\ell'})$}
        \State{\Return $(\lceil \ctxt_1\parallel\cdots\parallel \ctxt_{\ell'} \rceil_{|\msg|},\lceil s_{\ell'+1}\rceil_{\alpha})$}
    \end{algorithmic}
\end{algorithm}
% \vspace{-20pt}
\begin{algorithm}[tb]
\caption*{\textbf{Algorithm 6} $\mathtt{Dec}^{\pi,\ell,n}$}%\label{algo:Dec}
    \begin{algorithmic}[1]
        \Require{$(\key,\ctxt,\auth,\meta,\nonce)\in\newline\bink\times\binm\times\bina\times\bint\times\bins$}
        \Ensure{$\msg\in\binm$ or $\bot$}
        \State{$\ell'\gets\lceil (|\ctxt|+1)/n\rceil$}
        \State{$\ctxt_1\parallel\cdots\parallel \ctxt_{\ell'}\xleftarrow{n\text{-}\mathrm{blocks}} \pad_{\ell'\cdot n}(\ctxt)$}
        \State{$s_0\gets \pad_n(\nonce\|\meta)\parallel 0^{b-n-|\key|}\parallel \key$}
        \For{$i=1,\ldots,\ell'-1$}
            \State{$s_i\gets \pi(s_{i-1})$}
            \State{$\msg_i\gets \lceil s_i\rceil_n \xor \ctxt_i$}
            \If{$i<\ell'$}
                \State{$s_i\gets \ctxt_i \parallel \lfloor s_i\rfloor_{b-n}$}
            \Else
                \State{$s_i\gets \lceil \ctxt_i \rceil_{|\ctxt|\bmod n} \parallel \lfloor s_i\rfloor_{b-(|\ctxt|\bmod n)}$}
            \EndIf
        \EndFor
        \State{$\msg\gets \lceil \msg_1\parallel\cdots\parallel \msg_{\ell'} \rceil_{|\ctxt|}$}
        \State{$s_{\ell'+1}\gets \pi(s_{\ell'})$}
        \State{\Return $\lceil s_{\ell'+1}\rceil_{\alpha}=\auth\;?\;\msg : \bot$}
    \end{algorithmic}
\end{algorithm}
%\end{minipage}

%\medskip
\desc{Security.}
$\NAME^{\pi,\ell,n}$ is in fact a full-state duplex construction~\cite{asiacrypt/MenninkRV15}, but for the sake of presentation, it is easier to explain the security of the construction in terms of the Inner-Keyed Sponge (\IKS) of Andreeva \etal~\cite{ADMV15-FSE}. This construction gets as input a key $k$, an arbitrarily sized message $m$, and a natural number $\rho$, and it outputs a digest $z$ of size $\rho$:
\begin{align*}
\IKS^\pi(k,m,\rho) = z\in\bin{\rho}\,.
\end{align*}
It is defined as the classical Sponge with an outer part of size $n$ and an inner part of size $b-n$, and with the capacity part being initialized using the key. We consider a specific case of \IKS where $\rho\leq n$, which means that the squeezing part of the Sponge takes exactly one round.

The security of variable-input-length $\IKS:\calK\times\bin{\ast}\to\bin{n}$ based on a permutation $\pi$ is slightly different from the CPA security of \secref{sec:tweety}; it differs in two aspects: first, $\IKS$ is variable length, so it is compared with a random oracle $\RO:\bin{\ast}\to\bin{n}$, and second, it is based on an underlying idealized permutation $\pi$ and the adversary also has two-sided oracle access to $\pi$. Denote by $\perm(\bin{b})$ the set of $b$-bit permutations. Abusing notation, we refer to the security of \IKS against an adversary that has access to either $(\IKS,\pi^{\pm})$ or $(\RO,\pi^{\pm})$, where $k\getR\calK$, $\pi\getR\perm(\bin{b})$, and $\RO$ is a random oracle, by
$\advcpa{\IKS}(\A)$. We define by $\advcpa{\IKS}(Q,S)$ the maximum advantage over all adversaries with total complexity $Q$, and that make at most $S$ primitive queries to $\pi^\pm$. Here, the total complexity $Q$ counts the number of \emph{fresh calls} to $\pi$ if $\A$ were conversing with $\IKS$.

Note that if no authentication is needed, then $\mathtt{Enc}^{\pi,\ell,n}$ and $\mathtt{Dec}^{\pi,\ell,n}$ do not require the computation of $s_{\ell'+1}\gets \pi(s_{\ell'})$ at the end, which saves a permutation call. Related to this, we define $\ell_\alpha$ as follows.
\begin{align*}
\ell_\alpha =
    \begin{cases}
    \ell\,, \text{ if }\alpha=0\,,\\
    \ell+1\,, \text{ if }\alpha>0\,.
    \end{cases}
\end{align*}

\begin{theorem}\label{thm:Sponge}
    Assume $\pi\getR\perm(\bin{b})$ is an ideal permutation. We have
    %
    \begin{align*}
    \advcpa{\NAME^{\pi,\ell,n}}(Q,T) &\leq \frac{(\ell_aQ)^2}{2^{b-n}} + \frac{\ell_aQS}{2^\kappa}\,,\\
    \advauth{\NAME^{\pi,\ell,n}}(Q,R,T) &\leq \frac{(\ell_aQ)^2}{2^{b-n}} + \frac{\ell_aQS}{2^\kappa} + \frac{R}{2^\alpha}\,.
    \end{align*}
    %
    where $S$ is the maximal number of evaluations of $\pi$ that can be made in time $T$.
\end{theorem}

\begin{proof}
    Let $\A$ be an adversary that makes $Q$ queries and runs in time $T$. It has access to either $\mathtt{Enc}_\key$ or $\$$. Consider any evaluation $\mathtt{Enc}_\key$ on input of $(\msg,\meta,\nonce)$. If we define $k=0^{b-n-|\key|}\|\key$, then its output is as follows,
    %

    \noindent
    \scalebox{0.76}{\begin{minipage}{\linewidth}
    \begin{align*}
    \ctxt=&\;\IKS^\pi(k,\pad_n(\nonce\|\meta),n) \xor \msg_1 \parallel\\
         &\;\IKS^\pi(k,\pad_n(\nonce\|\meta)\| \msg_1,n) \xor \msg_2 \parallel\\
         &\;\IKS^\pi(k,\pad_n(\nonce\|\meta)\| \msg_1,n) \xor \msg_2 \parallel\\
         &\;\cdots\,\\
         &\;\IKS^\pi(k,\pad_n(\nonce\|\meta)\| \msg_1\cdots \msg_{\ell-2},n) \xor \msg_{\ell-1} \parallel\\
         &\;\lceil\IKS^\pi(k,\pad_n(\nonce\|\meta)\| \msg_1\cdots \msg_{\ell-1},n) \xor \msg_\ell\rceil_{|\msg|\bmod n}\,,\\
    \auth=&\;\IKS^\pi(k,\pad_n(\nonce\|\meta)\| \msg_1\cdots \msg_{\ell},\alpha)
    \end{align*}
    \end{minipage}}

\bigskip
\noindent
Where abusing notation, $|\msg|\bmod n\in\{1,\ldots,n\}$. In other words, any evaluation of $\mathtt{Enc}_\key$ entails $\ell_\alpha$ evaluations of $\IKS$ (the computation of $\auth$ is omitted if $\alpha=0$). Each of these evaluations adds $1$ to the complexity (as it is simply an extension of the previous one). Thus, after $Q$ evaluations of $\mathtt{Enc}_\key$, \IKS is evaluated with a total complexity $\ell_a Q$. We replace $\IKS$ by a random oracle $\RO$. This step costs us $\advcpa{\IKS}(\ell_a Q,S)$, where $S$ is as described in the theorem statement.

    Now, for the case of secrecy, recall that $\A$ is nonce respecting. Consequently, all evaluations of $\RO$ are made for a different input. This is clear for the $\ell+1$ queries for a single evaluation; different evaluations of $\mathtt{Enc}_\key$ are made under a different $\nonce$ as the adversary is nonce respecting. Consequently, every query to $\mathtt{Enc}_\key$ is responded with a uniformly randomly generated $|\msg|$-bit value, and thus,
    \begin{align*}
    \advcpa{\NAME^{\pi,\ell,n}}(Q,T) \leq \advcpa{\IKS}(\ell_a Q,S)\,.
    \end{align*}
    Next, for authenticity, it suffices to only focus on the value $\auth$. Consider any forgery attempt $(\ctxt,\auth,\meta,\nonce)$. Let $\msg$ be the message that is derived by $\mathtt{Dec}^{\pi,\ell,n}$. As the forgery is required to be non-trivial, $\RO$ has never been queries on
    \begin{align*}
    \pad_n(\nonce\|\meta)\| \msg_1\cdots \msg_{\ell}
    \end{align*}
    before. Its response $\auth$ is thus a randomly generated value and the forgery is successful with probability $1/2^\alpha$. Again using \cite{DBLP:journals/iacr/BellareGM04},
    \begin{align*}
    \advauth{\NAME^{\pi,\ell,n}}(Q,R,T) \leq \advcpa{\IKS}(\ell_a Q,S) + \frac{R}{2^\alpha}\,.
    \end{align*}
    Now, in \cite{ADMV15-FSE} it is proven that\footnote{We have slightly re-interpreted the result in order to accommodate the different key length.}
    \begin{align*}
    \advcpa{\IKS}(Q',S) \leq \frac{(Q')^2}{2^{b-n}} + \frac{Q'S}{2^\kappa} \,,
    \end{align*}
    which completes the proof of both secrecy and authenticity.
    % This completes the proof.
    % \qed
\end{proof}

\medskip
\desc{Instantiation.}
For $\pi$, we suggest to use the Keccak permutation $\keccak:\bin{1600}\to\bin{1600}$, and the following specific choices of $(\ell,n)$. As the complexity of the {$\NAME^{\keccak,\ell,n}$} increases linearly in $\ell$, we suggest to use $\ell\leq 2$. If $\ell=1$ and $n=1024$, the messages can be of size at most $1024$ bits, and $\nonce\|\meta$ is of size at most $1023$ bits. Security up to approximately $\frac{1600-n}{2}=288$ is achieved. In contrast, taking $\ell=2$ and $n=576$ gives flexible message lengths, $\nonce\|\meta$ should be of size at most $575$, and $512$-bit security is achieved.



\section{Applications of \NAME}

In this section we discuss the practical application of the \NAME constructions on different scenarios and use cases: low-latency messaging, secure mix-formatting and microblogging. However, we stress that \NAME is suitable to any application requiring a compact output with high efficiency and security benefits.

\subsection{Secret Messaging}\label{sec:secmsg}

The popularity of secret message services has been increasing since Edward Snowden's whistleblowing events. Secret message protocols such as OTR~\cite{wpes/BorisovGB04}, TextSecure\footnote{https://whispersystems.org/}, and Wickr\footnote{https://wickr.com/} have been deployed into widely used mobile application. Most use common symmetric encryption schemes under an authenticated mode of operation, such as AES-CCM. In addition, each scheme requires a re-keying protocol for providing a different session key for each communication to provide forward secrecy. The usage of \NAME in such protocols allows for greater security and efficiency (for short messsages) and provides the possibility to use these protocols through the common text messaging channel, which is also limited to 140 characters for each message.

One recent proposal that would be especially suitable to be instantiated with AITO is Vuvuzela \cite{van2015vuvuzela}. The anonymity provided by Vuvuzela is better than what many other systems (e.g. Tor) can provide, but the proposed implementation is geared towards short messages (240 bytes of content). Vuvuzela has also a much better performance than previous systems that provide strong anonymity. 

AITO could be used with the Vuvuzela framework to provide greater security for the message contents together with the extreme anonymity of messaging. This would mean slightly shorter message content. The system design  would not need to be changed or modified, but the implementation would only change from their proposed cryptographic library to one with support for \NAME.
%How deep into details should we go?

\subsection{Secure Mix Formatting}\label{sec:applmix}
Mix networks rely on (cryptography based) mix message formats that provide nice efficiency and security properties. Sphinx~\cite{sp/DanezisG09} is the most compact cryptographic mix message format which is provably secure and efficient. To deliver such properties Sphinx relies on the \emph{Sphinx blinding logic} technique for generating a session key consisting of nested MAC computations over the public pseudonyms of each predecessor mix. The private key associated to the public key (i.e., pseudonym) is only known by the user, while the session key is used for the encryption of the payload message.



Internally, Sphinx uses a plurality of cryptographic primitives. Firstly, there are five hash functions, which are used to cryptographically hash group elements to key bit strings. Then, it uses a pseudorandom generator and a MAC function for the computation of the nested MAC. Finally, it uses an encryption scheme that encrypts the payload at every mix.

% The hash functions are instantiated using appropriately truncated SHA256 hash functions, using SHA256-HMAC-128 as the MAC function.
For the encryption, Sphinx relies on the LIONESS blockcipher by Anderson and Biham~\cite{DBLP:conf/fse/AndersonB96a}. This blockcipher is made out of the SEAL stream cipher and a keyed version of the SHA-1 hash function, and evaluates these functions on the message via a Feistel structure. In more detail, denote the stream cipher by $S_k$ and the keyed hash function by $H_k$. Consider a LIONESS key $k=(k_1,k_2,k_3,k_4)$, where $k_1,k_3$ will be used to key the stream cipher and $k_2,k_4$ to key the hash function. To encrypt a message $m$, LIONESS first splits it into two blocks $m_l\|m_r\gets m$. These two blocks are then transformed using a four-round Feistel structure:
\begin{align*}
m_r &\gets m_r\xor S_{k_1}(m_l)\,,\\
m_l &\gets m_l\xor H_{k_2}(m_r)\,,\\
m_r &\gets m_r\xor S_{k_3}(m_l)\,,\\
m_l &\gets m_l\xor H_{k_4}(m_r)\,.
\end{align*}
The updated $m_l\|m_r$ constitutes the ciphertext $c$.

LIONESS enjoys a security proof if the underlying hash function SHA-1 and stream cipher SEAL are secure~\cite{DBLP:conf/fse/AndersonB96a}, therewith making it particularly useful for Sphinx because of its goal to achieve provable security. However, LIONESS dates back to 1996, and has been outpaced by reality. In more detail, attacks on SEAL~\cite{DBLP:conf/fse/Fluhrer01a} and SHA-1~\cite{DBLP:conf/crypto/WangYY05a,DBLP:conf/asiacrypt/CanniereR06,DBLP:conf/eurocrypt/Stevens13,DBLP:conf/crypto/KarpmanPS15,DBLP:journals/iacr/StevensKP15}, the most recent result being a free-start collision attack on the full SHA-1, shine a negative light on the security of the LIONESS mode.

A naive solution to this situation is to replace SEAL by a more modern stream cipher and to replace SHA-1 by SHA-3, but there is little point in doing so: versatility of Sponges in general and SHA-3 in particular enables encryption using SHA-3 on the fly; putting a four-round Feistel construction on top of it is overkill. Instead, it makes more sense to simply \emph{replace} LIONESS by a keyed version of the SHA-3. The \NAME Sponge construction of Section~\ref{sec:tweetySponge} is particularly suited for this purpose, as it is an authenticated encryption scheme based on the SHA-3 permutation. In this way, it seems logical to also replace the other cryptographic functionalities in Sphinx by SHA-3 or SHA-3 based alternatives. Alternatively, one can use the Threefish based version of \NAME (\secref{sec:tweetytbc} or \secref{sec:tweetylrw}), and use the Skein hash function family~\cite{FLS+11} to serve for hashing, as it already uses Threefish natively.


Either approach makes the encryption functionality of Sphinx more secure and more efficient. \figref{fig:sphinx} depicts a generic depiction of using \NAME on Sphinx, such that, the Sphinx header on each Mix $n$ is composed by the tuples $(\alpha,\beta,\gamma)$ and $\delta$ the payload message. In addition, \NAME facilitates the twofold advantages: it supports tweaks an input which could be used for the processing of the header, and it allows for authentication, and could potentially be used as MAC function. These advantages could be exploited to integrate part of the nested MAC functionality of Sphinx within \NAME. As a bonus, Sphinx using \NAME \emph{additionally} authenticates the payload for free, a feature that was missing in the original Sphinx.


% ------------------------------------------------------------------------
\begin{figure}[t]
    \centering
    \resizebox{1\linewidth}{!}{%
    \begin{tikzpicture}%
    [%
        auto,font=\small\sffamily,
        myarrow/.style={-angle 60,>=stealth',shorten >=1pt}
    ]
        % Top rectangle
        \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=2pt] (7,4) -- (0,4);
        \node at (3.5,5) {Sphinx Header};

        \draw [fill=white] (0,3) rectangle (1,4);
        \node at (0.5,3.5) {$\alpha$};
        \draw [fill=white] (1.1,3) rectangle (5,4);
        \node at (3,3.5) {$\beta$};
        \draw [fill=white] (5.1,3) rectangle (7,4);
        \node at (6,3.5) {$\gamma$};
        %
        \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=2pt] (10,4) -- (7.1,4);
        \node at (8.5,5) {Payload};
        \draw [fill=white] (7.1,3) rectangle (10,4);
        \node at (8.5,3.5) {$\delta$};% $\tau = t - \mu$};
        

        % encrypt block
        \draw [fill=white] (1,1) rectangle (5.5,2);
        \node[font=\normalsize] at (3.25,1.5) {Sphinx Mix Header};


        % encrypt block
        \draw [fill=gray!30,very thick] (7.5,1) rectangle (9.5,2);
        \node[font=\normalsize] at (8.5,1.5) {\NAME};

        % Bottom rectangles ....
        % left
        \draw [fill=white] (0,-1) rectangle (1,0);
        \node at (0.5,-0.5) {$\alpha'$};
        \draw [fill=white] (1.1,-1) rectangle (5,0);
        \node at (3,-0.5) {$\beta'$};        
        \draw [fill=white] (5.1,-1) rectangle (7,0);
        \node at (6,-0.5) {$\gamma'^*$};
        \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=2pt] (0,-1) -- (10,-1);
        \node at (5,-1.75) {Route to Mix $n'$};
        % \node at (3.5,-1) {Tweakable blockcipher Output};

        \draw [fill=white] (7.1,-1) rectangle (10,0);
        \node at (8.5,-0.5) {$\delta'$};

        \node[font=\normalsize\sffamily] at (-0.1,2.3) {Mix $n$};
        \node[font=\normalsize\sffamily] (secret) at (-0.1,1.9) {secret $x_n$};

        \begin{scope}[myarrow,thick]
          \draw (secret) |- (1,1.5);
          \draw (5.5,1.75) -- (7.5,1.75);
          \draw (0.5,3) -- (0.5,2.5) -- (1.5,2.5) -- (1.5,2); % alpha
          \draw (3,3) -- (3,2); % beta
          \draw (6,3) -- (6,2.5) -- (5,2.5) -- (5,2); % gamma
          \draw (8.5,3) -- (8.5,2);
          % 
          \draw (1.5,1) -- (1.5,0.5) -- (0.5,0.5) -- (0.5,0); % alpha
          \draw (3,1) -- (3,0); % beta
          \draw (6,3) -- (6,2.5) -- (5,2.5) -- (5,2); % gamma
          \draw (8.5,1) -- (8.5,0);
          \draw (8.5,0.5) -- (6.3,0.5) -- (6.3,0);
          \draw (3,0.4) -- (5.8,0.4) -- (5.8,1.15) -- (7.5,1.15);  
          \draw (5,1) -- (5,0.6) -- (5.8,0.6);
        \end{scope}
        

        % concat
        \draw[fill=white] (5.8,0.5) circle (0.3cm);
        \node at (5.8,0.5) {$\parallel$};
        \node at (6.5,2.1) {session key $s_n$};
        \node at (7.25,0.7) {$auth$ tag};
        \node at (6.5,1.4) {$(\beta' \parallel \gamma')$};
        \node at (4.8,0.75) {$\gamma'$};
        \node at (3.25,0.6) {$\beta'$};
        % 
    \end{tikzpicture}
    }
    \caption{Using \NAME on Sphinx to process a Sphinx message $( (\alpha,\beta,\gamma),\delta)$ into $( (\alpha',\beta',\gamma'^*),\delta)$ at Mix $n$ with the secret $x_n$. Note that the key derivation from $s_n = \mathsf{keyderive}(\alpha, x_n)$, blinding $\alpha_n = \mathsf{blind}(\alpha,s_n)$, and $(\beta,\gamma) \rightarrow (\beta',\gamma')$ computations occur as in Sphinx original version (see. Figure~3 from \cite{sp/DanezisG09}). The session key $s_n$ is used as the key, whereas the header $(\beta',\gamma')$ is used as metadata on the input of \NAME. }
    \label{fig:sphinx}
\end{figure}
% ------------------------------------------------------------------------

\subsection{Microblogging}\label{sec:applmicro}

The text input size limitation on microblogging systems, such as Twitter or Instagram, makes \NAME\ a particularly suitable solution for sharing secret messages with a high level of security (significantly higher than ordinary encryption modes). We acknowledge that sharing secret messages on these systems may not be ideal for the broadcast messaging setting, however it is useful for sharing private messages among a segregated audience.

The high level idea of applying \NAME to microblogging is as follows:

\begin{itemize}
  \item The time stamp of a tweet functions as the nonce $\nonce$;
  \item The hashtags (or part of them) function as a public meta data $\meta$;
  \item The tweet itself (and some hashtags, if needed) are authenticated and encrypted.
\end{itemize}
%
We denote the time stamp by $\tstamp$ and the hashtags by $\hasht$. Due to the Twitter limitation on 140 characters, we take $\lambdamax=1120$ bits, but we can abuse the fact that the time stamp is implicit in the tweet. In other words, we require that $\nu+\alpha+\tau\leq1120$. We remark that the Unix time stamp is conventionally written in $32$ bits. This makes all three constructions of \NAME\ suitable for the application. %This is enough until January 19, 2038, before which all systems should be migrated to $64$-bit stamps.

Without loss of generality, we consider users to be registered, use, and share private information on any Twitter-like systems. We also assume that users share a symmetric key using auxiliary out-of-band channels. For example, the users could employ the techniques from \cite{gunther2012cryptographic} to share the necessary keys with the intended recipients. This would also provide some anonymity for the audience as stated in \cite{gunther2012cryptographic}. In the most simple case, the users can get the keys by performing an authenticated Diffie-Hellman or by simply encrypting the secret with the public keys of the intended recipients. However, the exact details for this key exchange are beyond the scope of \NAME mechanism and this paper.

For a specific instantiation, we suggest the framework of \figref{fig:twitteroverview}. \NAME operates by parsing a $1120$-bit tweet into a message/hashtag-tuple $(\msg,\hasht)\in\binm\times\bint$. Using the time stamp $\tstamp\in\bins$, it is then encrypted to a ciphertext $\ctxt\in\binn$ and authenticated using tag $\auth\in\bina$ (absent if no authentication is needed, in which case we have $\alpha=0$). Thus, the encrypted tweet is of the form $(\ctxt,\auth,\hasht)\in\binn\times\bina\times\bint$ (the time stamp $\tstamp$ is implicit from the tweet).
%
In this configuration, nonce respecting behavior of users corresponds to them being ``time stamp respecting,'' and we assume that two tweets under the same secret key are never encrypted with the same time stamp.


% ------------------------------------------------------------------------
\begin{figure}[t]
    \centering
    \resizebox{0.95\linewidth}{!}{%
    \begin{tikzpicture}%
    [%
        auto,font=\small\sffamily,
        myarrow/.style={-angle 60,>=stealth',shorten >=1pt}
    ]
        % Top rectangle
        \draw [fill=white] (0,4.5) rectangle (10,5.5);
        \node at (5,5) {total size $t = 1120~bits$ (UTF-8 \emph{140 ``[A-Za-z0-9\_]'' characters)}};
        \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=2pt] (10,5.5) -- (0,5.5);
        \node at (5,6.5) {Normal Tweet};

        \draw [fill=white] (0,3) rectangle (7,4);
        \node at (3.5,3.5) {message (\msg)};
        %
        \draw [fill=white] (7.1,3) rectangle (10,4);
        \node at (8.5,3.5) {\#hashtags (\hasht)};% $\tau = t - \mu$};
        %
        \draw[dashed,thin] (0,4) -- (0,4.5);
        \draw[dashed,thin] (10,4) -- (10,4.5);

        % encrypt block
        \draw [fill=gray!30,very thick] (4,1.5) rectangle (6,2.5);
        \node at (5,2) {\NAME};

        % Bottom rectangles ....
        % left
        \draw [fill=white] (0,0) rectangle (7,1);
        \node at (3.5,0.5) {encryption (\ctxt) and authentication tag (\auth)};
        \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=2pt] (0,0) -- (10,0);
        \node at (5,-1) {\NAME (Encrypted) Output};
        % \node at (3.5,-1) {Tweakable blockcipher Output};

        % right
        \draw [fill=white] (7.1,0) rectangle (10,1);
        \node at (8.5,0.5) {\#hashtags (\hasht)};

        \draw[myarrow,thick] (5,3) -- (5,2.5);
        \draw[myarrow,thick] (5,1.5) -- (5,1);
        \draw[myarrow,thick,angle 60-angle 60] (8.5,1) |- (6,2);
        \draw[thick] (8.5,2) -- (8.5,3);
        \node (l) at (2,2.3) {$\key$};
        \node (t) at (2,1.7) {$\tstamp$};
        \draw[myarrow,thick] (l) -- (4,2.3);
        \draw[myarrow,thick] (t) -- (4,1.7);
        %
    \end{tikzpicture}
    }
    \caption{Using \NAME for microblogging to share private messages, while allowing filtering and providing limited data utility through the hashtags.}
    \label{fig:twitteroverview}
\end{figure}
% ------------------------------------------------------------------------

Moreover, other privacy-friendly architectures have been suggested to replace existing platforms. Hummingbird~\cite{sp/CristofaroSTW12} presents a variant of Twitter that provably guarantees confidentiality of tweet contents, hashtags, and follower interests. Hummingbird bases its design on private set intersection methods~\cite{asiacrypt/CristofaroKT10} to match the authorized followers to the private tweets, and uses blockcipher to protect content.

\section{Practical Analysis}

In this section we discuss the practical result of \NAME, with respect to its performance and possible implementation. In order to demonstrate the compact design, effieciency, and filtering of content through hashtags, we have implemented a proof-of-concept of the microblogging use case on Twitter.

    \subsection{Performance}\label{sec:applmicro-comparison}
        \tabref{tab:comparison} gives a summary of the performances of the three instantiations of \NAME in the context of microblogging. In all cases, we take $\lambdamax=1120$ and $\sigma=|\tstamp|\leq64$, and for simplicity, this summary omits authentication (hence $\alpha=|\auth|=0$). We see that the three options for \NAME are mutually competitive, but all of them significantly outperform a classic mode like AES-CBC. This is caused by that fact that AES only has an 128-bit state, and hence a mode of operation has to be placed on top. Consequently, such a scheme on the one hand requires no less than $8$ blockcipher invocations, and on the other hand achieves only $128$-bit security (and distinguishing attacks can be performed in a complexity of about $2^{64}$~\cite{BDJR97}).
        \begin{table*}[tb]
            \centering
            \rowcolors{3}{}{lightgray}
            \caption{Comparison of the different versions of \NAME without authentication, compared with AES-CBC. A size is ``flex'' if it can take any value up to the trivial upper bounds ($|\ctxt|+|\hasht|\leq1120$ bits and $|\tstamp|\leq64$ bits). The size of the key is omitted, as it is always possible to take a key of size at least the security bound}\label{tab:comparison}
            \scalebox{1.2}{\begin{tabular}{@{\quad\:\,}lcccccccccc@{\quad\:\,}}
                %\toprule
                &\phantom{xxx}& \multicolumn{3}{c}{Size of} &\phantom{xxx}& \multicolumn{3}{c}{Efficiency} &\phantom{xxx}& Security\\
                %
                \cmidrule{3-5}\cmidrule{7-9}\cmidrule{11-11}
                %
                && $\ctxt$ &\phantom{xx}& $\hasht\|\tstamp$ && \phantom{\:}primitive\phantom{\:}           &\phantom{xx}& c/b           && bits\\
                %
                \midrule
                %
                AES-CBC         && flex       && flex     && $8\cdot$AES       && 16.0          && 64 \\
                %
                \fish          && 1024       && $<\!128$&& $1\cdot$\fish     && 6.5           && 512 \\
                %
                $\LRW[\fish]$  && 1024       && flex     && $2\cdot$\fish     && 13            && 512 \\
                %
                $\keccak,\ell,n$&&$\leq\!\ell\!\cdot\!n$&&$<\!n$&& $\ell\cdot$\keccak&& $\ell\cdot$12.5&& $\frac{1600-n}{2}$\\
                %
                $\phantom{\keccak,}\!\:1,1024$&&$\leq\!1024$&&$<\!1024$&& $1\cdot$\keccak&& 12.5&& $288$\\
                %
                $\phantom{\keccak,}\!\:1,800$&&$\leq\!800$&&$<\!800$&& $1\cdot$\keccak&& 12.5&& $400$\\
                %
                $\phantom{\keccak,}\!\:2,576$&& flex &&$<\!576$&& $2\cdot$\keccak&& 25&& $512$\\
                %\bottomrule
            \end{tabular}
            }
        \end{table*}

    \subsection{Implementation}\label{sec:applmicro-prototype}
        %
        To demonstrate the viability of our proposal, we implemented a proof-of-concept prototype \NAME-App as a Firefox extension.\footnote{Source of our implementations is freely available upon request.}
        %
        The current prototype is compatible with Firefox 14+, but it could be easily ported to other browsers extensions, e.g., to Chrome, as it is written in simple Javascript.
        Specifically, the \texttt{Enc} and \texttt{Dec} operations are as follows:

        \begin{description}
            \item[]\texttt{Enc:} The user selects the Twitter text input area, and the extension launches a dialog where the user inserts the secret message and the public hashtags. The extension encrypts using the message, the hashtag, with the server time stamp, and the key as input and publishes the result into the Twitter text area.
            \smallskip
            \item[]\texttt{Dec:} The Firefox extension parses the messages on the Twitter-feed, and for each message transparently decrypts and replaces the result with the secret message.
        \end{description}
        %

        \medskip
        \desc{\boldmath{\NAME}.} The cryptographic module of \NAME-App comprises the Javascript implementation of the \NAME cipher designs based on Threefish, allowing easy portability to other browser implementations, e.g., Chrome. However, in order to increase performance, the \NAME cryptographic module can also be used, interacting with Firefox through a local socket connection. In particular, the different instantiations of \NAME were implemented using the available C libraries for Threefish and Keccak: Skein3Fish\footnote{\url{https://github.com/wernerd/Skein3Fish}} and KeccakCodePackage,\footnote{\url{https://github.com/gvanas/KeccakCodePackage}} respectively.
        % Therefore, the performance of \NAME-Sponge (2 permutations of Keccak-1600) takes approximately 4~$ms$, whereas \NAME-Threefish-1024 takes also about 5~$ms$. Hence
        The performances comply with the data from \tabref{tab:comparison}.

        %
        For the sake of simplicity, the \NAME implementation uses a passphrase as input to a key derivation function to generate the secret key, whereas the exchange of the key is assumed to be performed using a secure and authenticated offline channel. However, the secret key distribution could be made by posting a QR code image containing the encryption of the secret key using the public key of the intended recipients.
        %
        In addition, while it only supports desktop browsers at the moment, \NAME-App is perfectly suitable for resource-constrained devices, such as smartphones.
        This is crucial considering that a significant portion of users access Twitter via their mobile devices. Even the somewhat increased size of the key will not be a problem in these settings.

        \medskip
        \desc{Encoding of Messages.}
        As aforementioned, Internet services like Twitter use UTF-8 to encode shared messages. Thus, the bit length of a 140 character message is not constant, as the representation of a UTF-8 encoded character can be range between 1--4 bytes.\footnote{See for example \url{unicode.org/faq/utf_bom.html}} However, if only ASCII characters are used, then UTF-8 encoding will only take one byte per character, and we get the $8\times140 = 1120$ bits that is used as a starting point of our constructions.

        One problem with UTF-8 encoding is that after encryption, when we have an arbitrary sequence of bits, it is likely that it is no longer valid UTF-8 and thus we need to do some encoding for the ciphertext. In our implementation we have chosen to encode two bytes (16 bits) of the ciphertext into a single UTF-8 character and thus get more than enough space for any expansion and/or overhead that the encryption might induce. The encoding works by simply mapping the two bytes into the Unicode character table\footnote{See for example \url{http://unicode-table.com/en/}} and encoding this character as valid UTF-8.

        Traditional encoding schemes for encrypted data are base64 and base56, but these schemes' overhead will not allow encrypted and encoded tweets to be represented in only single tweets as the textual output is much longer than 140 characters if we have 1120 bits (or more) of ciphertext. With our encoding, it is possible to have the ciphertext in a single tweet, although the actual binary length of our encoding can add more overhead than the traditional schemes in some cases. This is of course specific to Twitter and UTF-8 encoding and in other possible applications the encoding can be done in other ways that are most suitable to that OSN.

% ----------------------------------------------------------------
%\section{Related Work}\label{sec:relatedwork}
% \bart{TODO OLD.}
% Along with the increased popularity of OSNs several privacy concerns start to arise which have prompted a large interest within the research community. As a result, several privacy-preserving solutions have been proposed to deliver OSN content confidentiality by means of existing cryptographic mechanisms. However, there is a lack of tailored designs that take into account the space limitation and the general design of OSNs. For instance, systems like FaceCloak~\cite{cse/LuoXH09} use blockciphers under different modes of operation such as AES-CBC to protect the content. Scramble~\cite{pet/BeatoKW11} and FSEO~\cite{codaspy/BeatoICPL13} use a broadcast encryption mechanism that encrypts the content using a blockcipher under a mode of operation. It attaches a header with the public-key encryptions of the key used by the blockcipher, representing the access control list of the content. Similarly, Persona~\cite{sigcomm/BadenBSBS09} and EaSiER~\cite{asiaccs/JahidMB11} use attribute-based encryption mechanisms to protect confidentiality while allowing access control definition by attributes.

% Tweetcipher~\cite{other/tweetcipher} was presented by a group of cryptographers as a compact authenticated encryption algorithm initiated through Twitter discussions. Although Tweetcipher is based on Sponge and Salsa20~\cite{estream/salsa20} constructions, it aims at delivering authentication and requires six tweets, whereas \NAME requires only one tweet with easy re-keying and public hashtags. \bart{In fact, Tweetcipher is a cipher that fits in 6 tweets, it isn't suggested for Tweets, is it?}

%
% In general, such constructions require large entropy which may not be allowed by OSNs like Twitter. Also those constructions demand at least $8$ AES evaluations achieving only $64$-bit indistinguishability security. Aligned with the fact that general tweets are of a relatively short (but larger than $128$ bits) length, the dedicated constructions presented by the different \NAME approaches achieve higher efficiency results and a much higher level of security. This can be seen from \tabref{tab:comparison}. In addition, \NAME can be used together with the broadcast and attribute-based encryptions solutions as a tailored symmetric encryption, and with Hummingbird system for protecting tweets.

% ----------------------------------------------------------------
% \section{Conclusions}
% ----------------------------------------------------------------
\section{Discussion and Conclusions}\label{sec:concl}
This paper presented \NAME, a novel family of compact authenticated encryption (AE) schemes, that employs tweakable blockciphers and the Sponge permutation to achieve provable security that is greater than with existing mechanisms and systems, and naive constructions from normal blockciphers.

We also gave three use cases for this new scheme. First, we discussed the use of \NAME in direct messaging applications and protocols such as OTR, where it can be used to offer AE for short messages. Second, \NAME can be utilized in secure mix networks, especially in the Sphinx mix network, to provide better security and efficiency for the cryptographic headers required for the mixing. Finally, \NAME can be used to offer AE for short messages on OSNs and microblogging services, such as Twitter and Instagram. To this means, we also demonstrated through a proof-of-concept prototype for the final use case on Twitter the practicality of \NAME.

Although AE is possible with existing general blockciphers, such as AES-128, these solutions do not provide similar level of security and efficiency as \NAME when applied to compact data. This is also demonstrated in \tabref{tab:comparison}: security of the \NAME system goes up to approximately $512$ bits, while encrypting more efficiently than, for instance, AES-CBC.\footnote{The c/b's in the table are in fact derived from the speed of the Keccak permutation, AES-CBC, and $\fish$ on an Intel Core 2 for long messages \cite{Cryptopp,FLS+11,BDPA12}. These are included in the table for comparison.}
%
%Furthermore, in order to fit more information than the common 1120 bits (i.e., 140 characters using Latin UTF-8 alphabet) into single tweets, one could employ bit packing schemes. For instance, by using larger character sets, such as emoji characters and Chinese characters, one can accommodate extra information as these characters are larger than 8 bits.
%
% This requires that the overhead of the encryption and other information is embedded in the 140 characters allowed by Twitter for single tweets by encoding the overhead and cryptotext in some character set larger than the original.
%
% In \NAME, this is not necessary, if one adheres to UTF-8 and basic Latin alphabet. To accommodate other character systems and also even emoji, one could extend \NAME with some bit packing scheme.

%
% Our application does not provide key exchange between the participants and this can be seen as a limitation of our system. We assume that this key exchange can take place in whatever means the users of the system feel is best for their intentions. It can be offline or online (based on some PKI). \NAME can then be used after the key has been agreed upon and distributed to the necessary recipients.

%
It is worth noting that \NAME is proven secure against nonce respecting adversaries. For our application to microblogging, this translates to time stamp respecting adversaries. In the case of protection against time stamp misuse, for example by the OSN itself, the \NAME can accommodate a client generated time stamp. This would add some overhead (of 32 bits), but could protect against this type of attack. For the two Threefish based constructions the security of the schemes against time stamp misusing adversaries is achieved with a slight security degradation, the proof of which is similar to the ones in \secref{sec:tweetytbc} and \secref{sec:tweetylrw}. For the Sponge based construction, time stamp misuse resistance cannot be achieved as the adversary can learn the XOR of two ciphertexts. Adding a client generated explicit time stamp would make the use of the plain Threefish construction harder due to the limited size of the tweak space, but the other two options would still be viable. In any case, there are many incentives for a platform such as Twitter to remain honest, such as bad publicity.

As our work demonstrates, it is possible to achieve increased security for AE in compact messages with novel designs such as \NAME. Topics for future research would be to find more applications for this type of AE schemes as well as potentially new AE schemes for compact messages besides \NAME. 
% In particular, realizing the full potential of \NAME in Sphinx could be a beneficial and interesting research topic for increased privacy.

    %\bigskip\noindent\textsc{Acknowledgments. }This work was supported in part by the Research Council KU Leuven: GOA TENSE (GOA/11/007). Bart Mennink is a Postdoctoral Fellow of the Research Foundation -- Flanders (FWO).

% ----------------------------------------------------------------
\bibliographystyle{acm}
\bibliography{tweetybib}

\end{document}

